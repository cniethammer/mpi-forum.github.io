<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Use of General Datatypes in Communication</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node109">6.1.11. Use of General Datatypes in Communication</span></h2>
<a href="node108.htm#Node108"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node110.htm#Node110"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node110.htm#Node110"> Correct Use of Addresses</a>
<b>Previous: </b><a href="node108.htm#Node108"> Duplicating a Datatype</a>
<p>
  
<P> 
Handles to derived datatypes can be passed to a communication call wherever a  
datatype argument is required.  
A call of the form <font face="sans-serif"> MPI_SEND</font><font face="sans-serif"> (buf, count, datatype, ...)</font>, where  
<i><span style="font-family:sans-serif;"> count</span> &gt; 1</i>, is interpreted as if the call was passed a new datatype  
that is the  
concatenation of <font face="sans-serif"> count</font> copies of <font face="sans-serif"> datatype</font>.  
Thus,  
<font face="sans-serif"> MPI_SEND</font><font face="sans-serif"> (buf, count, datatype, dest, tag, comm)</font> is equivalent to,  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>MPI_TYPE_CONTIGUOUS</b>(count, datatype, newtype) 
<b>MPI_TYPE_COMMIT</b>(newtype) 
<b>MPI_SEND</b>(buf, 1, newtype, dest, tag, comm) 
<b>MPI_TYPE_FREE</b>(newtype). 
</tt></pre> 
  
Similar statements apply to all other communication procedures that have a  
<font face="sans-serif"> count</font> and <font face="sans-serif"> datatype</font> argument.  
<P> 
Suppose that a send operation <font face="sans-serif"> MPI_SEND</font><font face="sans-serif"> (buf, count,  
datatype, dest, tag, comm)</font> is executed, where  
<font face="sans-serif"> datatype</font> has type map,  
<p><i>{(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>),...,(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>)}, 
</i><p>  
and extent <i>extent</i>.  (Explicit lower bound and upper bound markers are not listed in the type map, but  
they affect the value of <i>extent</i>.)  
The send  
operation sends <i>n &#183; <span style="font-family:sans-serif;"> count</span></i> entries, where entry <i>i 
&#183; n + j</i> is at location  
<i>addr<SUB>i,j</SUB> = <span style="font-family:sans-serif;"> buf</span> + extent &#183; i + <span style="font-family:serif;"> <em>disp</em></span><SUB>j</SUB></i><P> 
and has type <i><span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB></i>,  
for <i>i = 0 ,..., <span style="font-family:sans-serif;"> count</span>-1</i> and <i>j = 0 ,..., n-1</i>.  
These entries need not be contiguous, nor distinct; their order can be  
arbitrary.  
<P> 
The variable stored at address <i>addr<SUB>i,j</SUB></i> in the calling program  
should be of a type that matches <i><span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB></i>, where  
type matching is defined as in Section <a href="node66.htm#Node66">Type Matching Rules</a>.  
The message sent contains <i>n &#183; <span style="font-family:sans-serif;"> count</span></i> entries, where entry  
<i>i &#183; n +j</i> has type <i><span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB></i>.  
<P> 
Similarly, suppose that a receive operation  
<font face="sans-serif"> MPI_RECV</font><font face="sans-serif"> (buf, count, datatype, source, tag, comm, status)</font> is  
executed, where <font face="sans-serif"> datatype</font> has type map,  
<p><i>{(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>) ,...,(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) }, 
</i><p>  
  
with extent <i>extent</i>.  (Again,  explicit lower bound and upper bound markers are not listed in the type map, but  
they affect the value of <i>extent</i>.)  
This receive operation receives  
<i>n &#183; <span style="font-family:sans-serif;"> count</span></i> entries, where entry <i>i &#183; n + j</i> is at location  
<i><span style="font-family:sans-serif;"> buf</span> + extent &#183; i + <span style="font-family:serif;"> <em>disp</em></span><SUB>j</SUB></i><P> 
and has type <i><span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB></i>.  If the incoming message consists of <i>k</i>  
elements, then we must have <i>k &le; n &#183; <span style="font-family:sans-serif;"> count</span></i>; the <i>i &#183; n + 
j</i>-th element of the message should have a type that matches <i><span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB></i>.  
<P> 
<b> Type matching</b>  
is defined according to the type signature of  
the corresponding datatypes, that is, the sequence of basic type  
components.  Type matching does not depend on some aspects of the  
datatype definition, such as the displacements (layout in memory) or the  
intermediate types used.  
<P> 
<br><b> Example</b>  
  
This example shows that type matching is defined in terms of  
the basic types that a derived type consists of.  
<br> 
<pre style="background-color:#EFEFEF"><tt>... 
<b>CALL</b> <b>MPI_TYPE_CONTIGUOUS</b>(2, <b>MPI_REAL</b>, type2, ...) 
<b>CALL</b> <b>MPI_TYPE_CONTIGUOUS</b>(4, <b>MPI_REAL</b>, type4, ...) 
<b>CALL</b> <b>MPI_TYPE_CONTIGUOUS</b>(2, type2, type22, ...) 
... 
<b>CALL</b> <b>MPI_SEND</b>(a, 4, <b>MPI_REAL</b>, ...) 
<b>CALL</b> <b>MPI_SEND</b>(a, 2, type2, ...) 
<b>CALL</b> <b>MPI_SEND</b>(a, 1, type22, ...) 
<b>CALL</b> <b>MPI_SEND</b>(a, 1, type4, ...) 
... 
<b>CALL</b> <b>MPI_RECV</b>(a, 4, <b>MPI_REAL</b>, ...) 
<b>CALL</b> <b>MPI_RECV</b>(a, 2, type2, ...) 
<b>CALL</b> <b>MPI_RECV</b>(a, 1, type22, ...) 
<b>CALL</b> <b>MPI_RECV</b>(a, 1, type4, ...) 
</tt></pre> 
  
Each of the sends matches any of the receives.  
  
<P> 
A datatype may specify overlapping entries. The use of such a  
datatype in any communication in association with a buffer updated by  
the operation is erroneous. (This is erroneous even  
if the actual message received is short enough not to write any entry  
more than once.)  
<P> 
Suppose that  
<font face="sans-serif"> MPI_RECV</font><font face="sans-serif"> (buf, count, datatype, dest, tag, comm, status)</font> is  
executed, where <font face="sans-serif"> datatype</font> has type map,  
<p><i>{(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>) ,...,(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) }. 
</i><p>  
The received message need not fill all the receive buffer, nor does it  
need to fill a number of locations that is a multiple of <i>n</i>.  
Any number, <i>k</i>, of basic  
elements can be received, where <i>0 &le; k &le; <span style="font-family:sans-serif;"> count</span> &#183; n</i>.  
The number of basic elements received can be retrieved from  
<font face="sans-serif"> status</font> using the query procedure <font face="sans-serif"> MPI_GET_ELEMENTS</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GET_ELEMENTS(<span style="white-space:nowrap">status</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">count</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> status</TD><TD>return status of receive operation (status)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype used by receive operation (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> count</TD><TD>number of received basic elements (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Get_elements(const MPI_Status *status, MPI_Datatype datatype, int *count) <br></tt>  
  
  <tt> int MPI_Get_elements_c(const MPI_Status *status, MPI_Datatype datatype, MPI_Count *count) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Get_elements(status, datatype, count, ierror) <br> TYPE(MPI_Status), INTENT(IN) :: <span style="white-space:nowrap">status</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">count</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Get_elements(status, datatype, count, ierror) !(_c) <br> TYPE(MPI_Status), INTENT(IN) :: <span style="white-space:nowrap">status</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">count</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GET_ELEMENTS(STATUS, DATATYPE, COUNT, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The <font face="sans-serif"> datatype</font> argument should match the argument provided by the  
receive call that set the <font face="sans-serif"> status</font> variable.  
For both procedures, if the <span style="font-size:0.900em;"> OUT</span> parameter cannot express the value to  
be returned (e.g., if the parameter is too small to hold the output  
value), it is set to <font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 
The previously defined procedure  
<font face="sans-serif"> MPI_GET_COUNT</font>  
(Section <a href="node62.htm#Node62">Return Status</a>),  
has a different behavior.  
It returns the number of ``top-level  
entries'' received, i.e., the number of ``copies'' of type  
<font face="sans-serif"> datatype</font>.  
In the previous example, <font face="sans-serif"> MPI_GET_COUNT</font>  
may return any integer value <i>k</i>, where <i>0 &le; k &le; <span style="font-family:sans-serif;"> count</span></i>.  
If <font face="sans-serif"> MPI_GET_COUNT</font> returns <i>k</i>, then the number of basic  
elements received (and the value returned by  
<font face="sans-serif"> MPI_GET_ELEMENTS</font>)  
is <i>n &#183; k</i>.   If the number of basic elements received is not a  
multiple of <i>n</i>, that is, if the receive operation has not received an  
integral number of <font face="sans-serif"> datatype</font> ``copies,'' then  
<font face="sans-serif"> MPI_GET_COUNT</font> sets the value of <font face="sans-serif"> count</font> to <font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 
<br><b> Example</b>  
  
Usage of <font face="sans-serif"> MPI_GET_COUNT</font> and  
<font face="sans-serif"> MPI_GET_ELEMENTS</font>.  
<br> 
<pre style="background-color:#EFEFEF"><tt>... 
<b>CALL</b> <b>MPI_TYPE_CONTIGUOUS</b>(2, <b>MPI_REAL</b>, Type2, ierr) 
<b>CALL</b> <b>MPI_TYPE_COMMIT</b>(Type2, ierr) 
... 
<b>CALL</b> <b>MPI_COMM_RANK</b>(comm, rank, ierr) 
<b>IF</b> (rank .EQ. 0) <b>THEN</b> 
   <b>CALL</b> <b>MPI_SEND</b>(a, 2, <b>MPI_REAL</b>, 1, 0, comm, ierr) 
   <b>CALL</b> <b>MPI_SEND</b>(a, 3, <b>MPI_REAL</b>, 1, 0, comm, ierr) 
<b>ELSE</b> <b>IF</b> (rank .EQ. 1) <b>THEN</b> 
   <b>CALL</b> <b>MPI_RECV</b>(a, 2, Type2, 0, 0, comm, stat, ierr) 
   <b>CALL</b> <b>MPI_GET_COUNT</b>(stat, Type2, i, ierr)     ! returns i=1 
   <b>CALL</b> <b>MPI_GET_ELEMENTS</b>(stat, Type2, i, ierr)  ! returns i=2 
   <b>CALL</b> <b>MPI_RECV</b>(a, 2, Type2, 0, 0, comm, stat, ierr) 
   <b>CALL</b> <b>MPI_GET_COUNT</b>(stat, Type2, i, ierr)     ! returns i=<b>MPI_UNDEFINED</b> 
   <b>CALL</b> <b>MPI_GET_ELEMENTS</b>(stat, Type2, i, ierr)  ! returns i=3 
<b>END</b> <b>IF</b> 
</tt></pre> 
  
  
<P> 
The procedure <font face="sans-serif"> MPI_GET_ELEMENTS</font>  
can also be used after a probe  
to find the number of elements in the probed message.  
Note that the  
<font face="sans-serif"> MPI_GET_COUNT</font> and  
<font face="sans-serif"> MPI_GET_ELEMENTS</font>  
return the same values when they are used  
with basic datatypes as long as the limits of their respective <font face="sans-serif"> count</font> arguments are not exceeded.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The extension given to the definition of <font face="sans-serif"> MPI_GET_COUNT</font> seems  
natural: one would expect this procedure to return the value of the  
<font face="sans-serif"> count</font> argument, when the receive buffer is filled.  
Sometimes <font face="sans-serif"> datatype</font> represents  
a basic unit of data one wants to transfer,  
for example, a record in an array of records (structures).  
One should be able to find out how many components were received  
without bothering to divide by the number of elements in each  
component.   However, on other occasions, <font face="sans-serif"> datatype</font> is used to  
define a complex layout of data in the receiver memory, and does not represent  
a basic unit of data for transfers.  In such cases, one needs to use  
the procedure <font face="sans-serif"> MPI_GET_ELEMENTS</font>.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The definition implies that a receive cannot change the value of  
storage outside the entries defined to compose the communication  
buffer.  
In particular, the definition implies that padding space in a structure  
should not be modified when such a structure is copied from one process to  
another. This would  
prevent the obvious optimization of copying the structure, together  
with the padding, as one contiguous block.  
The implementation is free to do this optimization when it does not  
impact the outcome of the computation.  
The user can ``force'' this optimization by explicitly including  
padding as part of the message.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node108.htm#Node108"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node110.htm#Node110"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node110.htm#Node110"> Correct Use of Addresses</a>
<b>Previous: </b><a href="node108.htm#Node108"> Duplicating a Datatype</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
