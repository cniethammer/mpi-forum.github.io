<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>True Extent of Datatypes</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node106">6.1.8. True Extent of Datatypes</span></h2>
<a href="node105.htm#Node105"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node107.htm#Node107"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node107.htm#Node107"> Commit and Free</a>
<b>Previous: </b><a href="node105.htm#Node105"> Extent and Bounds of Datatypes</a>
<p>
  
  
  
<P> 
Suppose we implement gather  
(see also Section <a href="node124.htm#Node124">Gather</a>)  
as a spanning tree implemented on top of  
point-to-point routines.  Since the receive buffer is only valid on the  
root process, one will need to allocate some temporary space for  
receiving data on intermediate nodes.  However, the datatype extent  
cannot be used as an estimate of the amount of space that needs to be  
allocated, if the user has modified the extent, for example by  
using <font face="sans-serif"> MPI_TYPE_CREATE_RESIZED</font>.  
The procedure <font face="sans-serif"> MPI_TYPE_GET_TRUE_EXTENT</font> returns  
the true extent of the datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_TRUE_EXTENT(<span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">true_lb</span>, <span style="white-space:nowrap">true_extent</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype to get information on (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> true_lb</TD><TD>true lower bound of datatype (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> true_extent</TD><TD>true extent of datatype (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_get_true_extent(MPI_Datatype datatype, MPI_Aint *true_lb, MPI_Aint *true_extent) <br></tt>  
  
  <tt> int MPI_Type_get_true_extent_c(MPI_Datatype datatype, MPI_Count *true_lb, MPI_Count *true_extent) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_get_true_extent(datatype, true_lb, true_extent, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: <span style="white-space:nowrap">true_lb</span>, <span style="white-space:nowrap">true_extent</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_get_true_extent(datatype, true_lb, true_extent, ierror) !(_c) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">true_lb</span>, <span style="white-space:nowrap">true_extent</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_GET_TRUE_EXTENT(DATATYPE, TRUE_LB, TRUE_EXTENT, IERROR) <br> INTEGER <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">TRUE_LB</span>, <span style="white-space:nowrap">TRUE_EXTENT</span> <br></tt>  
<P> 
<font face="sans-serif"> true_lb</font> returns the offset of the lowest unit of storage that  
is addressed by the datatype, i.e., the lower bound of the  
corresponding typemap, ignoring explicit lower bound markers.  
<font face="sans-serif"> true_extent</font> returns the  
true size of  
the datatype, i.e., the extent of the corresponding typemap, ignoring  
explicit lower bound and upper bound markers, and performing no  
rounding for alignment.  If the typemap associated with  
<font face="sans-serif"> datatype</font> is  
<p><i><span style="font-family:serif;"> <em>Typemap</em></span> = { (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>)} 
</i><p>  
Then  
<p><i>true_lb(<span style="font-family:serif;"> <em>Typemap</em></span>) = <tt> min</tt><SUB>j</SUB>  { <span style="font-family:serif;"> <em>disp</em></span><SUB>j</SUB>  :  <span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB> &ne; <span style="font-family:sans-serif;"> lb_marker</span>, <span style="font-family:sans-serif;"> ub_marker</span> }, 
</i><p>  
<p><i>true_ub (<span style="font-family:serif;"> <em>Typemap</em></span>) = <tt> max</tt><SUB>j</SUB> {<span style="font-family:serif;"> <em>disp</em></span><SUB>j</SUB> + <span style="font-family:sans-serif;"> sizeof</span>(<span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB>)  :  <span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB> &ne; 
<span style="font-family:sans-serif;"> lb_marker</span>, <span style="font-family:sans-serif;"> ub_marker</span>} , 
</i><p>  
and  
<p><i>true_extent (<span style="font-family:serif;"> <em>Typemap</em></span>) = true_ub(<span style="font-family:serif;"> <em>Typemap</em></span>) - true_lb(<span style="font-family:serif;"> <em>Typemap</em></span>). 
</i><p>  
(Readers should compare this with the definitions in  
Section <a href="node104.htm#Node104">Lower-Bound and Upper-Bound Markers</a> and  
Section <a href="node105.htm#Node105">Extent and Bounds of Datatypes</a>,  
which describe the procedure  
<font face="sans-serif"> MPI_TYPE_GET_EXTENT</font>.)  
<P> 
The <font face="sans-serif"> true_extent</font> is the minimum number of bytes of  
memory necessary to hold a datatype, uncompressed.  
<P> 
If either <span style="font-size:0.900em;"> OUT</span> parameter cannot express the value to  
be returned (e.g., if the parameter is too small to hold the output  
value), it is set to <font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 

<P>
<hr>
<a href="node105.htm#Node105"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node107.htm#Node107"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node107.htm#Node107"> Commit and Free</a>
<b>Previous: </b><a href="node105.htm#Node105"> Extent and Bounds of Datatypes</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
