<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-context/context-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Group Constructors</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node186">8.3.2. Group Constructors</span></h2>
<a href="node185.htm#Node185"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node184.htm#Node184"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node187.htm#Node187"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node184.htm#Node184"> Group Management</a>
<b>Next: </b><a href="node187.htm#Node187"> Group Destructors</a>
<b>Previous: </b><a href="node185.htm#Node185"> Group Accessors</a>
<p>
  
<font face="sans-serif"> MPI</font> provides two approaches to constructing groups.  
In the first approach, <font face="sans-serif"> MPI</font> procedures are provided  
to subset and superset existing groups.  
These constructors construct new groups from existing groups.  
In the second approach, a group is created using a session handle and associated  
process set. This second approach is available when using the Sessions Model.  
With both approaches, these are local operations, and distinct groups may be defined on  
different <font face="sans-serif"> MPI</font> processes; an <font face="sans-serif"> MPI</font> process may also define a group that does not  
include itself. Consistent definitions are required when groups are  
used as arguments in communicator creation functions.  
When using the World Model (Section <a href="node268.htm#Node268">The World Model</a>) for <font face="sans-serif"> MPI</font> initialization,  
the base group, upon which all  
other groups are defined, is the group associated with the initial  
communicator <font face="sans-serif"> MPI_COMM_WORLD</font> (accessible through  
the function <font face="sans-serif"> MPI_COMM_GROUP</font>).  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
In what follows, there is no group duplication function analogous to  
<font face="sans-serif"> MPI_COMM_DUP</font>, defined later in this chapter. There is no need for  
a group duplicator. A group, once created, can have several references to it  
by making copies of the handle. The following constructors address the need  
for subsets and supersets of existing groups.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Each group constructor behaves as if it returned a new group object.  
When this new group is a copy of an existing group, then  
one can avoid creating such new objects, using  
a reference-count mechanism.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_GROUP(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">group</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> group</TD><TD>group corresponding to <font face="sans-serif"> comm</font> (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_group(MPI_Comm comm, MPI_Group *group) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_group(comm, group, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">group</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_GROUP(COMM, GROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_GROUP</font> returns in <font face="sans-serif"> group</font> a handle to the  
group of <font face="sans-serif"> comm</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_UNION(<span style="white-space:nowrap">group1</span>, <span style="white-space:nowrap">group2</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group1</TD><TD>first group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group2</TD><TD>second group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>union group (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_union(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_union(group1, group2, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group1</span>, <span style="white-space:nowrap">group2</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_UNION(GROUP1, GROUP2, NEWGROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP1</span>, <span style="white-space:nowrap">GROUP2</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_INTERSECTION(<span style="white-space:nowrap">group1</span>, <span style="white-space:nowrap">group2</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group1</TD><TD>first group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group2</TD><TD>second group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>intersection group (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_intersection(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_intersection(group1, group2, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group1</span>, <span style="white-space:nowrap">group2</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_INTERSECTION(GROUP1, GROUP2, NEWGROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP1</span>, <span style="white-space:nowrap">GROUP2</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_DIFFERENCE(<span style="white-space:nowrap">group1</span>, <span style="white-space:nowrap">group2</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group1</TD><TD>first group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group2</TD><TD>second group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>difference group (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_difference(MPI_Group group1, MPI_Group group2, MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_difference(group1, group2, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group1</span>, <span style="white-space:nowrap">group2</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_DIFFERENCE(GROUP1, GROUP2, NEWGROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP1</span>, <span style="white-space:nowrap">GROUP2</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
 The set-like operations are defined as follows:  
<dl> 
 
<dt> 
<b>union:</b><dd> 
 All elements of the first group (<font face="sans-serif"> group1</font>), followed by  
all elements of second group (<font face="sans-serif"> group2</font>) not in  
the first group.  
 
<dt> 
<b>intersect:</b><dd> 
 All elements of the first group that are also  
in the second group, ordered as in the first group.  
 
<dt> 
<b>difference:</b><dd> 
 All elements of the first group that are not  
in the second group, ordered as in the first group.  
</dl> 
<br> 
Note that for these operations the order of <font face="sans-serif"> MPI</font> processes in the output  
group is determined primarily by order in the first group (if possible)  
and then, if necessary, by order in the second group. Neither union nor  
intersection are commutative, but both are associative. The new group can  
be empty, that is, equal to <font face="sans-serif"> MPI_GROUP_EMPTY</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_INCL(<span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranks</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group</TD><TD>group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> n</TD><TD>number of elements in array <font face="sans-serif"> ranks</font> (and size of <font face="sans-serif"> newgroup</font>) (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> ranks</TD><TD>ranks of processes in <font face="sans-serif"> group</font> to appear in <font face="sans-serif"> newgroup</font> (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>new group derived from above, in the order defined by <font face="sans-serif"> ranks</font> (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_incl(MPI_Group group, int n, const int ranks[], MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_incl(group, n, ranks, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranks(n)</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_INCL(GROUP, N, RANKS, NEWGROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">N</span>, <span style="white-space:nowrap">RANKS(*)</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The function <font face="sans-serif"> MPI_GROUP_INCL</font> creates a group  
<font face="sans-serif"> newgroup</font> that consists of the <font face="sans-serif"> n</font> <font face="sans-serif"> MPI</font> processes in  
<font face="sans-serif"> group</font> with ranks <font face="sans-serif"> ranks[0]</font>,<i>...</i>, <font face="sans-serif"> ranks[n-1]</font>;  
the <font face="sans-serif"> MPI</font> process with rank <font face="sans-serif"> i</font> in  
<font face="sans-serif"> newgroup</font> is the <font face="sans-serif"> MPI</font> process with rank <font face="sans-serif"> ranks[i]</font> in  
<font face="sans-serif"> group</font>. Each of the <font face="sans-serif"> n</font> elements of <font face="sans-serif"> ranks</font> must be a  
valid rank in <font face="sans-serif"> group</font> and all elements must be distinct, or else the  
program is erroneous. If <font face="sans-serif"> n</font><i>= 0</i>, then <font face="sans-serif"> newgroup</font> is  
<font face="sans-serif"> MPI_GROUP_EMPTY</font>.  
This function can, for instance, be used to reorder the  
elements of a group. See also <font face="sans-serif"> MPI_GROUP_COMPARE</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_EXCL(<span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranks</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group</TD><TD>group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> n</TD><TD>number of elements in array <font face="sans-serif"> ranks</font> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> ranks</TD><TD>array of integer ranks of <font face="sans-serif"> MPI</font> processes in <font face="sans-serif"> group</font> not to appear in <font face="sans-serif"> newgroup</font></TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>new group derived from above, preserving the order defined by <font face="sans-serif"> group</font> (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_excl(MPI_Group group, int n, const int ranks[], MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_excl(group, n, ranks, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranks(n)</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_EXCL(GROUP, N, RANKS, NEWGROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">N</span>, <span style="white-space:nowrap">RANKS(*)</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The function <font face="sans-serif"> MPI_GROUP_EXCL</font> creates a group of <font face="sans-serif"> MPI</font> processes  
<font face="sans-serif"> newgroup</font> that is obtained by deleting from <font face="sans-serif"> group</font>  
those <font face="sans-serif"> MPI</font> processes with ranks  
<font face="sans-serif"> ranks[0]</font>,<i>...</i>, <font face="sans-serif"> ranks[n-1]</font>.  
The ordering of <font face="sans-serif"> MPI</font> processes in <font face="sans-serif"> newgroup</font> is identical to the ordering  
in <font face="sans-serif"> group</font>.  
Each of the <font face="sans-serif"> n</font> elements of <font face="sans-serif"> ranks</font> must be a valid  
rank in <font face="sans-serif"> group</font> and all elements must be distinct; otherwise, the  
program is erroneous.  
If <font face="sans-serif"> n</font><i>= 0</i>, then <font face="sans-serif"> newgroup</font> is identical to <font face="sans-serif"> group</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_RANGE_INCL(<span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranges</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group</TD><TD>group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> n</TD><TD>number of triplets in array <font face="sans-serif"> ranges</font> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> ranges</TD><TD>a one-dimensional array of integer triplets, of the form (first rank, last rank, stride) indicating ranks in <font face="sans-serif"> group</font> of <font face="sans-serif"> MPI</font> processes to be included in <font face="sans-serif"> newgroup</font></TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>new group derived from above, in the order defined by <font face="sans-serif"> ranges</font> (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_range_incl(MPI_Group group, int n, int ranges[][3], MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_range_incl(group, n, ranges, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranges(3, n)</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_RANGE_INCL(GROUP, N, RANGES, NEWGROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">N</span>, <span style="white-space:nowrap">RANGES(3, *)</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
 If <font face="sans-serif"> ranges</font> consists of the triplets  
<p><i>(first<SUB>1</SUB> , last<SUB>1</SUB>, stride<SUB>1</SUB>) , ... , (first<SUB>n</SUB>, last<SUB>n</SUB>, stride<SUB>n</SUB>) 
</i><p>  
then <font face="sans-serif"> newgroup</font> consists of the sequence of  
<font face="sans-serif"> MPI</font> processes in <font face="sans-serif"> group</font> with ranks  
<P><img width=653 height=51 src="img32.gif" alt="Image file"><P>
  
<P><img width=625 height=51 src="img33.gif" alt="Image file"><P>
  
<P> 
Each computed rank must be a valid  
rank in <font face="sans-serif"> group</font> and all computed ranks must be distinct, or else the  
program is erroneous.  
Note that we may have <i>first<SUB>i</SUB> &gt; last<SUB>i</SUB></i>, and <i>stride<SUB>i</SUB></i> may be negative, but  
cannot be zero.  
<P> 
The functionality of this routine is specified to be equivalent to  
expanding the array of ranges to an array of the included ranks and  
passing the resulting array of ranks and other arguments to  
<font face="sans-serif"> MPI_GROUP_INCL</font>. A call to <font face="sans-serif"> MPI_GROUP_INCL</font> is  
equivalent to a call to  
<font face="sans-serif"> MPI_GROUP_RANGE_INCL</font> with each rank <font face="sans-serif"> i</font>  
in <font face="sans-serif"> ranks</font> replaced by the triplet <font face="sans-serif"> (i,i,1)</font> in the argument <font face="sans-serif"> ranges</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_RANGE_EXCL(<span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranges</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group</TD><TD>group (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> n</TD><TD>number of triplets in array <font face="sans-serif"> ranges</font> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> ranges</TD><TD>a one-dimensional array of integer triplets, of the form (first rank, last rank, stride) indicating ranks in <font face="sans-serif"> group</font> of <font face="sans-serif"> MPI</font> processes to be excluded from the output group <font face="sans-serif"> newgroup</font> (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>new group derived from above, preserving the order in <font face="sans-serif"> group</font> (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_range_excl(MPI_Group group, int n, int ranges[][3], MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_range_excl(group, n, ranges, newgroup, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">n</span>, <span style="white-space:nowrap">ranges(3, n)</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_RANGE_EXCL(GROUP, N, RANGES, NEWGROUP, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">N</span>, <span style="white-space:nowrap">RANGES(3, *)</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
 Each computed rank must be a valid  
rank in <font face="sans-serif"> group</font> and all computed ranks must be distinct, or else the  
program is erroneous.  
<P> 
The functionality of this routine is specified to be equivalent to  
expanding the array of ranges to an array of the excluded ranks and  
passing the resulting array of ranks and other arguments to  
<font face="sans-serif"> MPI_GROUP_EXCL</font>. A call to <font face="sans-serif"> MPI_GROUP_EXCL</font> is  
equivalent to a call to <font face="sans-serif"> MPI_GROUP_RANGE_EXCL</font> with each rank  
<font face="sans-serif"> i</font> in <font face="sans-serif"> ranks</font> replaced by the triplet <font face="sans-serif"> (i,i,1)</font> in the argument  
<font face="sans-serif"> ranges</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The range operations do not explicitly enumerate ranks, and therefore  
are more scalable if implemented efficiently. Hence, we recommend <font face="sans-serif"> MPI</font> programmers  
to use them whenenever possible, as high-quality implementations will  
take advantage of this fact.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The range operations should be implemented, if possible, without  
enumerating the group members,  
in order to obtain better scalability (time and space).  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_GROUP_FROM_SESSION_PSET(<span style="white-space:nowrap">session</span>, <span style="white-space:nowrap">pset_name</span>, <span style="white-space:nowrap">newgroup</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> session</TD><TD>session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pset_name</TD><TD>name of process set to use to create the new group (string)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newgroup</TD><TD>new group derived from supplied session and process set (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Group_from_session_pset(MPI_Session session, const char *pset_name, MPI_Group *newgroup) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Group_from_session_pset(session, pset_name, newgroup, ierror) <br> TYPE(MPI_Session), INTENT(IN) :: <span style="white-space:nowrap">session</span><br>CHARACTER(LEN=*), INTENT(IN) :: <span style="white-space:nowrap">pset_name</span><br>TYPE(MPI_Group), INTENT(OUT) :: <span style="white-space:nowrap">newgroup</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GROUP_FROM_SESSION_PSET(SESSION, PSET_NAME, NEWGROUP, IERROR) <br> INTEGER <span style="white-space:nowrap">SESSION</span>, <span style="white-space:nowrap">NEWGROUP</span>, <span style="white-space:nowrap">IERROR</span><br>CHARACTER*(*) <span style="white-space:nowrap">PSET_NAME</span> <br></tt>  
<P> 
The function <font face="sans-serif"> MPI_GROUP_FROM_SESSION_PSET</font> creates a group  
<font face="sans-serif"> newgroup</font> using the provided session handle and process set name.  
Process set names returned from <font face="sans-serif"> MPI_SESSION_GET_NTH_PSET</font> for the supplied <font face="sans-serif"> session</font> are considered valid process set names by <font face="sans-serif"> MPI</font>.  
If the <font face="sans-serif"> pset_name</font> is not considered valid by <font face="sans-serif"> MPI</font> at the time of the call, <font face="sans-serif"> MPI_GROUP_NULL</font> will be returned in the <font face="sans-serif"> newgroup</font> argument.  
As with other group constructors, <font face="sans-serif"> MPI_GROUP_FROM_SESSION_PSET</font> is a local function.  
See Section <a href="node273.htm#Node273">The Sessions Model</a> for more information on sessions and process sets.  
<P> 

<P>
<hr>
<a href="node185.htm#Node185"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node184.htm#Node184"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node187.htm#Node187"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node184.htm#Node184"> Group Management</a>
<b>Next: </b><a href="node187.htm#Node187"> Group Destructors</a>
<b>Previous: </b><a href="node185.htm#Node185"> Group Accessors</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
