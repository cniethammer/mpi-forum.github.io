<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-context/context-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Communicators</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node208">8.7.2. Communicators</span></h2>
<a href="node207.htm#Node207"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node206.htm#Node206"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node209.htm#Node209"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node206.htm#Node206"> Caching</a>
<b>Next: </b><a href="node209.htm#Node209"> Windows</a>
<b>Previous: </b><a href="node207.htm#Node207"> Functionality</a>
<p>
  
<P> 
Functions  
for caching on communicators are:  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_CREATE_KEYVAL(<span style="white-space:nowrap">comm_copy_attr_fn</span>, <span style="white-space:nowrap">comm_delete_attr_fn</span>, <span style="white-space:nowrap">comm_keyval</span>, <span style="white-space:nowrap">extra_state</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm_copy_attr_fn</TD><TD>copy callback function for <font face="sans-serif"> comm_keyval</font> (function)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm_delete_attr_fn</TD><TD>delete callback function for <font face="sans-serif"> comm_keyval</font> (function)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> comm_keyval</TD><TD>key value for future access (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> extra_state</TD><TD>extra state for callback function</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_create_keyval(MPI_Comm_copy_attr_function *comm_copy_attr_fn, MPI_Comm_delete_attr_function *comm_delete_attr_fn, int *comm_keyval, void *extra_state) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_create_keyval(comm_copy_attr_fn, comm_delete_attr_fn, comm_keyval, extra_state, ierror) <br> PROCEDURE(MPI_Comm_copy_attr_function) :: <span style="white-space:nowrap">comm_copy_attr_fn</span><br>PROCEDURE(MPI_Comm_delete_attr_function) :: <span style="white-space:nowrap">comm_delete_attr_fn</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">comm_keyval</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">extra_state</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_CREATE_KEYVAL(COMM_COPY_ATTR_FN, COMM_DELETE_ATTR_FN, COMM_KEYVAL, EXTRA_STATE, IERROR) <br> EXTERNAL <span style="white-space:nowrap">COMM_COPY_ATTR_FN</span>, <span style="white-space:nowrap">COMM_DELETE_ATTR_FN</span><br>INTEGER <span style="white-space:nowrap">COMM_KEYVAL</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">EXTRA_STATE</span> <br></tt>  
<P> 
Generates a new attribute key. Keys are locally unique in an <font face="sans-serif"> MPI</font> process,  
and opaque to user, though they are explicitly stored in integers.  
Once allocated, the key value can be used to associate attributes  
and access them on any locally defined communicator.  
<P> 
  
The C callback functions are:  
<P> 
 <tt> typedef int MPI_Comm_copy_attr_function(MPI_Comm oldcomm, int comm_keyval, void *extra_state, void *attribute_val_in, void *attribute_val_out, int *flag); <br></tt>  
<P> 
  
and  
<P> 
 <tt> typedef int MPI_Comm_delete_attr_function(MPI_Comm comm, int comm_keyval, void *attribute_val, void *extra_state); <br></tt>  
<P> 
  
which are the same as the <font face="sans-serif"> MPI-1.1</font> calls but with a new name.  
The old names are deprecated.  
<P> 
  
With the <tt>mpi_f08</tt> module, the Fortran callback functions are:  
<P> 
<tt> ABSTRACT INTERFACE<br>&nbsp;&nbsp;&nbsp;  SUBROUTINE MPI_Comm_copy_attr_function(oldcomm, comm_keyval, extra_state, attribute_val_in, attribute_val_out, flag, ierror) <br> TYPE(MPI_Comm) :: <span style="white-space:nowrap">oldcomm</span><br>INTEGER :: <span style="white-space:nowrap">comm_keyval</span>, <span style="white-space:nowrap">ierror</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) :: <span style="white-space:nowrap">extra_state</span>, <span style="white-space:nowrap">attribute_val_in</span>, <span style="white-space:nowrap">attribute_val_out</span><br>LOGICAL :: <span style="white-space:nowrap">flag</span> <br></tt>  
 <P> 
  
and  
 <P> 
<tt> ABSTRACT INTERFACE<br>&nbsp;&nbsp;&nbsp;  SUBROUTINE MPI_Comm_delete_attr_function(comm, comm_keyval, attribute_val, extra_state, ierror) <br> TYPE(MPI_Comm) :: <span style="white-space:nowrap">comm</span><br>INTEGER :: <span style="white-space:nowrap">comm_keyval</span>, <span style="white-space:nowrap">ierror</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) :: <span style="white-space:nowrap">attribute_val</span>, <span style="white-space:nowrap">extra_state</span> <br></tt>  
<P> 
  
With the <tt>mpi</tt> module and (deprecated) <tt>mpif.h</tt> include file, the Fortran callback functions are:  
<P> 
 <tt> SUBROUTINE COMM_COPY_ATTR_FUNCTION(OLDCOMM, COMM_KEYVAL, EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR) <br> INTEGER <span style="white-space:nowrap">OLDCOMM</span>, <span style="white-space:nowrap">COMM_KEYVAL</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">EXTRA_STATE</span>, <span style="white-space:nowrap">ATTRIBUTE_VAL_IN</span>, <span style="white-space:nowrap">ATTRIBUTE_VAL_OUT</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
  
and  
<P> 
 <tt> SUBROUTINE COMM_DELETE_ATTR_FUNCTION(COMM, COMM_KEYVAL, ATTRIBUTE_VAL, EXTRA_STATE, IERROR) <br> INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">COMM_KEYVAL</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ATTRIBUTE_VAL</span>, <span style="white-space:nowrap">EXTRA_STATE</span> <br></tt>  
<P> 
The <font face="sans-serif"> comm_copy_attr_fn</font> function is invoked when a communicator is  
duplicated by <font face="sans-serif"> MPI_COMM_DUP</font>, <font face="sans-serif"> MPI_COMM_IDUP</font>, <font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font>  
or <font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font>.  
<font face="sans-serif"> comm_copy_attr_fn</font> should be  
of type <font face="sans-serif"> MPI_Comm_copy_attr_function</font>.  
The copy callback function is invoked for each key value in  
<font face="sans-serif"> oldcomm</font> in arbitrary order. Each call  
to the copy callback is made with a key value and its corresponding attribute.  
If it returns <font face="sans-serif"> flag</font><font face="sans-serif">  = 0</font> or <tt>.FALSE.</tt>, then the  
attribute is deleted in the duplicated communicator. Otherwise  
(<font face="sans-serif"> flag</font><font face="sans-serif">  = 1</font> or <tt>.TRUE.</tt>),  
the new attribute value is set to the value  
returned in  
<font face="sans-serif"> attribute_val_out</font>.  
The function returns <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> on  
success and an error code on failure (in which case  
<font face="sans-serif"> MPI_COMM_DUP</font> or <font face="sans-serif"> MPI_COMM_IDUP</font> will fail).  
<P> 
The argument <font face="sans-serif"> comm_copy_attr_fn</font> may be specified as  
<font face="sans-serif"> MPI_COMM_NULL_COPY_FN</font> or  
<font face="sans-serif"> MPI_COMM_DUP_FN</font>  
from either C or Fortran.  
<font face="sans-serif"> MPI_COMM_NULL_COPY_FN</font>  
is a function that does nothing other than returning <font face="sans-serif"> flag</font><font face="sans-serif">  = 0</font>  
or <tt>.FALSE.</tt> (depending on whether the keyval  
 was created with a C or Fortran binding to  
 <font face="sans-serif"> MPI_COMM_CREATE_KEYVAL</font>) and <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>.  
<font face="sans-serif"> MPI_COMM_DUP_FN</font> is a simple  
copy function that sets <font face="sans-serif"> flag</font><font face="sans-serif">  = 1</font> or <tt>.TRUE.</tt>,  
returns the value of  
<font face="sans-serif"> attribute_val_in</font> in <font face="sans-serif"> attribute_val_out</font>, and  
returns <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>.  
These replace the <font face="sans-serif"> MPI-1</font> predefined callbacks <font face="sans-serif"> MPI_NULL_COPY_FN</font>  
and <font face="sans-serif"> MPI_DUP_FN</font>, whose use is deprecated.  
<P> 
  
  
 
<br> 
<em> Advice to users.</em>  
<P> 
Even though both formal arguments <font face="sans-serif"> attribute_val_in</font> and  
<font face="sans-serif"> attribute_val_out</font> are of type <tt>void*</tt>, their usage differs.  
The C copy function is passed by <font face="sans-serif"> MPI</font> in <font face="sans-serif"> attribute_val_in</font>  
the <em> value</em> of the attribute, and in  
<font face="sans-serif"> attribute_val_out</font> the <em> address</em> of the attribute, so as  
to allow the function to return the (new) attribute value.  
The use of type <tt>void*</tt> for both is to avoid messy type casts.  
<P> 
A valid copy function is one that completely duplicates the  
information by making a full duplicate copy of the data structures  
implied by an attribute; another might just make another reference to  
that data structure, while using a reference-count mechanism. Other  
types of attributes might not copy at all (they might be specific to  
<font face="sans-serif"> oldcomm</font> only).  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
A C interface should be assumed for copy and delete functions  
associated with key values created in C; a Fortran calling interface  
should be assumed for key values created in Fortran.  
 (<em> End of advice to implementors.</em>) <br> 
Analogous to <font face="sans-serif"> comm_copy_attr_fn</font> is a callback deletion function, defined  
as follows. The <font face="sans-serif"> comm_delete_attr_fn</font> function is invoked when a communicator is  
deleted by <font face="sans-serif"> MPI_COMM_FREE</font>, <font face="sans-serif"> MPI_COMM_DISCONNECT</font> or when a call is made explicitly to  
<font face="sans-serif"> MPI_COMM_DELETE_ATTR</font>.  
<font face="sans-serif"> comm_delete_attr_fn</font> should be  
of type <font face="sans-serif"> MPI_Comm_delete_attr_function</font>.  
<P> 
This function is called by <font face="sans-serif"> MPI_COMM_FREE</font>,  
<font face="sans-serif"> MPI_COMM_DISCONNECT</font>,  
<font face="sans-serif"> MPI_COMM_DELETE_ATTR</font>,  
and <font face="sans-serif"> MPI_COMM_SET_ATTR</font>  
to do whatever is needed to remove an attribute.  
The function returns <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> on  
success and an error code on failure (in which case  
<font face="sans-serif"> MPI_COMM_FREE</font> will fail).  
<P> 
The argument <font face="sans-serif"> comm_delete_attr_fn</font> may be specified as<font face="sans-serif"> MPI_COMM_NULL_DELETE_FN</font>  
from either C or Fortran.<font face="sans-serif"> MPI_COMM_NULL_DELETE_FN</font> is a function that does nothing, other  
than returning <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>. <font face="sans-serif"> MPI_COMM_NULL_DELETE_FN</font>  
replaces <font face="sans-serif"> MPI_NULL_DELETE_FN</font>, whose use is deprecated.  
<P> 
  
If an attribute copy function or attribute delete function returns other than  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>, then the call that caused it to be invoked (for example,  
<font face="sans-serif"> MPI_COMM_FREE</font>) is erroneous.  
<P> 
The special key value <font face="sans-serif"> MPI_KEYVAL_INVALID</font> is never returned  
by <font face="sans-serif"> MPI_COMM_CREATE_KEYVAL</font>. Therefore, it can be used for  
static initialization of key values.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The predefined Fortran functions <font face="sans-serif"> MPI_COMM_NULL_COPY_FN</font>,  
<font face="sans-serif"> MPI_COMM_DUP_FN</font>,  
and <font face="sans-serif"> MPI_COMM_NULL_DELETE_FN</font> are defined  
in the <tt>mpi</tt> module (and deprecated <tt>mpif.h</tt>) and the <tt>mpi_f08</tt> module  
with the same name, but with different interfaces.  
Each function can coexist twice with the same name in the same <font face="sans-serif"> MPI</font> library,  
one routine as an implicit interface outside of the <tt>mpi</tt> module,  
i.e., declared as <tt> EXTERNAL</tt>,  
and the other routine within <tt>mpi_f08</tt> declared with <tt> CONTAINS</tt>.  
These routines have different link names, which are also different  
to the link names used for the routines used in C.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Callbacks, including the predefined Fortran functions  
<font face="sans-serif"> MPI_COMM_NULL_COPY_FN</font>, <font face="sans-serif"> MPI_COMM_DUP_FN</font>,  
and <font face="sans-serif"> MPI_COMM_NULL_DELETE_FN</font> should not be passed from one application  
routine that uses the <tt>mpi_f08</tt> module to another  
application routine that uses the <tt>mpi</tt> module or (deprecated) <tt>mpif.h</tt> include file,  
and vice versa;  
see also the advice to users on page <a href="node511.htm#Node513">Callback Functions</a>.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_FREE_KEYVAL(<span style="white-space:nowrap">comm_keyval</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> comm_keyval</TD><TD>key value (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_free_keyval(int *comm_keyval) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_free_keyval(comm_keyval, ierror) <br> INTEGER, INTENT(INOUT) :: <span style="white-space:nowrap">comm_keyval</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_FREE_KEYVAL(COMM_KEYVAL, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COMM_KEYVAL</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Frees an extant attribute key.  
This function sets the value of <font face="sans-serif"> keyval</font> to  
<font face="sans-serif"> MPI_KEYVAL_INVALID</font>.  
Note that it is not erroneous to free an attribute key  
that is in use, because the actual free does not transpire until after all  
references (in other communicators on the <font face="sans-serif"> MPI</font> process) to the key have been freed.  
These references need to be explictly freed by the program, either via calls  
to <font face="sans-serif"> MPI_COMM_DELETE_ATTR</font> that free one attribute instance, or by calls  
to <font face="sans-serif"> MPI_COMM_FREE</font> that free all attribute instances associated with  
the freed communicator.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_SET_ATTR(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">comm_keyval</span>, <span style="white-space:nowrap">attribute_val</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> comm</TD><TD>communicator to which attribute will be attached (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm_keyval</TD><TD>key value (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> attribute_val</TD><TD>attribute value</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_set_attr(MPI_Comm comm, int comm_keyval, void *attribute_val) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_set_attr(comm, comm_keyval, attribute_val, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">comm_keyval</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">attribute_val</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_SET_ATTR(COMM, COMM_KEYVAL, ATTRIBUTE_VAL, IERROR) <br> INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">COMM_KEYVAL</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ATTRIBUTE_VAL</span> <br></tt>  
<P> 
This function stores the stipulated attribute value <font face="sans-serif"> attribute_val</font>  
for subsequent retrieval by <font face="sans-serif"> MPI_COMM_GET_ATTR</font>.  
If the value is already present, then the outcome  
is as if <font face="sans-serif"> MPI_COMM_DELETE_ATTR</font>was first called to delete the previous  
value (and the callback function <font face="sans-serif"> comm_delete_attr_fn</font> was executed), and a new  
value was next stored. The call is erroneous if there is no key with value  
<font face="sans-serif"> keyval</font>; in particular  
<font face="sans-serif"> MPI_KEYVAL_INVALID</font> is an erroneous key value.  
The call will fail if the <font face="sans-serif"> comm_delete_attr_fn</font> function returned an error code  
other than <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_GET_ATTR(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">comm_keyval</span>, <span style="white-space:nowrap">attribute_val</span>, <span style="white-space:nowrap">flag</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator to which the attribute is attached (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm_keyval</TD><TD>key value (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> attribute_val</TD><TD>attribute value, unless <font face="sans-serif"> flag</font><font face="sans-serif">  = false</font></TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> flag</TD><TD><font face="sans-serif"> false</font> if no attribute is associated with the key (logical)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_get_attr(MPI_Comm comm, int comm_keyval, void *attribute_val, int *flag) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_get_attr(comm, comm_keyval, attribute_val, flag, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">comm_keyval</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: <span style="white-space:nowrap">attribute_val</span><br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">flag</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_GET_ATTR(COMM, COMM_KEYVAL, ATTRIBUTE_VAL, FLAG, IERROR) <br> INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">COMM_KEYVAL</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ATTRIBUTE_VAL</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
Retrieves attribute value by key.  
The call is erroneous if there is no key with value  
<font face="sans-serif"> keyval</font>. On the other hand, the call is correct if the key value  
exists, but no attribute is attached on <font face="sans-serif"> comm</font> for that key; in such case,  
the call returns <font face="sans-serif"> flag</font><font face="sans-serif">  = false</font>. In particular  
<font face="sans-serif"> MPI_KEYVAL_INVALID</font> is an erroneous key value.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The call to <font face="sans-serif"> MPI_Comm_set_attr</font> passes in <font face="sans-serif"> attribute_val</font>  
the <em> value</em> of the attribute; the call to <font face="sans-serif"> MPI_Comm_get_attr</font>  
passes in <font face="sans-serif"> attribute_val</font> the <em> address</em> of  
the  
location where the attribute value is to be returned.  
Thus, if the attribute value itself is a pointer of type <tt>void*</tt>,   
then the  
actual <font face="sans-serif"> attribute_val</font> parameter to  
<font face="sans-serif"> MPI_Comm_set_attr</font> will be of type <tt>void*</tt> and the actual  
<font face="sans-serif"> attribute_val</font> parameter to  
<font face="sans-serif"> MPI_Comm_get_attr</font>  
will be of type <tt>void**</tt>.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
The use of a formal parameter <font face="sans-serif"> attribute_val</font>  
of type  
<tt>void*</tt> (rather than <tt>void**</tt>) avoids the messy type  
casting that would be needed if the attribute value is declared with a  
type other than <tt>void*</tt>.  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_DELETE_ATTR(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">comm_keyval</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> comm</TD><TD>communicator from which the attribute is deleted (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm_keyval</TD><TD>key value (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_delete_attr(MPI_Comm comm, int comm_keyval) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_delete_attr(comm, comm_keyval, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">comm_keyval</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_DELETE_ATTR(COMM, COMM_KEYVAL, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">COMM_KEYVAL</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Delete attribute from cache by key. This function invokes the  
attribute delete function <font face="sans-serif"> comm_delete_attr_fn</font>  
specified when the <font face="sans-serif"> keyval</font> was created.  
The call will fail if the <font face="sans-serif"> comm_delete_attr_fn</font> function returns an  
error code other than <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>.  
<P> 
Whenever a communicator is replicated using the function  
<font face="sans-serif"> MPI_COMM_DUP</font>, <font face="sans-serif"> MPI_COMM_IDUP</font>,  
<font face="sans-serif"> MPI_COMM_DUP_WITH_INFO</font> or <font face="sans-serif"> MPI_COMM_IDUP_WITH_INFO</font>,  
all call-back copy functions for attributes  
that are currently set are invoked (in arbitrary order).  
Whenever a communicator is deleted using the function  
<font face="sans-serif"> MPI_COMM_FREE</font> all callback delete functions for attributes  
that are currently set are invoked.  
<P> 

<P>
<hr>
<a href="node207.htm#Node207"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node206.htm#Node206"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node209.htm#Node209"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node206.htm#Node206"> Caching</a>
<b>Next: </b><a href="node209.htm#Node209"> Windows</a>
<b>Previous: </b><a href="node207.htm#Node207"> Functionality</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
