<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Derived Datatypes</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node98">6.1. Derived Datatypes</span></h1>
<a href="node97.htm#Node97"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node97.htm#Node97"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node99.htm#Node99"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node97.htm#Node97"> Datatypes</a>
<b>Next: </b><a href="node99.htm#Node99"> Type Constructors with Explicit Addresses</a>
<b>Previous: </b><a href="node97.htm#Node97"> Datatypes</a>
<p>
  
  
<P> 
Point-to-point communications on buffers containing a sequence of identical basic datatypes  
is constraining.  One often wants to pass  
messages that contain values with different datatypes (e.g., an integer count,  
followed by a sequence of real numbers); and one often wants to send  
noncontiguous data (e.g., a sub-block of a matrix).  One solution is to  
pack noncontiguous data into a contiguous buffer  
at the sender site and unpack it  
at the receiver site.   This has  
the disadvantage of requiring additional memory-to-memory copy operations  
at both sites, even when the communication  
subsystem has scatter-gather capabilities.   Instead, <font face="sans-serif"> MPI</font> provides  
mechanisms to specify more general, mixed, and noncontiguous  
communication buffers. It is up to the implementation to decide  
whether data should be first packed in a contiguous buffer before being  
transmitted, or whether it can be collected directly from where it  
resides.  
<P> 
The general mechanisms provided here allow one to transfer directly,  
without copying, objects of various shapes and sizes.  It is not assumed  
that the <font face="sans-serif"> MPI</font> library is cognizant of the objects declared in the host  
language. Thus, if one wants to transfer a structure, or an array  
section, it will be necessary to provide in <font face="sans-serif"> MPI</font> a definition of a  
communication buffer that mimics the definition of the structure or  
array section in question.  These facilities can be used by library  
designers to define communication functions that can transfer objects  
defined in the host language---by decoding their definitions as  
available in a symbol table or a dope vector.  Such higher-level  
communication functions are not part of <font face="sans-serif"> MPI</font>.  
<P> 
More general communication buffers are specified by replacing the  
basic datatypes that have been used so far with derived datatypes that  
are constructed from basic datatypes using the constructors described  
in this section.  These methods of constructing derived datatypes can  
be applied recursively.  
<P> 
A <b> general datatype</b> is an opaque object that specifies two  
things:  
<ul> 
 
<li>A sequence of basic datatypes.  
 
<li>A sequence of integer (byte) displacements.  
</ul> 
<br> 
The displacements are not required to be positive, distinct, or  
in increasing order. Therefore, the order of items need not  
coincide with their order in store, and an item may appear more than  
once.  
We call such a pair of sequences (or sequence of pairs) a <b> type map</b>.  
The sequence of basic datatypes (displacements ignored) is the <b> type  
signature</b> of the datatype.  
<P> 
Let  
<p><i><span style="font-family:serif;"> <em>Typemap</em></span> = { (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) } , 
</i><p>  
be such a type map, where <i><span style="font-family:serif;"> <em>type</em></span><SUB>i</SUB></i> are basic types, and  
<i><span style="font-family:serif;"> <em>disp</em></span><SUB>i</SUB></i> are  displacements.  
Let  
<p><i><span style="font-family:serif;"> <em>Typesig</em></span> = { <span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , ... , <span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> } 
</i><p>  
be the associated type signature.  
This type map, together with a base address <font face="sans-serif"> buf</font>,  
specifies a communication buffer: the communication buffer that consists of <i>n</i>  
entries, where the <i>i</i>-th entry is at address <i><span style="font-family:sans-serif;"> buf</span> + 
<span style="font-family:serif;"> <em>disp</em></span><SUB>i</SUB></i> and has type <i><span style="font-family:serif;"> <em>type</em></span><SUB>i</SUB></i>.  
A message assembled from such a  
communication buffer will consist of <i>n</i> values, of the types defined  
by <i><span style="font-family:serif;"> <em>Typesig</em></span></i>.  
<P> 
Most datatype constructors have replication count or block length arguments.  
Allowed values are nonnegative integers. If the value is zero, no elements are  
generated in the type map and there is no effect on datatype bounds or  
extent.  
<P> 
We can use a handle to a general datatype as an argument in a send or  
receive operation, instead of a basic datatype argument.  The  
operation  
<font face="sans-serif"> MPI_SEND</font><font face="sans-serif"> (buf, 1, datatype,<i>...</i>)</font> will use the send buffer  
defined by the base address <font face="sans-serif"> buf</font> and the general datatype  
associated with <font face="sans-serif"> datatype</font>; it will generate a message with the type  
signature determined by the <font face="sans-serif"> datatype</font> argument.  
<font face="sans-serif"> MPI_RECV</font><font face="sans-serif"> (buf, 1, datatype,<i>...</i>)</font> will use the receive buffer  
defined by the base address <font face="sans-serif"> buf</font> and the general datatype  
associated with <font face="sans-serif"> datatype</font>.  
<P> 
General datatypes can be used in all send and receive  
operations.  We discuss, in Section <a href="node109.htm#Node109">Use of General Datatypes in Communication</a>, the  
case where the second argument <font face="sans-serif"> count</font> has value <i>&gt; 1</i>.  
<P> 
The basic datatypes presented in  
Section <a href="node59.htm#Node59">Message Data</a>  
are particular cases of a general datatype, and are predefined.  
Thus, <font face="sans-serif"> MPI_INT</font> is a predefined handle to a datatype with type  
map <i>{ (<tt> int</tt>, 0) }</i>, with one entry of type <tt> int</tt> and  
displacement zero.  The other basic datatypes are similar.  
<P> 
The <b> extent</b> of a datatype is defined to  
be the span from the first byte to the last byte occupied by entries in this  
datatype, rounded up to satisfy alignment requirements.  
That is, if  
<p><i><span style="font-family:serif;"> <em>Typemap</em></span> = { (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) } , 
</i><p>  
then  
<P><span id="node98.htm#Equation1"><img width=669 height=113 src="img1.gif" alt="Image file"></span><P>
If <i><span style="font-family:serif;"> <em>type</em></span><SUB>j</SUB></i> requires alignment to a byte address that  
is  
a multiple  
of <i>k<SUB>j</SUB></i>,  
then <i>&epsilon;</i> is the least nonnegative increment needed to round  
<i>extent(<span style="font-family:serif;"> <em>Typemap</em></span>)</i> to the next multiple of <i><tt> max</tt><SUB>j</SUB> k<SUB>j</SUB></i>.  
In Fortran, it is implementation dependent whether the <font face="sans-serif"> MPI</font> implementation  
computes the alignments <i>k<SUB>j</SUB></i> according to the alignments  
used by the compiler in common blocks, <tt> SEQUENCE</tt> derived types,  
<tt> BIND(C)</tt> derived types,  
or derived types that are neither <tt> SEQUENCE</tt> nor <tt> BIND(C)</tt>.  
The complete definition of <b> extent</b> is given  
by Equation <a href="node98.htm#Equation1">1</a>.  
<P> 
<br><b> Example</b>  
  
Assume that  
<i>Type = { (<tt> double</tt>,0), (<tt> char</tt>, 8) }</i><P> 
(a <tt> double</tt> at  
displacement zero, followed by a <tt> char</tt> at displacement eight).  
Assume, furthermore, that  
doubles have to be strictly aligned at addresses that are multiples of eight.  
Then, the extent of this datatype is 16 (9 rounded to the next multiple of 8).  
A datatype that consists of a character immediately followed by a double will  
also have an extent of 16.  
  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The definition of extent is motivated by the assumption that  
the amount of padding added at the end of each structure in an array of  
structures is the least needed to fulfill alignment constraints.  
More explicit control of the extent is provided in  
Section <a href="node104.htm#Node104">Lower-Bound and Upper-Bound Markers</a>.  Such explicit control is needed  
in cases where the assumption does not hold, for example, where union types  
are used.  
In Fortran, structures can be expressed with several language features, e.g.,  
common blocks, <tt> SEQUENCE</tt> derived types, or <tt> BIND(C)</tt> derived types. The compiler may  
use different alignments, and therefore, it is recommended to use <font face="sans-serif"> MPI_TYPE_CREATE_RESIZED</font>  
for arrays of structures if an alignment may cause an alignment-gap at the end of  
a structure as described  
in Section <a href="node104.htm#Node104">Lower-Bound and Upper-Bound Markers</a> and  
in Section <a href="node484.htm#Node484">Fortran Derived Types</a>.  
 (<em> End of rationale.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node97.htm#Node97"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node97.htm#Node97"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node99.htm#Node99"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node97.htm#Node97"> Datatypes</a>
<b>Next: </b><a href="node99.htm#Node99"> Type Constructors with Explicit Addresses</a>
<b>Previous: </b><a href="node97.htm#Node97"> Datatypes</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
