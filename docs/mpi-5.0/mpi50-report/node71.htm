<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Buffer Allocation and Usage</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node71">4.6. Buffer Allocation and Usage</span></h1>
<a href="node70.htm#Node70"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node55.htm#Node55"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node72.htm#Node72"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node55.htm#Node55"> Point-to-Point Communication</a>
<b>Next: </b><a href="node72.htm#Node72"> Model Implementation of Buffered Mode</a>
<b>Previous: </b><a href="node70.htm#Node70"> Semantics of Point-to-Point Communication</a>
<p>
  
  
  
  
<P> 
A user may specify up to one buffer per communicator, up to one buffer per session, and up to one buffer per <font face="sans-serif"> MPI</font> process to be used for buffering messages sent in buffered mode.  Buffering is done by the sender.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_ATTACH_BUFFER(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">buffer</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buffer</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> size</TD><TD>buffer size, in bytes (nonnegative integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_attach_buffer(MPI_Comm comm, void *buffer, int size) <br></tt>  
  
  <tt> int MPI_Comm_attach_buffer_c(MPI_Comm comm, void *buffer, MPI_Count size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_attach_buffer(comm, buffer, size, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buffer</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Comm_attach_buffer(comm, buffer, size, ierror) !(_c) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buffer</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_ATTACH_BUFFER(COMM, BUFFER, SIZE, IERROR) <br> INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUFFER(*)</span> <br></tt>  
<P> 
Provides to <font face="sans-serif"> MPI</font> a communicator-specific buffer in memory. This is to be used for buffering outgoing  
messages sent when a buffered mode send is started that uses the communicator <font face="sans-serif"> comm</font>.  
<P> 
If <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is passed as the argument <font face="sans-serif"> buffer</font>, no explicit buffer is attached; rather, automatic buffering is enabled for all buffered mode communication associated with the communicator <font face="sans-serif"> comm</font> (see Section <a href="node71.htm#Node71">Buffer Allocation and Usage</a>).  
Further, if <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is passed as the argument <font face="sans-serif"> buffer</font>, the value of <font face="sans-serif"> size</font> is irrelevant.  
Note that in Fortran <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is an  
object like <font face="sans-serif"> MPI_BOTTOM</font> (not usable for initialization or  
assignment), see Section <a href="node38.htm#Node38">Named Constants</a>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SESSION_ATTACH_BUFFER(<span style="white-space:nowrap">session</span>, <span style="white-space:nowrap">buffer</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> session</TD><TD>session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buffer</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> size</TD><TD>buffer size, in bytes (nonnegative integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Session_attach_buffer(MPI_Session session, void *buffer, int size) <br></tt>  
  
  <tt> int MPI_Session_attach_buffer_c(MPI_Session session, void *buffer, MPI_Count size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Session_attach_buffer(session, buffer, size, ierror) <br> TYPE(MPI_Session), INTENT(IN) :: <span style="white-space:nowrap">session</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buffer</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Session_attach_buffer(session, buffer, size, ierror) !(_c) <br> TYPE(MPI_Session), INTENT(IN) :: <span style="white-space:nowrap">session</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buffer</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SESSION_ATTACH_BUFFER(SESSION, BUFFER, SIZE, IERROR) <br> INTEGER <span style="white-space:nowrap">SESSION</span>, <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUFFER(*)</span> <br></tt>  
<P> 
Provides to <font face="sans-serif"> MPI</font> a session-specific buffer in memory. This buffer is to be used for buffering outgoing  
messages sent when using a communicator that is created from a group that is derived from the session <font face="sans-serif"> session</font>. However, if there is a communicator-specific buffer attached to the particular communicator at the time of the buffered mode send is started, that buffer is used.  
<P> 
If <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is passed as the argument <font face="sans-serif"> buffer</font>, no explicit buffer is attached; rather, automatic buffering is enabled for all buffered mode communication associated with the session <font face="sans-serif"> session</font> that is not explicitly covered by a buffer provided at communicator level (see Section <a href="node71.htm#Node71">Buffer Allocation and Usage</a>).  
Further, if <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is passed as the argument <font face="sans-serif"> buffer</font>, the value of <font face="sans-serif"> size</font> is irrelevant.  
Note that in Fortran <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is an  
object like <font face="sans-serif"> MPI_BOTTOM</font> (not usable for initialization or  
assignment), see Section <a href="node38.htm#Node38">Named Constants</a>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BUFFER_ATTACH(<span style="white-space:nowrap">buffer</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buffer</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> size</TD><TD>buffer size, in bytes (nonnegative integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Buffer_attach(void *buffer, int size) <br></tt>  
  
  <tt> int MPI_Buffer_attach_c(void *buffer, MPI_Count size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Buffer_attach(buffer, size, ierror) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buffer</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Buffer_attach(buffer, size, ierror) !(_c) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buffer</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_BUFFER_ATTACH(BUFFER, SIZE, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUFFER(*)</span><br>INTEGER <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Provides to <font face="sans-serif"> MPI</font> an <font face="sans-serif"> MPI</font> process-specific buffer in memory. This buffer is to be used for buffering outgoing  
messages sent when using a communicator to which no communicator-specific buffer is attached or which is derived from a session to which no session-specific buffer is attached at the time the buffered mode send is started.  
<P> 
If <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is passed as the argument <font face="sans-serif"> buffer</font>, no explicit buffer is attached; rather, automatic buffering is enabled for all buffered mode communication not explicitly covered by a buffer provided at session or communicator level (see Section <a href="node71.htm#Node71">Buffer Allocation and Usage</a>).  
Further, if <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is passed as the argument <font face="sans-serif"> buffer</font>, the value of <font face="sans-serif"> size</font> is irrelevant.  
Note that in Fortran <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is an  
object like <font face="sans-serif"> MPI_BOTTOM</font> (not usable for initialization or  
assignment), see Section <a href="node38.htm#Node38">Named Constants</a>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The use of a global shared buffer can be problematic when used for communication in different libraries, as the buffer represents a shared resource used for all buffered mode communication. Further, with the introduction of the Sessions Model, the use of a single shared buffer violates the concept of resource isolation that is intended with <font face="sans-serif"> MPI</font> Sessions. It is therefore recommended, especially for libraries and programs using the Sessions Model, to use only communicator-specific or session-specific buffers.  
 (<em> End of advice to users.</em>) <br> 
Any of these buffers are used only for messages sent in buffered mode.  
Only one <font face="sans-serif"> MPI</font> process-specific buffer can be attached to an <font face="sans-serif"> MPI</font> process at a time,  
only one session-specific buffer can be attached to a session at a time and  
only one communicator-specific buffer can be attached to a communicator at a time.  
<P> 
If automatic buffering is enabled at any level, no other buffer can be attached at that level.  
<P> 
A particular memory region can only be used in one buffer; reusing buffer space  
for multiple sessions, communicators and/or the global buffer is erroneous.  
Further, only one buffer is used for any one communication  
following the rules above; buffer space is not combined, even if two buffers are directly  
or indirectly provided  to a communicator to be used for buffered sends.  
<P> 
In C, <font face="sans-serif"> buffer</font> is the starting address of a memory region.  
In Fortran, one can pass the first element of a memory region  
or a whole array, which must be `simply contiguous'  
(for `simply contiguous,' see also  
Section <a href="node481.htm#Node481">Problems Due to Data Copying and Sequence Association with Subscript Triplets</a>).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_DETACH_BUFFER(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">buffer_addr</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buffer_addr</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> size</TD><TD>buffer size, in bytes (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_detach_buffer(MPI_Comm comm, void *buffer_addr, int *size) <br></tt>  
  
  <tt> int MPI_Comm_detach_buffer_c(MPI_Comm comm, void *buffer_addr, MPI_Count *size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_detach_buffer(comm, buffer_addr, size, ierror) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(C_PTR), INTENT(OUT) :: <span style="white-space:nowrap">buffer_addr</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Comm_detach_buffer(comm, buffer_addr, size, ierror) !(_c) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(C_PTR), INTENT(OUT) :: <span style="white-space:nowrap">buffer_addr</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_DETACH_BUFFER(COMM, BUFFER_ADDR, SIZE, IERROR) <br> INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUFFER_ADDR(*)</span> <br></tt>  
<P> 
Detach the communicator-specific buffer currently attached to the communicator.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SESSION_DETACH_BUFFER(<span style="white-space:nowrap">session</span>, <span style="white-space:nowrap">buffer_addr</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> session</TD><TD>session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buffer_addr</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> size</TD><TD>buffer size, in bytes (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Session_detach_buffer(MPI_Session session, void *buffer_addr, int *size) <br></tt>  
  
  <tt> int MPI_Session_detach_buffer_c(MPI_Session session, void *buffer_addr, MPI_Count *size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Session_detach_buffer(session, buffer_addr, size, ierror) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(MPI_Session), INTENT(IN) :: <span style="white-space:nowrap">session</span><br>TYPE(C_PTR), INTENT(OUT) :: <span style="white-space:nowrap">buffer_addr</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Session_detach_buffer(session, buffer_addr, size, ierror) !(_c) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(MPI_Session), INTENT(IN) :: <span style="white-space:nowrap">session</span><br>TYPE(C_PTR), INTENT(OUT) :: <span style="white-space:nowrap">buffer_addr</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SESSION_DETACH_BUFFER(SESSION, BUFFER_ADDR, SIZE, IERROR) <br> INTEGER <span style="white-space:nowrap">SESSION</span>, <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUFFER_ADDR(*)</span> <br></tt>  
<P> 
Detach the session-specific buffer currently attached to the session.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BUFFER_DETACH(<span style="white-space:nowrap">buffer_addr</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buffer_addr</TD><TD>initial buffer address (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> size</TD><TD>buffer size, in bytes (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Buffer_detach(void *buffer_addr, int *size) <br></tt>  
  
  <tt> int MPI_Buffer_detach_c(void *buffer_addr, MPI_Count *size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Buffer_detach(buffer_addr, size, ierror) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(C_PTR), INTENT(OUT) :: <span style="white-space:nowrap">buffer_addr</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Buffer_detach(buffer_addr, size, ierror) !(_c) <br> USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_PTR <br>TYPE(C_PTR), INTENT(OUT) :: <span style="white-space:nowrap">buffer_addr</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_BUFFER_DETACH(BUFFER_ADDR, SIZE, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUFFER_ADDR(*)</span><br>INTEGER <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Detach the <font face="sans-serif"> MPI</font> process-specific buffer buffer currently attached to <font face="sans-serif"> MPI</font>.  
<P> 
The procedure calls return the  
address and the size of the detached buffer.  
If <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> was used in the corresponding attach procedure, then <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> is also returned in the detach procedure and the value returned in argument <font face="sans-serif"> size</font> is undefined.  
In this case, automatic buffering is disabled upon return from the detach procedure.  
When using Fortran <tt>mpi_f08</tt>, the returned value is identical to <tt>c_loc(MPI_BUFFER_AUTOMATIC)</tt>. Note that <tt>c_loc()</tt> is an intrinsic in the Fortran <tt> ISO_C_BINDING</tt> module.  
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
In Fortran, the implementation of <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> must allow the intrinsic <tt>c_loc</tt> to be applied to it.  
 (<em> End of advice to implementors.</em>) <br> 
These procedures  
will delay their return until all messages currently in the (explicit or automatic) buffer have been transmitted.  
Upon return of  
these procedures, the user may reuse or deallocate the space taken by the buffer.  
<P> 
If the size of the detached buffer cannot be represented in  
<font face="sans-serif"> size</font>, it is set to <font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 
  
The following <font face="sans-serif"> MPI_XXX_FLUSH_BUFFER</font> procedures, as well as <font face="sans-serif"> MPI_BUFFER_FLUSH</font> itself, will not return until all messages currently in the buffer have been transmitted without detaching the buffer.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
These flush procedures provide the same functionality as an atomic combination of first detaching the buffer and then attaching it again (but without having to actually execute the detaching and the re-attaching of the buffer), but they may be implemented with less internal overhead.  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_FLUSH_BUFFER(<span style="white-space:nowrap">comm</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_flush_buffer(MPI_Comm comm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_flush_buffer(comm, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_FLUSH_BUFFER(COMM, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_COMM_FLUSH_BUFFER</font> will not return until all messages currently in the communicatorspecific buffer of the calling <font face="sans-serif"> MPI</font> process have been transmitted.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SESSION_FLUSH_BUFFER(<span style="white-space:nowrap">session</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> session</TD><TD>session (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Session_flush_buffer(MPI_Session session) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Session_flush_buffer(session, ierror) <br> TYPE(MPI_Session), INTENT(IN) :: <span style="white-space:nowrap">session</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SESSION_FLUSH_BUFFER(SESSION, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">SESSION</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_SESSION_FLUSH_BUFFER</font> will not return until all messages currently in the session-specific buffer of the calling <font face="sans-serif"> MPI</font> process have been transmitted.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BUFFER_FLUSH()</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Buffer_flush(void) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Buffer_flush(ierror) <br> <br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_BUFFER_FLUSH(IERROR) <br> <br>INTEGER <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_BUFFER_FLUSH</font> will not return until all messages currently in the <font face="sans-serif"> MPI</font> process-specific buffer of the calling <font face="sans-serif"> MPI</font> process have been transmitted.  
<P> 
For all <font face="sans-serif"> MPI_XXX_FLUSH_BUFFER</font> procedures, there also exist the following nonblocking variants, which start the respective flush operation. These operations will not complete until all messages currently in the respective  buffer of the calling <font face="sans-serif"> MPI</font> process have been transmitted.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMM_IFLUSH_BUFFER(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Comm_iflush_buffer(MPI_Comm comm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Comm_iflush_buffer(comm, request, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMM_IFLUSH_BUFFER(COMM, REQUEST, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_SESSION_IFLUSH_BUFFER(<span style="white-space:nowrap">session</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> session</TD><TD>session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Session_iflush_buffer(MPI_Session session, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Session_iflush_buffer(session, request, ierror) <br> TYPE(MPI_Session), INTENT(IN) :: <span style="white-space:nowrap">session</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SESSION_IFLUSH_BUFFER(SESSION, REQUEST, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">SESSION</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BUFFER_IFLUSH(<span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Buffer_iflush(MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Buffer_iflush(request, ierror) <br> TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_BUFFER_IFLUSH(REQUEST, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<br><b> Example</b>  
  
Calls to attach and detach buffers.  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>#define</b> BUFFSIZE 10000+<b>MPI_BSEND_OVERHEAD</b> 
<b>int</b> size; 
<b>char</b> *buff; 
<b>MPI_Buffer_attach</b>(malloc(BUFFSIZE), BUFFSIZE); 
/* a buffer of 10000 bytes can now be used by <b>MPI_Bsend</b> */ 
/* on all communicators, assuming only one message at a time is sent */ 
<b>MPI_Buffer_detach</b>(&amp;buff, &amp;size); 
/* Buffer size reduced to zero */ 
<b>MPI_Buffer_attach</b>(buff, size); 
/* Buffer of 10000 bytes available again */ 
</tt></pre> 
  
  
<P> 
<br><b> Example</b>  
  
Calls to attach and detach communicator-specific buffers.  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>#define</b> BUFFSIZE1 10000+<b>MPI_BSEND_OVERHEAD</b> 
<b>#define</b> BUFFSIZE2 20000+<b>MPI_BSEND_OVERHEAD</b> 
<b>int</b> size; 
<b>char</b> *buff1, *buff2; 
<b>MPI_Comm</b> world_dup; 
<b>MPI_Comm_dup</b>(<b>MPI_COMM_WORLD</b>, &amp;world_dup); 
<b>MPI_Comm_attach_buffer</b>(<b>MPI_COMM_WORLD</b>, malloc(BUFFSIZE2), BUFFSIZE2); 
<b>MPI_Buffer_attach</b>(malloc(BUFFSIZE1), BUFFSIZE1); 
/* a buffer of 20000 bytes can now be used by <b>MPI_Bsend</b> <b>for</b> */ 
/* communication using <b>MPI_COMM_WORLD</b>,  assuming only one message */ 
/* at a time is sent a buffer of 10000 bytes can now be used by */ 
/* <b>MPI_Bsend</b> <b>for</b> communication using any other communicator, */ 
/* including world_dup assuming only one message at a time is sent */ 
<b>MPI_Comm_detach_buffer</b>(<b>MPI_COMM_WORLD</b>, &amp;buff1, &amp;size); 
<b>MPI_Buffer_detach</b>(&amp;buff2, &amp;size); 
/* Both buffers are detached and no specific or MPI process-specific */ 
/* buffer can be used <b>for</b> further <b>MPI_Bsend</b> */ 
</tt></pre> 
  
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Even though the C procedures  
<font face="sans-serif"> MPI_Buffer_attach</font>,  
<font face="sans-serif"> MPI_Session_attach_buffer</font>,  
<font face="sans-serif"> MPI_Comm_attach_buffer</font>,  
<font face="sans-serif"> MPI_Buffer_detach</font>,  
<font face="sans-serif"> MPI_Session_detach_buffer</font> and  
<font face="sans-serif"> MPI_Comm_detach_buffer</font>  
have  
an argument of type <tt>void*</tt>, these arguments are used  
differently: a pointer to the buffer is passed to  
<font face="sans-serif"> MPI_Buffer_attach</font>,  
<font face="sans-serif"> MPI_Session_attach_buffer</font> and  
<font face="sans-serif"> MPI_Comm_attach_buffer</font>;  
the address of the pointer is passed to  
<font face="sans-serif"> MPI_Buffer_detach</font>,  
<font face="sans-serif"> MPI_Session_detach_buffer</font> and  
<font face="sans-serif"> MPI_Comm_detach_buffer</font>, so that  
this call can return the pointer value.  
In Fortran with the <tt>mpi</tt> module or (deprecated) <tt>mpif.h</tt>, the type of the <font face="sans-serif"> buffer_addr</font> argument is  
wrongly defined and the argument is therefore unused.  
In Fortran with the <tt>mpi_f08</tt> module, the address of the buffer is returned  
as <tt> TYPE(C_PTR)</tt>, see also  
Example <a href="node253.htm#Node253">Memory Allocation</a>  
about the use of <tt> C_PTR</tt> pointers.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
In all cases, arguments are defined to be of type <tt>void*</tt> (rather than  
<tt>void*</tt> and <tt>void**</tt>, respectively), so as to avoid complex type  
casts. E.g., in the last two examples, <tt>&amp;buff</tt>, which is of type  
<tt>char**</tt>, can be passed as argument to <font face="sans-serif"> MPI_Buffer_detach</font>,  
<font face="sans-serif"> MPI_Session_detach_buffer</font> and  
<font face="sans-serif"> MPI_Comm_detach_buffer</font>  
without type casting.  If the formal parameter had type <tt>void**</tt> then we  
would need a type cast before and after each call.  
 (<em> End of rationale.</em>) <br> 
<b> General semantics of buffered mode sends.</b>  
The statements made in this section describe the behavior of <font face="sans-serif"> MPI</font>  
for buffered-mode sends.  
<P> 
When no <font face="sans-serif"> MPI</font> process-specific buffer is currently (explicitly) attached and if no automatic buffering is enabled, <font face="sans-serif"> MPI</font> behaves as if a  
zero-sized <font face="sans-serif"> MPI</font> process-specific buffer is (implicitly) attached.  
<P> 
It is erroneous to detach a communicator-specific, session-specific, or <font face="sans-serif"> MPI</font> process-specific buffer, if no such buffer had been attached using a corresponding attach procedure. This includes attach procedure calls using <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> as the buffer argument.  
It is erroneous to attach a communicator-specific, session-specific, or <font face="sans-serif"> MPI</font> process-specific buffer, if such buffer had already been attached using a corresponding attach procedure and not yet been detached again. This includes attach procedure calls using <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font> as the buffer argument.  
It is erroneous to flush a communicator-specific, session-specific or <font face="sans-serif"> MPI</font> process-specific buffer, if there is no buffer attached (including automatic buffering).  
<P> 
<font face="sans-serif"> MPI_COMM_ATTACH_BUFFER</font>, <font face="sans-serif"> MPI_SESSION_ATTACH_BUFFER</font>, and <font face="sans-serif"> MPI_BUFFER_ATTACH</font> are local.  
<font face="sans-serif"> MPI_COMM_DETACH_BUFFER</font>, <font face="sans-serif"> MPI_SESSION_DETACH_BUFFER</font>,  <font face="sans-serif"> MPI_BUFFER_DETACH</font>,  
 <font face="sans-serif"> MPI_COMM_FLUSH_BUFFER</font>,  
<font face="sans-serif"> MPI_SESSION_FLUSH_BUFFER</font>, and <font face="sans-serif"> MPI_BUFFER_FLUSH</font>  
are nonlocal;  
they must not return before all buffered messages in their related buffers are transmitted,  
and they must eventually return when all corresponding receive operations are started  
(provided that none are cancelled).  
<P> 
<b> Automatic buffering with buffered mode sends.</b>  
  
If the buffer used at the time of buffered mode send is set to the buffer address <font face="sans-serif"> MPI_BUFFER_AUTOMATIC</font>, then a buffer of sufficient size is  
automatically used by the <font face="sans-serif"> MPI</font> library.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
When using automatic buffering, the user relinquishes control over buffer management, including allocation and deallocation decisions and timing, to the <font face="sans-serif"> MPI</font> library. If explicit control is needed over when and how much buffer space is allocated, automatic buffering must not be used.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
High-quality implementations of an <font face="sans-serif"> MPI</font> library should strive to support automatic buffering in a balanced fashion, i.e., providing the right balance between memory allocated for send operations and memory available for the end user.  
 (<em> End of advice to implementors.</em>) <br> 
The flush operations for the communicator-specific, session-specific, and <font face="sans-serif"> MPI</font> process-specific buffers  
can also be used for automatic buffering. The flush procedure will not return until all automatically allocated buffers  
for the communicator-specific, session-specific, or <font face="sans-serif"> MPI</font> process-specific buffers, respectively, no longer hold message data and could be deallocated by the <font face="sans-serif"> MPI</font> library, if it chooses to do so.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
With standard mode send, the limitation of needed buffer space is implemented within  
the <font face="sans-serif"> MPI</font> library through switching from internal buffering to internal synchronous mode.  
If the user wants to limit the automatically allocated buffer space for buffered mode send  
using automatic buffering, the user may call explicitly the appropriate flush procedure to wait  
until automatically allocated buffers are deallocated.  
 (<em> End of advice to users.</em>) <br> 
<b> Further rules.</b>  
In the case of an attached buffer (i.e., not using automatic buffering),  
the user must provide as much buffering for outgoing messages as would be required if  
outgoing message  
data were buffered by the sending <font face="sans-serif"> MPI</font> process, in the specified buffer space,  
using a circular, contiguous-space allocation policy.  
We outline below a model implementation that defines this policy.  
<font face="sans-serif"> MPI</font> may provide more buffering, and may use a better buffer allocation  
algorithm than described below.  
On the other hand, <font face="sans-serif"> MPI</font> may signal an error whenever the  
simple buffering allocator described below would run out of space.  
<font face="sans-serif"> MPI</font> must not require more buffer space as described in the model implementation below.  
<P> 
<font face="sans-serif"> MPI</font> does not provide mechanisms for querying or controlling buffering done by  
standard mode sends.  It is expected that vendors will provide such  
information  
for their implementations.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
There is a wide spectrum of possible implementations of buffered communication operations:  
buffering can be done at sender, at receiver, or both; buffers can be dedicated  
to one sender-receiver pair, or be shared by  
all communication operations; buffering can be done in real or  
in virtual memory; it can use dedicated memory, or memory shared by other  
<font face="sans-serif"> MPI</font> processes; buffer space may be allocated statically or be changed dynamically;  
etc.  It does not seem feasible to provide a portable mechanism for querying  
or controlling buffering that would be compatible with all these choices, yet  
provide meaningful information.  
 (<em> End of rationale.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node70.htm#Node70"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node55.htm#Node55"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node72.htm#Node72"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node55.htm#Node55"> Point-to-Point Communication</a>
<b>Next: </b><a href="node72.htm#Node72"> Model Implementation of Buffered Mode</a>
<b>Previous: </b><a href="node70.htm#Node70"> Semantics of Point-to-Point Communication</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
