<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Multiple Completions</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node78">4.7.5. Multiple Completions</span></h2>
<a href="node77.htm#Node77"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node73.htm#Node73"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node79.htm#Node79"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node73.htm#Node73"> Nonblocking Communication</a>
<b>Next: </b><a href="node79.htm#Node79"> Non-Destructive Test of <font face="sans-serif"> status</font></a>
<b>Previous: </b><a href="node77.htm#Node77"> Semantics of Nonblocking Communication Operations</a>
<p>
  
  
  
  
<P> 
It is convenient to be able to wait for the <em> completion</em> of any, some, or all the  
operations in a list, rather than having to wait for a specific message.  
A call to <font face="sans-serif"> MPI_WAITANY</font> or <font face="sans-serif"> MPI_TESTANY</font> can be used to  
wait for the  
<em> completion</em> of one out of several operations. A call to <font face="sans-serif"> MPI_WAITALL</font>  
or <font face="sans-serif"> MPI_TESTALL</font> can be  
used to wait for all <em> pending</em> operations in a list. A call to  
<font face="sans-serif"> MPI_WAITSOME</font> or <font face="sans-serif"> MPI_TESTSOME</font> can be used to <em> complete</em> all  
enabled operations in a list.  
<P> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_WAITANY(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_requests</span>, <span style="white-space:nowrap">index</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>list length (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> index</TD><TD>index of handle for operation that completed (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Waitany(int count, MPI_Request array_of_requests[], int *index, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Waitany(count, array_of_requests, index, status, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">array_of_requests(count)</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">index</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WAITANY(COUNT, ARRAY_OF_REQUESTS, INDEX, STATUS, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_REQUESTS(*)</span>, <span style="white-space:nowrap">INDEX</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Does not return until   
one of the operations associated with the <em> active</em>  
requests in the array has <em> completed</em>.  
If more than one operation is  
enabled and can <em> complete</em>, one is arbitrarily chosen.  
Returns in <font face="sans-serif"> index</font> the index  
of that request in the array and returns in <font face="sans-serif"> status</font> the status of the  
completing operation.  
(The array is indexed from zero in C, and from one in Fortran.)  
If the request  
is an <em> active</em> <em> persistent communication request</em>, it is marked <em> inactive</em>.  Any other type of  
request  
is deallocated and the request handle is set to <font face="sans-serif"> MPI_REQUEST_NULL</font>.  
<P> 
The <font face="sans-serif"> array_of_requests</font> list may contain <em> null</em> or <em> inactive</em>  
handles.  
If the list contains no <em> active</em> handles (list has length zero or all  
entries are <em> null</em> or <em> inactive</em>),  
then the call returns immediately with  
<font face="sans-serif"> index</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_UNDEFINED</font>, and an <em> empty</em> <font face="sans-serif"> status</font>.  
<P> 
The execution of  
<font face="sans-serif"> MPI_WAITANY</font>  
with an array containing multiple entries  
has the same effect as the execution of  
<font face="sans-serif"> MPI_WAIT</font>  
with the array entry indicated by the output value of <font face="sans-serif"> index</font>  
(unless the output value of <font face="sans-serif"> index</font> is <font face="sans-serif"> MPI_UNDEFINED</font>).  
<font face="sans-serif"> MPI_WAITANY</font> with an array containing one <em> active</em> entry  
is equivalent to <font face="sans-serif"> MPI_WAIT</font>.  
<P> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_TESTANY(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_requests</span>, <span style="white-space:nowrap">index</span>, <span style="white-space:nowrap">flag</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>list length (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> index</TD><TD>index of operation that completed or <font face="sans-serif"> MPI_UNDEFINED</font> if none completed (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> flag</TD><TD><font face="sans-serif"> true</font> if one of the operations is complete (logical)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Testany(int count, MPI_Request array_of_requests[], int *index, int *flag, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Testany(count, array_of_requests, index, flag, status, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">array_of_requests(count)</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">index</span><br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">flag</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TESTANY(COUNT, ARRAY_OF_REQUESTS, INDEX, FLAG, STATUS, IERROR) <br> INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_REQUESTS(*)</span>, <span style="white-space:nowrap">INDEX</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
Tests for <em> completion</em> of  
either one or none of the operations associated with <em> active</em> handles.  
In the former case, it returns <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font>,  
returns in <font face="sans-serif"> index</font> the index of this request in the array,  
and returns in <font face="sans-serif"> status</font> the status of that operation.  If  
the request is an <em> active</em> <em> persistent communication request</em>, it is marked as <em> inactive</em>.  
Any other type of request  
is deallocated  
and the handle is set to <font face="sans-serif"> MPI_REQUEST_NULL</font>.  
(The array is indexed from zero in C, and from one in Fortran.)  
In the latter case (no operation <em> completed</em>),  
it returns <font face="sans-serif"> flag</font><font face="sans-serif">  = false</font>, returns a value  
of <font face="sans-serif"> MPI_UNDEFINED</font> in <font face="sans-serif"> index</font> and <font face="sans-serif"> status</font> is  
undefined.  
<P> 
The array may contain <em> null</em> or inactive handles.  
If the  
array contains no <em> active</em> handles then the call returns  
<em> immediately</em> with <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font>,  
<font face="sans-serif"> index</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_UNDEFINED</font>, and an <em> empty</em> <font face="sans-serif"> status</font>.  
<P> 
If the array of requests contains <em> active</em> handles then  
the execution of  
<font face="sans-serif"> MPI_TESTANY</font>  
has the same effect as the execution of  
<font face="sans-serif"> MPI_TEST</font>  
with each of the <em> active</em> handles in the array  
in some arbitrary order, until one call returns <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font>, or  
all return <font face="sans-serif"> flag</font><font face="sans-serif">  = false</font>.  In the former case, <font face="sans-serif"> index</font> is set  
to indicate which array element returned <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font>  
and in the latter case, it is set to <font face="sans-serif"> MPI_UNDEFINED</font>.  
<font face="sans-serif"> MPI_TESTANY</font> with an array containing one <em> active</em> entry  
is equivalent to <font face="sans-serif"> MPI_TEST</font>.  
<P> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_WAITALL(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_requests</span>, <span style="white-space:nowrap">array_of_statuses</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>list length (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_statuses</TD><TD>array of status objects (array of status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Waitall(int count, MPI_Request array_of_requests[], MPI_Status array_of_statuses[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Waitall(count, array_of_requests, array_of_statuses, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">array_of_requests(count)</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">array_of_statuses(*)</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WAITALL(COUNT, ARRAY_OF_REQUESTS, ARRAY_OF_STATUSES, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_REQUESTS(*)</span>, <span style="white-space:nowrap">ARRAY_OF_STATUSES(MPI_STATUS_SIZE, *)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Does not return until   
all communication operations associated with <em> active</em> handles  
in the list <em> complete</em>, and returns the status of all these operations  
(this includes the case where no handle in the list is <em> active</em>).  
Both arrays have the same number of valid entries.  The <tt>i</tt>-th entry in  
<font face="sans-serif"> array_of_statuses</font> is set to the return status of the  
<tt>i</tt>-th operation.  
<em> Active</em> <em> persistent requests</em> are marked <em> inactive</em>.  Requests of any other type  
are  
deallocated and the corresponding handles in the array are set to  
<font face="sans-serif"> MPI_REQUEST_NULL</font>.  
The list may contain <em> null</em> or <em> inactive</em> handles.  
The call sets to <em> empty</em> the status of each such entry.  
<P> 
The error-free execution of  
<font face="sans-serif"> MPI_WAITALL</font>  
has the same effect as the execution of  
<font face="sans-serif"> MPI_WAIT</font>  
for each of the array elements  
in some arbitrary order.  
<font face="sans-serif"> MPI_WAITALL</font> with an array of length one  
is equivalent to <font face="sans-serif"> MPI_WAIT</font>.  
<P> 
When one or more of the communication operations <em> completed</em> by a  
call to <font face="sans-serif"> MPI_WAITALL</font> fail, it is  
desirable to return specific information on each  
communication.  The function <font face="sans-serif"> MPI_WAITALL</font> will return in such  
case the error code <span style="font-size:0.900em;"><font face="sans-serif"> MPI_ERR_IN_STATUS</span></font> and will set the  
error field of each status to a specific error code.  This code will be  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>, if the specific communication <em> completed</em>; it will  
be another specific error code, if it failed;  
or it can be <span style="font-size:0.900em;"><font face="sans-serif"> MPI_ERR_PENDING</span></font> if it has neither failed nor <em> completed</em>.  
The function <font face="sans-serif"> MPI_WAITALL</font> will return <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> if no request  
had an error,  
or will return another error code if it failed  
for other reasons (such as invalid arguments).  In such cases, it will  
not update the error fields of the statuses.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This design streamlines error handling in the application.  
The application code need only test the (single) function result to  
determine if an error has occurred.  It needs to check each individual  
status only when an error occurred.  
 (<em> End of rationale.</em>) <br> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_TESTALL(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_requests</span>, <span style="white-space:nowrap">flag</span>, <span style="white-space:nowrap">array_of_statuses</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>list length (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> flag</TD><TD><font face="sans-serif"> true</font> if all of the operations are complete (logical)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_statuses</TD><TD>array of status objects (array of status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Testall(int count, MPI_Request array_of_requests[], int *flag, MPI_Status array_of_statuses[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Testall(count, array_of_requests, flag, array_of_statuses, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">array_of_requests(count)</span><br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">flag</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">array_of_statuses(*)</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TESTALL(COUNT, ARRAY_OF_REQUESTS, FLAG, ARRAY_OF_STATUSES, IERROR) <br> INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_REQUESTS(*)</span>, <span style="white-space:nowrap">ARRAY_OF_STATUSES(MPI_STATUS_SIZE, *)</span>, <span style="white-space:nowrap">IERROR</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
Returns <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font>  
if all communication operations associated  
with <em> active</em> handles in the array have <em> completed</em> (this includes the  
case where no handle in the list is <em> active</em>).  
In this case, each status entry that corresponds to an  
<em> active</em> request  
is set to the status of the corresponding  
operation.  <em> Active</em> <em> persistent requests</em> are marked <em> inactive</em>.  
Requests of any other type are deallocated and the corresponding handles in  
the array are  
set to <font face="sans-serif"> MPI_REQUEST_NULL</font>.  
Each status entry that corresponds to a <em> null</em> or <em> inactive</em>  
handle is set to <em> empty</em>.  
<P> 
Otherwise,  
<font face="sans-serif"> flag</font><font face="sans-serif">  = false</font> is returned, no request is modified  
and the values of the status entries are undefined.  
This is a <em> local</em> procedure.  
<P> 
Errors that occurred during the execution of <font face="sans-serif"> MPI_TESTALL</font>  
are handled in the same manner as errors in <font face="sans-serif"> MPI_WAITALL</font>.  
<P> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_WAITSOME(<span style="white-space:nowrap">incount</span>, <span style="white-space:nowrap">array_of_requests</span>, <span style="white-space:nowrap">outcount</span>, <span style="white-space:nowrap">array_of_indices</span>, <span style="white-space:nowrap">array_of_statuses</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> incount</TD><TD>length of array_of_requests (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> outcount</TD><TD>number of completed requests (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_indices</TD><TD>array of indices of operations that completed (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_statuses</TD><TD>array of status objects for operations that completed (array of status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Waitsome(int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Waitsome(incount, array_of_requests, outcount, array_of_indices, array_of_statuses, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">incount</span><br>TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">array_of_requests(incount)</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">outcount</span>, <span style="white-space:nowrap">array_of_indices(*)</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">array_of_statuses(*)</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WAITSOME(INCOUNT, ARRAY_OF_REQUESTS, OUTCOUNT, ARRAY_OF_INDICES, ARRAY_OF_STATUSES, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">INCOUNT</span>, <span style="white-space:nowrap">ARRAY_OF_REQUESTS(*)</span>, <span style="white-space:nowrap">OUTCOUNT</span>, <span style="white-space:nowrap">ARRAY_OF_INDICES(*)</span>, <span style="white-space:nowrap">ARRAY_OF_STATUSES(MPI_STATUS_SIZE, *)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Does not return until  
at least one of the operations associated with <em> active</em>  
handles in the list have <em> completed</em>.  
Returns in <font face="sans-serif"> outcount</font> the number of requests from the list  
<font face="sans-serif"> array_of_requests</font> that have <em> completed</em>.  Returns in the first  
<font face="sans-serif"> outcount</font> locations of the array <font face="sans-serif"> array_of_indices</font>  
the indices of these operations (index within the  
array <font face="sans-serif"> array_of_requests</font>; the array is indexed from zero in  
C and from one in  
Fortran).  Returns in the first <font face="sans-serif"> outcount</font>  
locations of the array <font face="sans-serif"> array_of_statuses</font>  
the status for these <em> completed</em> operations.  
<em> Completed</em> <em> active</em> <em> persistent requests</em> are marked as <em> inactive</em>.  Any other  
type or request that <em> completed</em>  
is deallocated, and the  
associated handle is set to <font face="sans-serif"> MPI_REQUEST_NULL</font>.  
<P> 
If the list contains no <em> active</em> handles, then the  
call returns <em> immediately</em> with <font face="sans-serif"> outcount</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 
When one or more of the communication operations <em> completed</em> by  
<font face="sans-serif"> MPI_WAITSOME</font> fails, then it is desirable to return specific  
information on each communication.  
The arguments <font face="sans-serif"> outcount</font>,  
<font face="sans-serif"> array_of_indices</font> and <font face="sans-serif"> array_of_statuses</font> will be  
adjusted to indicate <em> completion</em> of all communication operations that have  
succeeded or failed.  The call will return the error code  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_ERR_IN_STATUS</span></font> and the error field of each status  
returned will be set to indicate success or to indicate the specific error  
that occurred.  The call will return <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> if no request  
resulted in an error,  
and will return another error code if it failed  
for other reasons (such as invalid arguments).  In such cases, it will  
not update the error fields of the statuses.  
<P> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_TESTSOME(<span style="white-space:nowrap">incount</span>, <span style="white-space:nowrap">array_of_requests</span>, <span style="white-space:nowrap">outcount</span>, <span style="white-space:nowrap">array_of_indices</span>, <span style="white-space:nowrap">array_of_statuses</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> incount</TD><TD>length of array_of_requests (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> outcount</TD><TD>number of completed requests (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_indices</TD><TD>array of indices of operations that completed (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_statuses</TD><TD>array of status objects for operations that completed (array of status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Testsome(int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Testsome(incount, array_of_requests, outcount, array_of_indices, array_of_statuses, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">incount</span><br>TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">array_of_requests(incount)</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">outcount</span>, <span style="white-space:nowrap">array_of_indices(*)</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">array_of_statuses(*)</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TESTSOME(INCOUNT, ARRAY_OF_REQUESTS, OUTCOUNT, ARRAY_OF_INDICES, ARRAY_OF_STATUSES, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">INCOUNT</span>, <span style="white-space:nowrap">ARRAY_OF_REQUESTS(*)</span>, <span style="white-space:nowrap">OUTCOUNT</span>, <span style="white-space:nowrap">ARRAY_OF_INDICES(*)</span>, <span style="white-space:nowrap">ARRAY_OF_STATUSES(MPI_STATUS_SIZE, *)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
This procedure behaves like <font face="sans-serif"> MPI_WAITSOME</font>, except that it returns  
<em> immediately</em>. If no operation has completed it  
returns <font face="sans-serif"> outcount</font><font face="sans-serif">  = 0</font>.  
If there is no <em> active</em> handle in the list it  
returns <font face="sans-serif"> outcount</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 
<font face="sans-serif"> MPI_TESTSOME</font> is a <em> local</em> procedure, which returns  
<em> immediately</em>, whereas  
<font face="sans-serif"> MPI_WAITSOME</font> will  
not return until  
a communication <em> completes</em>, if it was  
passed a list that contains at least one <em> active</em> handle.  Both calls fulfill a  
<b> fairness requirement</b>: If a request for a receive repeatedly  
appears in a list of requests passed to <font face="sans-serif"> MPI_WAITSOME</font> or  
<font face="sans-serif"> MPI_TESTSOME</font>, and a matching send has been <em> started</em>, then the receive  
will eventually succeed, unless the send is satisfied by another receive; and  
similarly for send requests.  
<P> 
Errors that occur during the execution of <font face="sans-serif"> MPI_TESTSOME</font> are  
handled as for <br><font face="sans-serif"> MPI_WAITSOME</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The use of <font face="sans-serif"> MPI_TESTSOME</font> is likely to be more efficient than the use  
of <font face="sans-serif"> MPI_TESTANY</font>. The former returns information on all  
<em> completed</em> communication operations, with the latter, a new call is required for  
each communication that completes.  
<P> 
A server with multiple clients can use <font face="sans-serif"> MPI_WAITSOME</font> so as not to  
starve any client.  Clients send messages to the server with service  
requests. The server calls <font face="sans-serif"> MPI_WAITSOME</font> with one receive request  
for each client, and then handles all receives that completed.  
If a call to <font face="sans-serif"> MPI_WAITANY</font> is used instead, then one client  
could starve while requests from another client always sneak in first.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
<font face="sans-serif"> MPI_TESTSOME</font> should <em> complete</em> as many  
<em> pending</em> communication operations of the <font face="sans-serif"> array_of_requests</font> as possible.  
 (<em> End of advice to implementors.</em>) <br> 
<br><b> Example</b>  
  
Client-server code (starvation can occur).  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>CALL</b> <b>MPI_COMM_SIZE</b>(comm, size, ierr) 
<b>CALL</b> <b>MPI_COMM_RANK</b>(comm, rank, ierr) 
<b>IF</b> (rank .GT. 0) <b>THEN</b>         ! client code 
   <b>DO</b> <b>WHILE</b>(.TRUE.) 
      <b>CALL</b> <b>MPI_ISEND</b>(a, n, <b>MPI_REAL</b>, 0, tag, comm, request, ierr) 
      <b>CALL</b> <b>MPI_WAIT</b>(request, status, ierr) 
   <b>END</b> <b>DO</b> 
<b>ELSE</b>         ! rank=0 -- server code 
   <b>DO</b> i=1,size-1 
      <b>CALL</b> <b>MPI_IRECV</b>(a(1,i), n, <b>MPI_REAL</b>, i, tag, &amp; 
                     comm, request_list(i), ierr) 
   <b>END</b> <b>DO</b> 
   <b>DO</b> <b>WHILE</b>(.TRUE.) 
      <b>CALL</b> <b>MPI_WAITANY</b>(size-1, request_list, index, status, ierr) 
      <b>CALL</b> DO_SERVICE(a(1,index))  ! handle one message 
      <b>CALL</b> <b>MPI_IRECV</b>(a(1, index), n, <b>MPI_REAL</b>, index, tag, &amp; 
                     comm, request_list(index), ierr) 
   <b>END</b> <b>DO</b> 
<b>END</b> <b>IF</b> 
</tt></pre> 
  
  
  
<P> 
<br><b> Example</b>  
  
Same code, using <font face="sans-serif"> MPI_WAITSOME</font>.  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>CALL</b> <b>MPI_COMM_SIZE</b>(comm, size, ierr) 
<b>CALL</b> <b>MPI_COMM_RANK</b>(comm, rank, ierr) 
<b>IF</b> (rank .GT. 0) <b>THEN</b>         ! client code 
   <b>DO</b> <b>WHILE</b>(.TRUE.) 
      <b>CALL</b> <b>MPI_ISEND</b>(a, n, <b>MPI_REAL</b>, 0, tag, comm, request, ierr) 
      <b>CALL</b> <b>MPI_WAIT</b>(request, status, ierr) 
   <b>END</b> <b>DO</b> 
<b>ELSE</b>         ! rank=0 -- server code 
   <b>DO</b> i=1,size-1 
      <b>CALL</b> <b>MPI_IRECV</b>(a(1,i), n, <b>MPI_REAL</b>, i, tag, &amp; 
                     comm, request_list(i), ierr) 
   <b>END</b> <b>DO</b> 
   <b>DO</b> <b>WHILE</b>(.TRUE.) 
      <b>CALL</b> <b>MPI_WAITSOME</b>(size, request_list, numdone, &amp; 
                        indices, statuses, ierr) 
      <b>DO</b> i=1,numdone 
         <b>CALL</b> DO_SERVICE(a(1, indices(i))) 
         <b>CALL</b> <b>MPI_IRECV</b>(a(1, indices(i)), n, <b>MPI_REAL</b>, 0, tag, &amp; 
                        comm, request_list(indices(i)), ierr) 
      <b>END</b> <b>DO</b> 
   <b>END</b> <b>DO</b> 
<b>END</b> <b>IF</b> 
</tt></pre> 
  
  
<P> 

<P>
<hr>
<a href="node77.htm#Node77"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node73.htm#Node73"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node79.htm#Node79"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node73.htm#Node73"> Nonblocking Communication</a>
<b>Next: </b><a href="node79.htm#Node79"> Non-Destructive Test of <font face="sans-serif"> status</font></a>
<b>Previous: </b><a href="node77.htm#Node77"> Semantics of Nonblocking Communication Operations</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
