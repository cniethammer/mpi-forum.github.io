<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Address and Size Procedures</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node103">6.1.5. Address and Size Procedures</span></h2>
<a href="node102.htm#Node102"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node104.htm#Node104"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node104.htm#Node104"> Lower-Bound and Upper-Bound Markers</a>
<b>Previous: </b><a href="node102.htm#Node102"> Distributed Array Datatype Constructor</a>
<p>
  
<P> 
The displacements in a general datatype are relative to some initial buffer  
address.  
<b> Absolute addresses</b>  
can be substituted for these  
displacements: we treat them as displacements relative to ``address  
zero,'' the start of the address space.  This initial address zero is  
indicated by the constant <font face="sans-serif"> MPI_BOTTOM</font>.  Thus, a datatype can  
specify the absolute address of the entries in the communication  
buffer, in which case the <font face="sans-serif"> buf</font> argument is passed the value  
<font face="sans-serif"> MPI_BOTTOM</font>.  
Note that in Fortran <font face="sans-serif"> MPI_BOTTOM</font> is not usable for initialization or  
assignment, see Section <a href="node38.htm#Node38">Named Constants</a>.  
<P> 
The address of a location in memory can be found by invoking the  
procedure  
<font face="sans-serif"> MPI_GET_ADDRESS</font>.  
The <b> relative displacement</b>  
between two absolute addresses  
can be calculated with the procedure <font face="sans-serif"> MPI_AINT_DIFF</font>. A new absolute  
address as sum of an absolute base address and a relative displacement can be  
calculated with the procedure <font face="sans-serif"> MPI_AINT_ADD</font>. To ensure portability,  
arithmetic on absolute addresses should not be performed with the intrinsic  
operators ``-'' and ``+''. See also Sections <a href="node40.htm#Node40">Absolute Addresses and Relative Address Displacements</a>  
and <a href="node110.htm#Node110">Correct Use of Addresses</a> on pages <a href="node40.htm#Node40">Absolute Addresses and Relative Address Displacements</a> and  
<a href="node110.htm#Node110">Correct Use of Addresses</a>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Address sized integer values, i.e., <font face="sans-serif"> MPI_Aint</font> or  
<font face="sans-serif"> INTEGER(KIND=MPI_ADDRESS_KIND)</font>  values, are signed integers, while  
absolute addresses are unsigned quantities. Direct arithmetic on addresses  
stored in address sized signed variables can cause overflows, resulting in  
undefined behavior.  
 (<em> End of rationale.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_GET_ADDRESS(<span style="white-space:nowrap">location</span>, <span style="white-space:nowrap">address</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> location</TD><TD>location in caller memory (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> address</TD><TD>address of location (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Get_address(const void *location, MPI_Aint *address) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Get_address(location, address, ierror) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">location</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: <span style="white-space:nowrap">address</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GET_ADDRESS(LOCATION, ADDRESS, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">LOCATION(*)</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ADDRESS</span><br>INTEGER <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Returns the (byte) address of <font face="sans-serif"> location</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
In the <tt>mpi_f08</tt> module, the <font face="sans-serif"> location</font> argument is not defined  
with <tt> INTENT(IN)</tt> because existing applications may use  
<font face="sans-serif"> MPI_GET_ADDRESS</font> as a  
substitute for <font face="sans-serif"> MPI_F_SYNC_REG</font>, which was not defined before <font face="sans-serif"> MPI-3.0</font>.  
 (<em> End of rationale.</em>) <br> 
<br><b> Example</b>  
  
Using <font face="sans-serif"> MPI_GET_ADDRESS</font> for an array.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>REAL</b> A(100,100) 
<b>INTEGER</b>(<b>KIND</b>=<b>MPI_ADDRESS_KIND</b>) I1, I2, DIFF 
<b>CALL</b> <b>MPI_GET_ADDRESS</b>(A(1,1), I1, IERROR) 
<b>CALL</b> <b>MPI_GET_ADDRESS</b>(A(10,10), I2, IERROR) 
DIFF = <b>MPI_AINT_DIFF</b>(I2, I1) 
! The value of DIFF is 909*SIZEOF(<b>REAL</b>); the values of I1 and I2 are 
! implementation dependent. 
</tt></pre> 
  
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
C users may be tempted to avoid the usage of  
<font face="sans-serif"> MPI_GET_ADDRESS</font>  
and rely on  
the availability of the address operator <tt>&amp;</tt>.  Note, however, that  
<tt>&amp;</tt> <em> cast-expression</em> is a pointer, not an  
address.  
ISO C  
does not require that the value of a pointer  
(or the pointer cast to <tt> int</tt>) be  
the absolute address of the object pointed at---although this is  
commonly the case.  
Furthermore, referencing may not have a unique  
definition on machines with a segmented address space.  
The use of  
<font face="sans-serif"> MPI_GET_ADDRESS</font>  
to ``reference'' C  
variables guarantees portability to such machines as well.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in  
Sections <a href="node479.htm#Node479">Problems With Fortran Bindings for <font face="sans-serif"> MPI</font></a>--<a href="node500.htm#Node500">Comparison with C</a>.  
 (<em> End of advice to users.</em>) <br> 
To ensure portability, arithmetic on <font face="sans-serif"> MPI</font> addresses must be  
performed using the <font face="sans-serif"> MPI_AINT_ADD</font>  
and <font face="sans-serif"> MPI_AINT_DIFF</font> procedures.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_AINT_ADD(<span style="white-space:nowrap">base</span>, <span style="white-space:nowrap">disp</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> base</TD><TD>base address (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> disp</TD><TD>displacement (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> MPI_Aint MPI_Aint_add(MPI_Aint base, MPI_Aint disp) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_Aint_add(base, disp) <br> <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">base</span>, <span style="white-space:nowrap">disp</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_AINT_ADD(BASE, DISP) <br> <br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">BASE</span>, <span style="white-space:nowrap">DISP</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_AINT_ADD</font> produces a new <font face="sans-serif"> MPI_Aint</font> value that is  
equivalent to the sum of the <font face="sans-serif"> base</font> and <font face="sans-serif"> disp</font> arguments, where  
<font face="sans-serif"> base</font> represents a base address returned by a call to  
<font face="sans-serif"> MPI_GET_ADDRESS</font> and <font face="sans-serif"> disp</font> represents a signed integer  
displacement. The resulting address is valid only at the process that generated  
<font face="sans-serif"> base</font>, and it must correspond to a location in the same object  
referenced by <font face="sans-serif"> base</font>, as described in  
Section <a href="node110.htm#Node110">Correct Use of Addresses</a>. The addition is performed in a manner  
that results in the correct <font face="sans-serif"> MPI_Aint</font> representation of the output  
address, as if the process that originally produced <font face="sans-serif"> base</font> had called:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>MPI_Get_address</b>((<b>char</b> *) base + disp, &amp;result); 
</tt></pre> 
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_AINT_DIFF(<span style="white-space:nowrap">addr1</span>, <span style="white-space:nowrap">addr2</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> addr1</TD><TD>minuend address (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> addr2</TD><TD>subtrahend address (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> MPI_Aint MPI_Aint_diff(MPI_Aint addr1, MPI_Aint addr2) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_Aint_diff(addr1, addr2) <br> <br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">addr1</span>, <span style="white-space:nowrap">addr2</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> INTEGER(KIND=MPI_ADDRESS_KIND) MPI_AINT_DIFF(ADDR1, ADDR2) <br> <br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ADDR1</span>, <span style="white-space:nowrap">ADDR2</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_AINT_DIFF</font> produces a new <font face="sans-serif"> MPI_Aint</font> value that is  
equivalent to the difference between <font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font>  
arguments, where <font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font> represent addresses returned  
by calls to <font face="sans-serif"> MPI_GET_ADDRESS</font>.  The resulting address is valid only  
at the process that generated <font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font>, and  
<font face="sans-serif"> addr1</font> and <font face="sans-serif"> addr2</font> must correspond to locations in the same  
object in the same process, as described in  
Section <a href="node110.htm#Node110">Correct Use of Addresses</a>. The difference is calculated in a manner  
that results in  
the signed difference from <font face="sans-serif"> addr1</font> to <font face="sans-serif"> addr2</font>, as if  
the process that originally produced the addresses had called  
<tt>(char *) addr1 - (char *) addr2</tt>  
on the addresses initially passed to <font face="sans-serif"> MPI_GET_ADDRESS</font>.  
<P> 
The following auxiliary procedures provide useful information on  
derived datatypes.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_SIZE(<span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">size</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype to get information on (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> size</TD><TD>datatype size (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_size(MPI_Datatype datatype, int *size) <br></tt>  
  
  <tt> int MPI_Type_size_c(MPI_Datatype datatype, MPI_Count *size) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_size(datatype, size, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_size(datatype, size, ierror) !(_c) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">size</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_SIZE(DATATYPE, SIZE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_TYPE_SIZE</font>  
set the value of <font face="sans-serif"> size</font> to the total size, in bytes, of the entries in  
the type signature  
associated with <font face="sans-serif"> datatype</font>; i.e., the total size of  
the data in a message that would be created with this datatype.  Entries that  
occur multiple times in the datatype are counted with their multiplicity.  
For both procedures, if the <span style="font-size:0.900em;"> OUT</span> parameter cannot express the value to  
be returned (e.g., if the parameter is too small to hold the output  
value), it is set to <font face="sans-serif"> MPI_UNDEFINED</font>.  
<P> 

<P>
<hr>
<a href="node102.htm#Node102"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node104.htm#Node104"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node104.htm#Node104"> Lower-Bound and Upper-Bound Markers</a>
<b>Previous: </b><a href="node102.htm#Node102"> Distributed Array Datatype Constructor</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
