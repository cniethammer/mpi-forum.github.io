<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>General Active Target Synchronization</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node331">13.5.2. General Active Target Synchronization</span></h2>
<a href="node330.htm#Node330"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node329.htm#Node329"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node332.htm#Node332"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node329.htm#Node329"> Synchronization Calls</a>
<b>Next: </b><a href="node332.htm#Node332"> Lock</a>
<b>Previous: </b><a href="node330.htm#Node330"> Fence</a>
<p>
  
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_START(<span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">assert</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group</TD><TD>group of target processes (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_start(MPI_Group group, int assert, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_start(group, assert, win, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">assert</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_START(GROUP, ASSERT, WIN, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">ASSERT</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Opens an <font face="sans-serif"> RMA</font> access epoch for <font face="sans-serif"> win</font>.  <font face="sans-serif"> RMA</font> calls issued on  
<font face="sans-serif"> win</font> during this epoch must access only windows at  
<font face="sans-serif"> MPI</font> processes in <font face="sans-serif"> group</font>.  
Each <font face="sans-serif"> MPI</font> process in <font face="sans-serif"> group</font> must issue a matching call to   
<font face="sans-serif"> MPI_WIN_POST</font>.  
<font face="sans-serif"> RMA</font> accesses to each target  
window will be delayed, if necessary,  
until the target process executed the matching call to   
<font face="sans-serif"> MPI_WIN_POST</font>.  
<font face="sans-serif"> MPI_WIN_START</font> is allowed to delay its return until the corresponding calls to  
<font face="sans-serif"> MPI_WIN_POST</font> have occurred, but is not required to.  
<P> 
The <font face="sans-serif"> assert</font> argument is used to provide assertions on the  
context of the call that may be used for various optimizations.  This  
is described in  
Section <a href="node334.htm#Node334">Assertions</a>.  A value of <font face="sans-serif"> assert</font><font face="sans-serif">  = 0</font> is  
always valid.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_COMPLETE(<span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_complete(MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_complete(win, ierror) <br> TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_COMPLETE(WIN, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Closes an <font face="sans-serif"> RMA</font> access epoch on <font face="sans-serif"> win</font> opened by a  
call to <font face="sans-serif"> MPI_WIN_START</font>.  All <font face="sans-serif"> RMA</font> communication  
operations initiated on <font face="sans-serif"> win</font> during this epoch will have completed at  
the origin when the call returns.  
All updates to shared memory in <font face="sans-serif"> win</font> through load/store accesses executed during this epoch will be visible  
at the target when the call returns.  
<P> 
<font face="sans-serif"> MPI_WIN_COMPLETE</font> enforces completion of preceding <font face="sans-serif"> RMA</font>  
operations and visibility of load/store accesses at the origin, but not at the target.  
A put or accumulate operation may not have completed  
at the target when it has completed at the origin.  
<P> 
Consider the sequence of calls in the example below.  
<br><b> Example</b>  
  
[<font face="sans-serif"> RMA</font> Start and complete]CRMA Start and complete@<font face="sans-serif"> RMA</font> Start and completeMPI_Win_start,MPI_Put,MPI_Win_completeUse of <font face="sans-serif"> MPI_WIN_START</font> and <font face="sans-serif"> MPI_WIN_COMPLETE</font>.  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>MPI_Win_start</b>(group, flag, win); 
<b>MPI_Put</b>(..., win); 
<b>MPI_Win_complete</b>(win); 
</tt></pre> 
  
<P> 
The call to <font face="sans-serif"> MPI_WIN_COMPLETE</font> does not return until the  
put operation has completed at the origin; and  
the target window will be accessed by the put operation only after the  
call to <font face="sans-serif"> MPI_WIN_START</font> has matched a call to  
<font face="sans-serif"> MPI_WIN_POST</font> by the target process.  
  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The semantics described above still leave  
much choice to implementors. The return from the call to  
<font face="sans-serif"> MPI_WIN_START</font> can block until the matching call to  
<font face="sans-serif"> MPI_WIN_POST</font> occurs at all target processes.  One can also  
have implementations where the call to <font face="sans-serif"> MPI_WIN_START</font> returns immediately, but the  
call to <font face="sans-serif"> MPI_WIN_COMPLETE</font> delays its return until the call to  
<font face="sans-serif"> MPI_WIN_POST</font> occurred; or implementations where all  
three calls can complete before any target process  
has called   
<font face="sans-serif"> MPI_WIN_POST</font>---the  
data put must be buffered, in this last case, so as to allow the  
put to complete at the origin ahead of its completion at the   
target.  
However, once the  
call to <font face="sans-serif"> MPI_WIN_POST</font> is issued, the sequence above  
must complete, without further dependencies.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
In order to ensure a portable deadlock free program, users must assume that  
<font face="sans-serif"> MPI_WIN_START</font> may delay its return until the corresponding call  
to <font face="sans-serif"> MPI_WIN_POST</font> has occurred.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_POST(<span style="white-space:nowrap">group</span>, <span style="white-space:nowrap">assert</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> group</TD><TD>group of origin processes (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> assert</TD><TD>program assertion (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_post(MPI_Group group, int assert, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_post(group, assert, win, ierror) <br> TYPE(MPI_Group), INTENT(IN) :: <span style="white-space:nowrap">group</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">assert</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_POST(GROUP, ASSERT, WIN, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">GROUP</span>, <span style="white-space:nowrap">ASSERT</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Opens an <font face="sans-serif"> RMA</font> exposure epoch for the  
local window associated with <font face="sans-serif"> win</font>.  Only <font face="sans-serif"> MPI</font> processes in  
<font face="sans-serif"> group</font> may access the window with <font face="sans-serif"> RMA</font> calls on  
<font face="sans-serif"> win</font> during  this   
epoch.  
Each <font face="sans-serif"> MPI</font> process in <font face="sans-serif"> group</font> must issue a matching call to   
<font face="sans-serif"> MPI_WIN_START</font>.  
<font face="sans-serif"> MPI_WIN_POST</font> is a <em> local</em> procedure.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_WAIT(<span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_wait(MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_wait(win, ierror) <br> TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_WAIT(WIN, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Closes an <font face="sans-serif"> RMA</font> exposure epoch opened by a call to  
<font face="sans-serif"> MPI_WIN_POST</font> on   
<font face="sans-serif"> win</font>.  
This call matches calls to <font face="sans-serif"> MPI_WIN_COMPLETE</font> on <font face="sans-serif"> win</font>  
issued  
by each of the origin processes that were granted access to the window  
during this epoch.  
The call to <font face="sans-serif"> MPI_WIN_WAIT</font> will  
return only after all matching calls to <font face="sans-serif"> MPI_WIN_COMPLETE</font>  
have occurred.  
This guarantees that all these origin processes have completed their  
<font face="sans-serif"> RMA</font> operations and shared-memory load/store accesses have become visible on the local  
window.  
When the call returns, all these <font face="sans-serif"> RMA</font> accesses will  
have completed at the target window.  
<P> 
Figure <a href="node331.htm#Figure31">31</a> illustrates the use of these four  
functions.  
<div style="text-align:center"><P><img width=1073 height=572 src="2party.gif" alt="Image file"><P>
</div>  
<br> 
<b>Figure 31: </b><span id="Figure31">Active target communication, with strong synchronization.  Dashed arrows represent 
synchronizations and solid arrows represent data transfer.</span><P> 
  
  
Process 0 puts data in the windows of processes 1 and 2 and process 3  
puts data in the window of process 2.  Each start call lists the ranks  
of the <font face="sans-serif"> MPI</font> processes whose windows will be accessed;  
each post call lists the ranks of the  
<font face="sans-serif"> MPI</font> processes that access the local window.  The figure illustrates a  
possible timing for the events, assuming strong synchronization; in a   
weak synchronization, the start, put or complete calls  
may occur ahead of the matching post calls.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_WIN_TEST(<span style="white-space:nowrap">win</span>, <span style="white-space:nowrap">flag</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> flag</TD><TD>success flag (logical)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Win_test(MPI_Win win, int *flag) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Win_test(win, flag, ierror) <br> TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">flag</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WIN_TEST(WIN, FLAG, IERROR) <br> INTEGER <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_WIN_TEST</font> is a local procedure.  
Repeated calls to <font face="sans-serif"> MPI_WIN_TEST</font> with the same <font face="sans-serif"> win</font> argument  
will eventually return <font face="sans-serif"> flag</font><tt> = true</tt> once all accesses to the  
local window by the group to which it was exposed by the corresponding call to  
<font face="sans-serif"> MPI_WIN_POST</font> have been completed as indicated by matching  
<font face="sans-serif"> MPI_WIN_COMPLETE</font> calls, and <font face="sans-serif"> flag</font><tt> = false</tt> otherwise.  
In the former case <font face="sans-serif"> MPI_WIN_WAIT</font>  
would have returned immediately.  
The effect of return of <font face="sans-serif"> MPI_WIN_TEST</font> with  
<font face="sans-serif"> flag</font><font face="sans-serif">  = true</font> is the same as the effect of a return   
of <font face="sans-serif"> MPI_WIN_WAIT</font>.  If <font face="sans-serif"> flag</font><font face="sans-serif">  = false</font> is returned,  
then the call has no visible effect.  
<P> 
<font face="sans-serif"> MPI_WIN_TEST</font> should be called only where  
<font face="sans-serif"> MPI_WIN_WAIT</font>  
can be called.  
Once the call has returned <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font>, it must not be  
called again, until the window is posted again.  
<P> 
Assume that window <font face="sans-serif"> win</font> is associated with a ``hidden''   
communicator <font face="sans-serif"> wincomm</font>, used for communication by the <font face="sans-serif"> MPI</font> processes  
in the group of <font face="sans-serif"> win</font>.  The rules for matching of post and start calls and  
for matching complete and wait calls can be  
derived from the rules for   
matching sends and receives, by considering the following (partial) model  
implementation.   
<P> 
<dl> 
 
<dt> 
<b><font face="sans-serif"> MPI_WIN_POST</font><font face="sans-serif"> (group,0,win)</font></b><dd> 
  
initiates a nonblocking send with tag <font face="sans-serif"> tag0</font> to each  
<font face="sans-serif"> MPI</font> process in <font face="sans-serif"> group</font>, using <font face="sans-serif"> wincomm</font>.  
 
<dt> 
<b><font face="sans-serif"> MPI_WIN_START</font><font face="sans-serif"> (group,0,win)</font></b><dd> 
  
initiates a nonblocking receive with tag <font face="sans-serif"> tag0</font> from each <font face="sans-serif"> MPI</font>  
process in <font face="sans-serif"> group</font>, using <font face="sans-serif"> wincomm</font>.  An <font face="sans-serif"> RMA</font> access to  
a target process is delayed until the receive  
from that <font face="sans-serif"> MPI</font> process is completed.  
 
<dt> 
<b><font face="sans-serif"> MPI_WIN_COMPLETE</font><font face="sans-serif"> (win)</font></b><dd> 
  
initiates a nonblocking send with tag <font face="sans-serif"> tag1</font> to each <font face="sans-serif"> MPI</font> process in  
the group of the preceding start call.  
 
<dt> 
<b><font face="sans-serif"> MPI_WIN_WAIT</font><font face="sans-serif"> (win)</font></b><dd> 
  
initiates a nonblocking receive with tag <font face="sans-serif"> tag1</font> from each  
<font face="sans-serif"> MPI</font> process in the group of the preceding post call.  Wait for the  
completion of all receives.   
</dl> 
<br> 
No races can occur in a correct program: each of the sends matches a  
unique receive, and vice versa.   
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The design for general active target synchronization requires the  
user to provide complete information on the communication pattern, at  
each end of a communication link: each origin specifies a list of  
targets, and each target specifies a list of origins.  This provides  
maximum flexibility (hence, efficiency) for the implementor:   
each  
synchronization can be initiated by either side, since each ``knows''  
the identity of the other.  This also provides maximum protection from  
possible races.  On the other hand, the design requires more  
information than <font face="sans-serif"> RMA</font> needs: in general, it is sufficient  
for the origin to know the rank of the target, but not vice  
versa.  
Users that want more ``anonymous'' communication will be required to  
use the fence or lock mechanisms.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Assume a communication pattern that is represented by a directed graph  
<i>G = &langle; V, E&rangle;</i>, where <i>V = {0, ..., n-1}</i> and <i>ij &isin; E</i> if origin process  
<i>i</i> accesses the window at target process <i>j</i>.  Then each <font face="sans-serif"> MPI</font> process <i>i</i>  
issues a call to   
<font face="sans-serif"> MPI_WIN_POST</font><font face="sans-serif"> (<i>ingroup<SUB>i</SUB></i>, ...)</font>,   
followed by a call to  
<font face="sans-serif"> MPI_WIN_START</font><font face="sans-serif"> (<i>outgroup<SUB>i</SUB></i>,...)</font>,  
where   
<i>outgroup<SUB>i</SUB> = { j  :  ij &isin; E}</i> and <i>ingroup<SUB>i</SUB> = { j  :  ji &isin; E 
}</i>.  A call is a no-op, and can be skipped, if the <font face="sans-serif"> group</font> argument is  
empty. After the communications calls, each <font face="sans-serif"> MPI</font> process that issued  
a start will issue a complete.  Finally, each <font face="sans-serif"> MPI</font> process that  
issued  a post will issue a wait.   
<P> 
Note that each <font face="sans-serif"> MPI</font> process may call with a <font face="sans-serif"> group</font> argument that has  
different members.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node330.htm#Node330"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node329.htm#Node329"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node332.htm#Node332"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node329.htm#Node329"> Synchronization Calls</a>
<b>Next: </b><a href="node332.htm#Node332"> Lock</a>
<b>Previous: </b><a href="node330.htm#Node330"> Fence</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
