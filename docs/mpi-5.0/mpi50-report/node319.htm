<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Put</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node319">13.3.1. Put</span></h2>
<a href="node318.htm#Node318"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node318.htm#Node318"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node320.htm#Node320"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node318.htm#Node318"> Communication Calls</a>
<b>Next: </b><a href="node320.htm#Node320"> Get</a>
<b>Previous: </b><a href="node318.htm#Node318"> Communication Calls</a>
<p>
  
The execution of a put operation is similar to the execution of a  
send by the origin process and a matching receive by the target process.  
The obvious difference is that all arguments are provided by one  
call---the call executed by the origin process.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_PUT(<span style="white-space:nowrap">origin_addr</span>, <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_disp</span>, <span style="white-space:nowrap">target_count</span>, <span style="white-space:nowrap">target_datatype</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_addr</TD><TD>initial address of origin buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_count</TD><TD>number of entries in origin buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_datatype</TD><TD>datatype of each entry in origin buffer (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_rank</TD><TD>rank of target (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_disp</TD><TD>displacement from start of window to target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_count</TD><TD>number of entries in target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_datatype</TD><TD>datatype of each entry in target buffer (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window used for communication (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Put(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Win win) <br></tt>  
  
  <tt> int MPI_Put_c(const void *origin_addr, MPI_Count origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, MPI_Count target_count, MPI_Datatype target_datatype, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Put(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">target_datatype</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Put(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, win, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">target_count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">target_datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">target_rank</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_PUT(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, WIN, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">ORIGIN_ADDR(*)</span><br>INTEGER <span style="white-space:nowrap">ORIGIN_COUNT</span>, <span style="white-space:nowrap">ORIGIN_DATATYPE</span>, <span style="white-space:nowrap">TARGET_RANK</span>, <span style="white-space:nowrap">TARGET_COUNT</span>, <span style="white-space:nowrap">TARGET_DATATYPE</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">TARGET_DISP</span> <br></tt>  
<P> 
Transfers <font face="sans-serif"> origin_count</font>  
successive entries of the type specified by the  
<font face="sans-serif"> origin_datatype</font>, starting at address <font face="sans-serif"> origin_addr</font>  
on the origin process, to the target process  
specified by the <font face="sans-serif"> win</font>, <font face="sans-serif"> target_rank</font> pair.   
The data are written in  
the target buffer at address  
<i><span style="font-family:sans-serif;"> target_addr</span> = <span style="font-family:sans-serif;"> window_base</span> +  
<span style="font-family:sans-serif;"> target_disp</span>&times;<span style="font-family:sans-serif;"> disp_unit</span></i>, where  
<font face="sans-serif"> window_base</font> and   
<font face="sans-serif"> disp_unit</font>  
are the base address and window displacement unit  
specified at window initialization, by the target process.  
<P> 
The target buffer is specified by the arguments  
<font face="sans-serif"> target_count</font>  
and <font face="sans-serif"> target_datatype</font>.  
<P> 
The data transfer is the same as that which would occur  
if the origin process executed a send  
operation  
with arguments <font face="sans-serif"> origin_addr</font>, <font face="sans-serif"> origin_count</font>,   
<font face="sans-serif"> origin_datatype</font>,  
<font face="sans-serif"> target_rank</font>, <font face="sans-serif"> tag</font>, <font face="sans-serif"> comm</font>, and the target  
process executed a   
receive operation with arguments  
<font face="sans-serif"> target_addr,  
target_count, target_datatype, source, tag, comm</font>, where  
<font face="sans-serif"> target_addr</font> is the target buffer address computed as  
explained above, the values of <font face="sans-serif"> tag</font> are arbitrary valid  
matching tag values, and <font face="sans-serif"> comm</font> is a communicator for the group of <font face="sans-serif"> win</font>.  
<P> 
The communication must satisfy the same constraints as for a similar message-passing communication.  The <font face="sans-serif"> target_datatype</font> may not specify overlapping entries in the target buffer.  
The message sent must fit, without truncation, in the target buffer.  
Furthermore, the target buffer  
must fit in the target window or in attached memory in a  
dynamic window.  
<P> 
The <font face="sans-serif"> target_datatype</font> argument  
is a handle to a datatype object defined at the origin process.  
However, this object is interpreted at the target process: the outcome  
is as if the target datatype object was defined at the target process  
by the same sequence of calls used to define it at the origin process.  
The target datatype must   
contain only relative displacements, not absolute addresses.  
The same  
holds for get and accumulate  
operations.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> target_datatype</font> argument is a handle to a datatype  
object  
that is defined at the origin process, even though it defines a data  
layout in  
the target process memory.  This causes no problems in a homogeneous  
environment, or in a heterogeneous environment if only portable  
datatypes are used (portable datatypes are defined in  
Section <a href="node30.htm#Node30">Semantic Terms</a>).  
<P> 
The performance of a put transfer can be significantly affected, on  
some systems,  
by the choice of window location and the shape and location  
of the origin and target buffer: transfers to a target window in memory  
allocated by <font face="sans-serif"> MPI_ALLOC_MEM</font> or <font face="sans-serif"> MPI_WIN_ALLOCATE</font> may be much faster on shared  
memory systems;  
transfers from contiguous buffers will be  
faster on most, if not all, systems;  the alignment of the  
communication buffers may also impact performance.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
A high-quality   
implementation will attempt to  
prevent remote accesses to memory outside the  
window that was exposed by the <font face="sans-serif"> MPI</font> process.  
This is important both for debugging  
purposes and for protection with client-server codes that use <font face="sans-serif"> RMA</font>.  
That is,  
a high-quality implementation will check, if possible,  
window bounds on each <font face="sans-serif"> RMA</font> call,  
and raise an error at the origin call if an out-of-bound  
situation occurs.  
Note that the condition can be checked at the origin.  
Of course, the added safety achieved by such checks has to be weighed  
against the added cost of such checks.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node318.htm#Node318"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node318.htm#Node318"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node320.htm#Node320"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node318.htm#Node318"> Communication Calls</a>
<b>Next: </b><a href="node320.htm#Node320"> Get</a>
<b>Previous: </b><a href="node318.htm#Node318"> Communication Calls</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
