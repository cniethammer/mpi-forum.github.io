<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-io/io-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Examples</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node395">15.6.11. Examples</span></h2>
<a href="node394.htm#Node394"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node395.htm#Node396"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Consistency and Semantics</a>
<b>Next: </b><a href="node395.htm#Node396"> Asynchronous I/O</a>
<b>Previous: </b><a href="node394.htm#Node394"> File Size</a>
<p>
  
<P> 
The examples in this section illustrate  
the application of the <font face="sans-serif"> MPI</font> consistency and semantics guarantees.  
These address  
<ul> 
 
<li>conflicting accesses on file handles obtained from a   
single collective open, and  
 
<li>all accesses on file handles obtained from two separate  
collective opens.  
</ul> 
<br> 
The simplest way to achieve consistency for conflicting accesses is  
to obtain sequential consistency by setting atomic mode.  
<br><b> Example</b>  
  
  
For the code below,  
process 1 will read either 0 or 10 integers.  
If the latter, every element of <tt>b</tt> will be <tt>5</tt>.  
If nonatomic mode is set, the results of the read are undefined.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>/* Process 0 */ 
 
<b>int</b>  i, a[10]; 
<b>int</b>  TRUE = 1; 
 
<b>for</b> (i=0;i&lt;10;i++) 
   a[i] = 5; 
 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "workfile", 
              <b>MPI_MODE_RDWR</b> | <b>MPI_MODE_CREATE</b>, <b>MPI_INFO_NULL</b>, &amp;fh0); 
<b>MPI_File_set_view</b>(fh0, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_File_set_atomicity</b>(fh0, TRUE); 
<b>MPI_File_write_at</b>(fh0, 0, a, 10, <b>MPI_INT</b>, &amp;status); 
/* <b>MPI_Barrier</b>(<b>MPI_COMM_WORLD</b>); */ 
</tt></pre> 
  
<br> 
<pre style="background-color:#EFEFEF"><tt>/* Process 1 */ 
 
<b>int</b>  b[10]; 
<b>int</b>  TRUE = 1; 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "workfile", 
              <b>MPI_MODE_RDWR</b> | <b>MPI_MODE_CREATE</b>, <b>MPI_INFO_NULL</b>, &amp;fh1); 
<b>MPI_File_set_view</b>(fh1, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_File_set_atomicity</b>(fh1, TRUE); 
/* <b>MPI_Barrier</b>(<b>MPI_COMM_WORLD</b>); */ 
<b>MPI_File_read_at</b>(fh1, 0, b, 10, <b>MPI_INT</b>, &amp;status); 
</tt></pre> 
  
A user may guarantee that the write on process <font face="sans-serif"> 0</font>  
precedes the read on process <font face="sans-serif"> 1</font> by imposing temporal order  
with, for example, calls to <font face="sans-serif"> MPI_BARRIER</font>.  
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Routines other than <font face="sans-serif"> MPI_BARRIER</font> may be used to impose   
temporal order.  In the example above, process 0 could use <font face="sans-serif"> MPI_SEND</font>  
to send a 0 byte message, received by process 1 using <font face="sans-serif"> MPI_RECV</font>.  
 (<em> End of advice to users.</em>) <br> 
<br><b> Example</b>  
  
  
Alternatively, a user can impose consistency with nonatomic mode set:  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>/* Process 0 */ 
<b>int</b>  i, a[10]; 
<b>for</b> (i=0;i&lt;10;i++) 
   a[i] = 5; 
 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "workfile", 
              <b>MPI_MODE_RDWR</b> | <b>MPI_MODE_CREATE</b>, <b>MPI_INFO_NULL</b>, &amp;fh0); 
<b>MPI_File_set_view</b>(fh0, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_File_write_at</b>(fh0, 0, a, 10, <b>MPI_INT</b>, &amp;status ); 
<b>MPI_File_sync</b>(fh0); 
<b>MPI_Barrier</b>(<b>MPI_COMM_WORLD</b>); 
<b>MPI_File_sync</b>(fh0); 
</tt></pre> 
  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>/* Process 1 */ 
 
<b>int</b>  b[10]; 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "workfile", 
              <b>MPI_MODE_RDWR</b> | <b>MPI_MODE_CREATE</b>, <b>MPI_INFO_NULL</b>, &amp;fh1); 
<b>MPI_File_set_view</b>(fh1, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_File_sync</b>(fh1); 
<b>MPI_Barrier</b>(<b>MPI_COMM_WORLD</b>); 
<b>MPI_File_sync</b>(fh1); 
<b>MPI_File_read_at</b>(fh1, 0, b, 10, <b>MPI_INT</b>, &amp;status); 
</tt></pre> 
  
<P> 
The ``sync-barrier-sync'' construct is required because:  
<ul> 
 
<li>The barrier ensures that the write on process 0 occurs  
before the read on process 1.  
 
<li>The first sync guarantees that the data written by all  
processes is transferred to the storage device.    
 
<li>The second sync guarantees that all data that has been  
transferred to the storage device is visible to all processes.  
(This does not affect process 0 in this example.)  
</ul> 
<br> 
  
<P> 
<br><b> Example</b>  
  
  
The following program represents an erroneous attempt to achieve consistency  
by eliminating the apparently superfluous second ``sync'' call for  
each process.  
<br> 
<pre style="background-color:#EFEFEF"><tt>/* ---------------- THIS EXAMPLE IS ERRONEOUS --------------- */ 
/* Process 0 */ 
 
<b>int</b>  i, a[10]; 
<b>for</b> (i=0;i&lt;10;i++) 
   a[i] = 5; 
 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "workfile", 
              <b>MPI_MODE_RDWR</b> | <b>MPI_MODE_CREATE</b>, <b>MPI_INFO_NULL</b>, &amp;fh0); 
<b>MPI_File_set_view</b>(fh0, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_File_write_at</b>(fh0, 0, a, 10, <b>MPI_INT</b>, &amp;status); 
<b>MPI_File_sync</b>(fh0); 
<b>MPI_Barrier</b>(<b>MPI_COMM_WORLD</b>); 
</tt></pre> 
  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>/* Process 1 */ 
 
<b>int</b>  b[10]; 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "workfile", 
              <b>MPI_MODE_RDWR</b> | <b>MPI_MODE_CREATE</b>, <b>MPI_INFO_NULL</b>, &amp;fh1); 
<b>MPI_File_set_view</b>(fh1, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_Barrier</b>(<b>MPI_COMM_WORLD</b>); 
<b>MPI_File_sync</b>(fh1); 
<b>MPI_File_read_at</b>(fh1, 0, b, 10, <b>MPI_INT</b>, &amp;status); 
 
/* ---------------- THIS EXAMPLE IS ERRONEOUS --------------- */ 
</tt></pre> 
  
The above program also violates the <font face="sans-serif"> MPI</font> rule  
against out-of-order collective operations  
and  
will deadlock for implementations in which <font face="sans-serif"> MPI_FILE_SYNC</font> blocks.  
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Some implementations may choose to implement <font face="sans-serif"> MPI_FILE_SYNC</font>  
as a temporally synchronizing function.  When using such an  
implementation, the ``sync-barrier-sync'' construct above can  
be replaced by a single ``sync.''  The results of using such  
code with an implementation for which <font face="sans-serif"> MPI_FILE_SYNC</font> is not  
temporally synchronizing is undefined.  
 (<em> End of advice to users.</em>) <br> 
<ul> 
</ul> 

<P>
<hr>
<a href="node394.htm#Node394"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node395.htm#Node396"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Consistency and Semantics</a>
<b>Next: </b><a href="node395.htm#Node396"> Asynchronous I/O</a>
<b>Previous: </b><a href="node394.htm#Node394"> File Size</a>
<p>
<hr><h3><span id="Node396">15.6.11.1. Asynchronous I/O</span></h3>
<a href="node395.htm#Node395"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node395.htm#Node395"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node397.htm#Node397"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node395.htm#Node395"> Examples</a>
<b>Next: </b><a href="node397.htm#Node397"> I/O Error Handling</a>
<b>Previous: </b><a href="node395.htm#Node395"> Examples</a>
<p>
The behavior of asynchronous I/O operations is determined by  
applying the rules specified above for synchronous I/O operations.  
<P> 
<br><b> Example</b>  
  
  
The following examples all access a pre-existing file ``<tt>myfile</tt>.''  
Word <font face="sans-serif"> 10</font> in myfile initially contains the integer <font face="sans-serif"> 2</font>.  
Each example writes and reads word <font face="sans-serif"> 10</font>.  
<P> 
First consider the following code fragment:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>int</b> a = 4, b, TRUE=1; 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "myfile", 
              <b>MPI_MODE_RDWR</b>, <b>MPI_INFO_NULL</b>, &amp;fh); 
<b>MPI_File_set_view</b>(fh, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
/* <b>MPI_File_set_atomicity</b>(fh, TRUE);   Use this to set atomic mode. */ 
<b>MPI_File_iwrite_at</b>(fh, 10, &amp;a, 1, <b>MPI_INT</b>, &amp;reqs[0]); 
<b>MPI_File_iread_at</b>(fh,  10, &amp;b, 1, <b>MPI_INT</b>, &amp;reqs[1]); 
<b>MPI_Waitall</b>(2, reqs, statuses); 
</tt></pre> 
  
For asynchronous data access operations, <font face="sans-serif"> MPI</font> specifies   
that the access occurs at any time between the call to the asynchronous   
data access routine and the return from the corresponding   
request complete routine.  
Thus, executing either the read before the write,  
or the write before the read is consistent with program order.  
If atomic mode is set, then <font face="sans-serif"> MPI</font> guarantees sequential   
consistency, and the program will read either <tt>2</tt> or  
<tt>4</tt> into <tt>b</tt>.  
If atomic mode is not set, then sequential consistency is not   
guaranteed and the program may read something other than <tt>2</tt>  
or <tt>4</tt> due to the conflicting data access.  
<P> 
Similarly, the following code fragment does not order file accesses:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>int</b> a = 4, b; 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "myfile", 
              <b>MPI_MODE_RDWR</b>, <b>MPI_INFO_NULL</b>, &amp;fh); 
<b>MPI_File_set_view</b>(fh, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
/* <b>MPI_File_set_atomicity</b>(fh, TRUE);   Use this to set atomic mode. */ 
<b>MPI_File_iwrite_at</b>(fh, 10, &amp;a, 1, <b>MPI_INT</b>, &amp;reqs[0]); 
<b>MPI_File_iread_at</b>(fh,  10, &amp;b, 1, <b>MPI_INT</b>, &amp;reqs[1]); 
<b>MPI_Wait</b>(&amp;reqs[0], &amp;status); 
<b>MPI_Wait</b>(&amp;reqs[1], &amp;status); 
</tt></pre> 
  
If atomic mode is set, either <tt>2</tt> or <tt>4</tt> will be read  
into <tt>b</tt>.  Again, <font face="sans-serif"> MPI</font> does not guarantee sequential consistency  
in nonatomic mode.  
<P> 
On the other hand, the following code fragment:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>int</b> a = 4, b; 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "myfile", 
              <b>MPI_MODE_RDWR</b>, <b>MPI_INFO_NULL</b>, &amp;fh); 
<b>MPI_File_set_view</b>(fh, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_File_iwrite_at</b>(fh, 10, &amp;a, 1, <b>MPI_INT</b>, &amp;reqs[0]); 
<b>MPI_Wait</b>(&amp;reqs[0], &amp;status); 
<b>MPI_File_iread_at</b>(fh,  10, &amp;b, 1, <b>MPI_INT</b>, &amp;reqs[1]); 
<b>MPI_Wait</b>(&amp;reqs[1], &amp;status); 
</tt></pre> 
  
defines the same ordering as:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>int</b> a = 4, b; 
<b>MPI_File_open</b>(<b>MPI_COMM_WORLD</b>, "myfile", 
              <b>MPI_MODE_RDWR</b>, <b>MPI_INFO_NULL</b>, &amp;fh); 
<b>MPI_File_set_view</b>(fh, 0, <b>MPI_INT</b>, <b>MPI_INT</b>, "native", <b>MPI_INFO_NULL</b>); 
<b>MPI_File_write_at</b>(fh, 10, &amp;a, 1, <b>MPI_INT</b>, &amp;status ); 
<b>MPI_File_read_at</b>(fh,  10, &amp;b, 1, <b>MPI_INT</b>, &amp;status ); 
</tt></pre> 
  
Since  
<ul> 
 
<li>nonconcurrent operations on a single file handle are sequentially consistent, and  
 
<li>the program fragments specify an order for the operations,  
</ul> 
<br> 
<font face="sans-serif"> MPI</font> guarantees that both program fragments will read the value   
<tt>4</tt> into  
<tt>b</tt>.  There is no need to set atomic mode for this example.  
<P> 
Similar considerations apply to conflicting accesses of the form:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>MPI_File_iwrite_all</b>(fh,...); 
<b>MPI_File_iread_all</b>(fh,...); 
<b>MPI_Waitall</b>(...); 
</tt></pre> 
  
In addition, as mentioned in Section <a href="node389.htm#Node389">Nonblocking Collective File Operations</a>,  
nonblocking collective I/O  
operations have to be called in the same order on the file handle by all  
processes.  
<P> 
Similar considerations apply to conflicting accesses of the form:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>MPI_File_write_all_begin</b>(fh,...); 
<b>MPI_File_iread</b>(fh,...); 
<b>MPI_Wait</b>(...); 
<b>MPI_File_write_all_end</b>(fh,...); 
</tt></pre> 
  
<P> 
Recall that constraints governing consistency and semantics are not  
relevant to the following:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>MPI_File_write_all_begin</b>(fh,...); 
<b>MPI_File_read_all_begin</b>(fh,...); 
<b>MPI_File_read_all_end</b>(fh,...); 
<b>MPI_File_write_all_end</b>(fh,...); 
</tt></pre> 
  
since split collective operations on the same file handle may not overlap  
(see Section <a href="node376.htm#Node376">Split Collective Data Access Routines</a>).  
  
<P> 

<P>
<hr>
<a href="node395.htm#Node395"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node395.htm#Node395"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node397.htm#Node397"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node395.htm#Node395"> Examples</a>
<b>Next: </b><a href="node397.htm#Node397"> I/O Error Handling</a>
<b>Previous: </b><a href="node395.htm#Node395"> Examples</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
