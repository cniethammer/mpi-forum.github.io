<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Communication Modes</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node69">4.4. Communication Modes</span></h1>
<a href="node68.htm#Node68"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node55.htm#Node55"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node70.htm#Node70"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node55.htm#Node55"> Point-to-Point Communication</a>
<b>Next: </b><a href="node70.htm#Node70"> Semantics of Point-to-Point Communication</a>
<b>Previous: </b><a href="node68.htm#Node68"> Data Conversion</a>
<p>
  
  
  
  
<P> 
The send call described in Section <a href="node58.htm#Node58">Blocking Send</a>  
is <em> blocking</em>:  
it does not return until the <em> message data</em>  
and <em> envelope</em> have been safely stored away so that the sender is  
free to modify  
the send buffer.  
The message might be copied directly into the matching receive buffer,  
or it might be copied into a temporary system buffer.  
<P> 
Message buffering  
decouples the send and receive operations.  A blocking send can  
complete as soon  
as the message was buffered, even if no matching receive has been executed  
by the receiver.  On the other hand, message buffering can be expensive,  
as it entails additional memory-to-memory copying, and it requires the  
allocation of memory for buffering.  <font face="sans-serif"> MPI</font> offers the choice of  
several <b> communication modes</b> that allow one to control the choice of the  
communication protocol.  
<P> 
The send call described in Section <a href="node58.htm#Node58">Blocking Send</a>  
uses  
the <b> standard</b> communication mode.  In this mode,  
it is up to <font face="sans-serif"> MPI</font> to decide whether outgoing  
messages will be buffered.  <font face="sans-serif"> MPI</font> may  
buffer outgoing messages.  In such a case, the send call may complete  
before a matching receive is invoked.  On the other hand, buffer space may be  
unavailable, or <font face="sans-serif"> MPI</font> may choose not to buffer  
outgoing messages, for performance reasons. In this case,  
the send call will not complete until a matching receive has been <em> started</em>, and  
the data has been moved to the receiver.  
<P> 
Thus, a <em> standard mode send</em> can be <em> started</em> whether or not a  
matching receive has been <em> started</em>.  It may <em> complete</em> before a matching receive  
is <em> started</em>.  The  
standard mode send is <em> nonlocal</em>: successful completion of the send  
operation may depend on the occurrence of a matching receive.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The reluctance of <font face="sans-serif"> MPI</font> to mandate whether standard sends are buffering  
or not stems from the desire to achieve portable programs.  Since any  
system will run out of buffer resources as message sizes are increased,  
and some implementations may want to provide little buffering, <font face="sans-serif"> MPI</font>  
takes the position that correct (and therefore, portable) programs  
do not rely on system buffering in standard mode.  Buffering  
may improve the performance  
of a correct program, but it doesn't affect the result of the program.  
If the user wishes to guarantee a certain amount of buffering, the  
user-provided buffer system of Section <a href="node71.htm#Node71">Buffer Allocation and Usage</a> should be used,  
along with the buffered-mode send.  
 (<em> End of rationale.</em>) <br> 
There are three additional communication modes.  
<P> 
A <b> buffered</b> mode send operation can be started whether or not a  
matching receive has been <em> started</em>.  
It may complete before a matching receive is <em> started</em>.  However, unlike  
the standard send, this operation is <em> local</em>, and its  
completion does not depend on the occurrence of a matching receive.  Thus, if a  
send is executed and no matching receive is <em> started</em>, then <font face="sans-serif"> MPI</font> must buffer the  
outgoing message, so as to allow the send call to complete.  An error will  
occur if there is insufficient buffer space.  The amount of available buffer  
space is controlled by the user---see Section <a href="node71.htm#Node71">Buffer Allocation and Usage</a>.  
Buffer allocation by the user may be required for the buffered mode to be  
effective.  
<P> 
A send that uses the <b> synchronous</b> mode can be started whether or  
not a matching receive was <em> started</em>.  However, the send will complete  
successfully only if a matching receive is <em> started</em>, and the  
receive operation has started to receive the message sent by the  
synchronous send.  
Thus, the completion of a synchronous send not only indicates that the  
send buffer can be reused, but  
it  
also indicates that the receiver has  
reached a certain point in its execution, namely that it has started  
executing the matching receive.  If both sends and receives are  
blocking operations then the use of the synchronous mode provides  
synchronous communication semantics: a communication does not complete  
at either end before both <font face="sans-serif"> MPI</font> processes rendezvous at the  
communication.  A send executed in this mode is <em> nonlocal</em>.  
<P> 
A send that uses the <b> ready</b> communication mode  
may be started <em> only</em> if the matching receive is already <em> started</em>.  
Otherwise, the operation is <em> erroneous</em> and its outcome is undefined.  
On some systems, this allows the removal of a hand-shake  
protocol that is otherwise required and results in improved  
performance.  
The completion of the send operation does not depend on the  
status of a matching receive, and merely indicates that the send  
buffer can be reused.  A send operation that uses the ready mode has  
the same semantics as a standard send operation, or a synchronous send  
operation; it is merely that the sender provides additional  
information to the system (namely that a matching receive is already  
<em> started</em>), that can save some overhead.  In a correct program, therefore, a  
ready send could be replaced by a standard send with no effect on the  
behavior of the program other than performance.  
<P> 
Three additional send functions are provided for the three additional  
communication  
modes.  The communication mode is indicated by a one letter prefix:  
<font face="sans-serif"> B</font> for buffered,  
<font face="sans-serif"> S</font> for synchronous, and  
<font face="sans-serif"> R</font> for ready.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_BSEND(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in send buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each send buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Bsend(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <br></tt>  
  
  <tt> int MPI_Bsend_c(const void *buf, MPI_Count count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Bsend(buf, count, datatype, dest, tag, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Bsend(buf, count, datatype, dest, tag, comm, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_BSEND(BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">DEST</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Send in buffered mode.  
<P> 
According to the definitions in Section <a href="node32.htm#Node32"><font face="sans-serif"> MPI</font> Procedures</a>,  
<font face="sans-serif"> MPI_BSEND</font> is a completing procedure and the user can re-use  
all resources given as arguments, including the <em> message data buffer</em>.  
It is also a local procedure because it returns immediately without  
depending on the execution of any <font face="sans-serif"> MPI</font> procedure in any other <font face="sans-serif"> MPI</font> process.  
 
<br> 
<em> Advice to users.</em>  
<P> 
This is one of the exceptions in which a completing and therefore blocking operation-related procedure is local.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_SSEND(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in send buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each send buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Ssend(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <br></tt>  
  
  <tt> int MPI_Ssend_c(const void *buf, MPI_Count count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Ssend(buf, count, datatype, dest, tag, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Ssend(buf, count, datatype, dest, tag, comm, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SSEND(BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">DEST</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Send in synchronous mode.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_RSEND(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in send buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each send buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Rsend(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <br></tt>  
  
  <tt> int MPI_Rsend_c(const void *buf, MPI_Count count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Rsend(buf, count, datatype, dest, tag, comm, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Rsend(buf, count, datatype, dest, tag, comm, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_RSEND(BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">DEST</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Send in ready mode.  
<P> 
There is only one receive operation,  
but it matches  
any of the send modes.  
The receive procedure described in the last section is <em> blocking</em>:  
it returns only after the receive buffer contains the newly received  
message.  A receive can complete before the matching send  
has completed (of course, it can complete only after the matching send  
has started).  
<P> 
In a multithreaded implementation of <font face="sans-serif"> MPI</font>, the system may de-schedule a  
thread that is blocked on a send or receive  
operation, and schedule another thread for execution in the same  
address space.  
In such a case it is the user's responsibility not to  
modify a  
communication  
buffer until the communication completes.  
Otherwise, the outcome of the computation is undefined.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Since a synchronous send cannot complete before a matching receive is <em> started</em>,  
one will not normally buffer messages sent by such an operation.  
<P> 
It is recommended to choose buffering over blocking the sender, whenever  
possible, for standard sends.  The programmer can signal a preference  
for blocking the sender until a matching receive occurs by using the  
synchronous send mode.  
<P> 
A possible communication protocol for the various communication modes  
is outlined below.  
<P> 
<dl> 
 
<dt> 
<b>ready send:</b><dd> 
The message is sent as soon as possible.  
<P> 
 
<dt> 
<b>synchronous send:</b><dd> 
The sender sends a request-to-send message.  
The receiver stores this request.  
When a matching receive is <em> started</em>, the receiver sends back a permission-to-send  
message, and the sender now sends the message.  
<P> 
 
<dt> 
<b>standard send:</b><dd> 
First protocol may be used for short messages, and second protocol for  
long messages.  
<P> 
 
<dt> 
<b>buffered send:</b><dd> 
The sender copies the message into a buffer and then sends it with a  
nonblocking send (using the same protocol as for standard send).  
</dl> 
<br> 
Additional control messages might be needed for flow control and error  
recovery.  Of course, there are many other possible protocols.  
<P> 
Ready send can be implemented as a standard send. In this case  
there will be no performance advantage (or disadvantage) for the use of  
ready send.  
<P> 
A standard send can be implemented as a synchronous send.  
In such a case, no data buffering is needed.  However,  
users may  
expect some buffering.  
<P> 
In a multithreaded environment, the execution of a blocking communication  
should block only the executing thread, allowing the thread scheduler to  
de-schedule this thread and schedule another thread for execution.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node68.htm#Node68"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node55.htm#Node55"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node70.htm#Node70"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node55.htm#Node55"> Point-to-Point Communication</a>
<b>Next: </b><a href="node70.htm#Node70"> Semantics of Point-to-Point Communication</a>
<b>Previous: </b><a href="node68.htm#Node68"> Data Conversion</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
