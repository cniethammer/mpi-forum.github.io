<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Problems with Code Movement and Register Optimization</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node486">20.1.17. Problems with Code Movement and Register Optimization</span></h2>
<a href="node485.htm#Node485"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node466.htm#Node466"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node487"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node466.htm#Node466"> Support for Fortran</a>
<b>Next: </b><a href="node486.htm#Node487"> Nonblocking Operations</a>
<b>Previous: </b><a href="node485.htm#Node485"> Optimization Problems, an Overview</a>
<p>
  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node485.htm#Node485"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node466.htm#Node466"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node487"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node466.htm#Node466"> Support for Fortran</a>
<b>Next: </b><a href="node486.htm#Node487"> Nonblocking Operations</a>
<b>Previous: </b><a href="node485.htm#Node485"> Optimization Problems, an Overview</a>
<p>
<hr><h3><span id="Node487">20.1.17.1. Nonblocking Operations</span></h3>
<a href="node486.htm#Node486"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node488"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node488"> Persistent Operations</a>
<b>Previous: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<p>
  
<P> 
If a variable is local to a Fortran subroutine (i.e., not in  
a module or a <tt>COMMON</tt> block), the compiler will assume that it cannot be modified  
by a called subroutine unless it is an actual argument of the  
call.  In the most common linkage convention, the subroutine is  
expected to save and restore certain registers. Thus, the optimizer  
will assume that a register that held a valid copy of such a  
variable before the call will still hold a valid copy on return.  
<P> 
<br><b> Example</b>  
Fortran 90 register optimization---extreme.  
  
  
<P><img width=882 height=135 src="img62.gif" alt="Image file"><P>
  
  
<P> 
Example <a href="node486.htm#Node487">Nonblocking Operations</a>  
shows extreme, but allowed, possibilities.  
<font face="sans-serif"> MPI_WAIT</font> on a concurrent thread modifies <font face="sans-serif"> buf</font>  
between the invocation of <font face="sans-serif"> MPI_IRECV</font> and the completion of  
<font face="sans-serif"> MPI_WAIT</font>.  But the compiler cannot see any possibility that  
<font face="sans-serif"> buf</font> can be changed after <font face="sans-serif"> MPI_IRECV</font> has returned,  
and may schedule the load of <font face="sans-serif"> buf</font> earlier than  
typed in the source. The compiler has no reason to avoid using a register to  
hold <font face="sans-serif"> buf</font> across the call to <font face="sans-serif"> MPI_WAIT</font>.  It also  
may reorder the instructions as illustrated in the rightmost column.  
<P> 
<br><b> Example</b>  
Similar example with <font face="sans-serif"> MPI_ISEND</font>  
  
  
<P><img width=950 height=224 src="img63.gif" alt="Image file"><P>
  
  
<P> 
Due to valid compiler code movement optimizations in Example <a href="node486.htm#Node487">Nonblocking Operations</a>,  
the content of <font face="sans-serif"> buf</font> may already have been overwritten by the compiler  
when the content of <font face="sans-serif"> buf</font> is sent.  
The code movement is permitted because the compiler cannot detect a possible access  
to <font face="sans-serif"> buf</font> in <font face="sans-serif"> MPI_WAIT</font> (or in a second thread between  
the start of <font face="sans-serif"> MPI_ISEND</font> and the end of <font face="sans-serif"> MPI_WAIT</font>).  
<P> 
Such register optimization is based on moving code; here, the access to <font face="sans-serif"> buf</font>  
was moved from after <font face="sans-serif"> MPI_WAIT</font> to before <font face="sans-serif"> MPI_WAIT</font>.  
Note that code movement may also occur across subroutine boundaries when  
subroutines or functions are inlined.  
<P> 
This register optimization/code movement problem for nonblocking operations does not occur  
with <font face="sans-serif"> MPI</font> parallel file I/O split collective operations,  
because in the <font face="sans-serif"> MPI_ XXX_BEGIN</font> and <font face="sans-serif"> MPI_ XXX_END</font> calls,  
the same buffer has to be provided as an actual argument.  
The register optimization / code movement problem for <font face="sans-serif"> MPI_BOTTOM</font>  
and derived <font face="sans-serif"> MPI</font> datatypes may occur in each blocking and nonblocking  
communication call, as well as in each parallel file I/O operation.  
<P> 

<P>
<hr>
<a href="node486.htm#Node486"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node488"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node488"> Persistent Operations</a>
<b>Previous: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<p>
<hr><h3><span id="Node488">20.1.17.2. Persistent Operations</span></h3>
<a href="node486.htm#Node487"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node489"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node489"> One-sided Communication</a>
<b>Previous: </b><a href="node486.htm#Node487"> Nonblocking Operations</a>
<p>
  
<P> 
With persistent requests, the buffer argument is hidden from the  
<font face="sans-serif"> MPI_START</font> and <font face="sans-serif"> MPI_STARTALL</font> calls, i.e., the  
Fortran compiler may move buffer accesses across the  
<font face="sans-serif"> MPI_START</font> or <font face="sans-serif"> MPI_STARTALL</font> call, similar to the  
<font face="sans-serif"> MPI_WAIT</font> call as described in the Nonblocking Operations  
subsection in Section <a href="node486.htm#Node486">Problems with Code Movement and Register Optimization</a>.  
<P> 

<P>
<hr>
<a href="node486.htm#Node487"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node489"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node489"> One-sided Communication</a>
<b>Previous: </b><a href="node486.htm#Node487"> Nonblocking Operations</a>
<p>
<hr><h3><span id="Node489">20.1.17.3. One-sided Communication</span></h3>
<a href="node486.htm#Node488"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node490"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node490"> <font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>
<b>Previous: </b><a href="node486.htm#Node488"> Persistent Operations</a>
<p>
  
<P> 
An example with instruction reordering due to register optimization can be found  
in Section <a href="node343.htm#Node343">Registers and Compiler Optimizations</a>.  
<P> 

<P>
<hr>
<a href="node486.htm#Node488"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node490"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node490"> <font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>
<b>Previous: </b><a href="node486.htm#Node488"> Persistent Operations</a>
<p>
<hr><h3><span id="Node490">20.1.17.4.  MPI_BOTTOM and Combining Independent Variables in Datatypes</span></h3>
<a href="node486.htm#Node489"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node491"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node491"> Solutions</a>
<b>Previous: </b><a href="node486.htm#Node489"> One-sided Communication</a>
<p>
This section is only relevant if the <font face="sans-serif"> MPI</font> program uses  
a buffer argument to an <font face="sans-serif"> MPI_SEND</font>, <font face="sans-serif"> MPI_RECV</font>,  
etc., that hides the actual  
variables involved in the communication.  
<font face="sans-serif"> MPI_BOTTOM</font> with an  
<font face="sans-serif"> MPI_Datatype</font> containing <em> absolute addresses</em> is one example.  Creating  
a datatype that uses one variable as an anchor and brings along  
others by using <font face="sans-serif"> MPI_GET_ADDRESS</font> to determine their offsets from  
the anchor is another. The anchor variable would be the only one  
referenced in the call. Also attention must be paid if <font face="sans-serif"> MPI</font> operations  
are used that run in parallel with the user's application.  
<P> 
Example <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>  
shows what Fortran compilers are allowed to do.  
<P> 
<br><b> Example</b>  
Fortran 90 register optimization.  
  
  
  
<P><img width=893 height=270 src="img64.gif" alt="Image file"><P>
  
  
<P> 
In Example <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>, the  
compiler does not invalidate the register because it cannot  
see that <font face="sans-serif"> MPI_RECV</font> changes the value of <font face="sans-serif"> buf</font>.  
The access to <font face="sans-serif"> buf</font> is hidden by the use of  
<font face="sans-serif"> MPI_GET_ADDRESS</font> and <font face="sans-serif"> MPI_BOTTOM</font>.  
<P> 
<br><b> Example</b>  
Similar example with <font face="sans-serif"> MPI_SEND</font>  
  
  
  
<P><img width=881 height=268 src="img65.gif" alt="Image file"><P>
  
  
<P> 
In Example <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>,  
several successive assignments to the same variable <font face="sans-serif"> buf</font> can be combined in a way  
such that only the last assignment is executed.  
``Successive'' means that no interfering load access to this variable occurs between the assignments.  
The compiler cannot detect that the call to <font face="sans-serif"> MPI_SEND</font> statement is interfering  
because the load access to <font face="sans-serif"> buf</font> is hidden by the usage of <font face="sans-serif"> MPI_BOTTOM</font>.  
<P> 

<P>
<hr>
<a href="node486.htm#Node489"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node491"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node491"> Solutions</a>
<b>Previous: </b><a href="node486.htm#Node489"> One-sided Communication</a>
<p>
<hr><h3><span id="Node491">20.1.17.5. Solutions</span></h3>
<a href="node486.htm#Node490"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node492"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node492"> The Fortran <tt> ASYNCHRONOUS</tt> Attribute</a>
<b>Previous: </b><a href="node486.htm#Node490"> <font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>
<p>
  
<P> 
The following sections show in detail how the problems  
with code movement and register optimization can be  
portably solved.  
Application writers can partially or fully avoid these compiler optimization problems  
by using one or more of the special Fortran declarations with  
the send and receive buffers used in nonblocking operations, or in operations  
in which <font face="sans-serif"> MPI_BOTTOM</font> is used, or if datatype handles that combine several variables are used:  
<ul> 
 
<li>Use of the Fortran <tt> ASYNCHRONOUS</tt> attribute.  
 
<li>Use of the helper routine <font face="sans-serif"> MPI_F_SYNC_REG</font>,  
      or an equivalent user-written dummy routine.  
 
<li>Declare the buffer as a Fortran module variable or within a Fortran common block.  
 
<li>Use of the Fortran <tt> VOLATILE</tt> attribute.  
</ul> 
<br> 
<br><b> Example</b>  
Protecting nonblocking communication with the <tt> ASYNCHRONOUS</tt> attribute.  
  
[Protecting nonblocking communication with <tt> ASYNCHRONOUS</tt>]FortranProtecting nonblocking communication with ASYNCHRONOUS@Protecting nonblocking communication with <tt> ASYNCHRONOUS</tt>  
<br> 
<pre style="background-color:#EFEFEF"><tt>USE mpi_f08 
REAL, ASYNCHRONOUS :: b(0:101) ! elements 0 and 101 are halo cells 
REAL :: bnew(0:101)            ! elements 1 and 100 are newly computed 
TYPE(MPI_Request) :: req(4) 
INTEGER :: left, right, i 
CALL MPI_Cart_shift(...,left,right,...) 
CALL MPI_Irecv(b(  0), ..., left,  ..., req(1), ...) 
CALL MPI_Irecv(b(101), ..., right, ..., req(2), ...) 
CALL MPI_Isend(b(  1), ..., left,  ..., req(3), ...) 
CALL MPI_Isend(b(100), ..., right, ..., req(4), ...) 
 
#ifdef WITHOUT_OVERLAPPING_COMMUNICATION_AND_COMPUTATION 
! Case (a) 
  CALL MPI_Waitall(4, req, ...) 
  DO i=1,100 ! compute all new local data 
    bnew(i) = function(b(i-1), b(i), b(i+1)) 
  END DO 
#endif 
 
#ifdef WITH_OVERLAPPING_COMMUNICATION_AND_COMPUTATION 
! Case (b) 
  DO i=2,99  ! compute  only elements for which halo data is not needed 
    bnew(i) = function(b(i-1), b(i), b(i+1)) 
  END DO 
  CALL MPI_Waitall(4, req, ...) 
  i=1 ! compute leftmost element 
    bnew(i) = function(b(i-1), b(i), b(i+1)) 
  i=100 ! compute rightmost element 
    bnew(i) = function(b(i-1), b(i), b(i+1)) 
#endif 
</tt></pre> 
  
  
<P> 
Each of these methods solves the problems of code movement and register optimization,  
but may incur various degrees of performance impact,  
and may not be usable in every application context.  
These methods may not be guaranteed by the Fortran standard,  
but they must be guaranteed by a <font face="sans-serif"> MPI-3.0</font> (and later) compliant  
<font face="sans-serif"> MPI</font> library and associated compiler  
suite according to the requirements  
listed in Section <a href="node473.htm#Node473">Requirements on Fortran Compilers</a>.  
The performance impact of using <font face="sans-serif"> MPI_F_SYNC_REG</font> is  
expected to be low, that of using module variables or the  
<tt> ASYNCHRONOUS</tt> attribute is expected to be low to medium, and  
that of using the <tt> VOLATILE</tt> attribute is expected to be high or  
very high.  
Note that there is one attribute that cannot be used for this purpose:  
the Fortran <tt> TARGET</tt> attribute does not solve  
code movement problems in <font face="sans-serif"> MPI</font> applications.  
<P> 

<P>
<hr>
<a href="node486.htm#Node490"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node492"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node492"> The Fortran <tt> ASYNCHRONOUS</tt> Attribute</a>
<b>Previous: </b><a href="node486.htm#Node490"> <font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>
<p>
<hr><h3><span id="Node492">20.1.17.6. The Fortran  ASYNCHRONOUS Attribute</span></h3>
<a href="node486.htm#Node491"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node493"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node493"> Calling <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<b>Previous: </b><a href="node486.htm#Node491"> Solutions</a>
<p>
  
  
<P> 
Declaring an actual buffer argument with the <tt> ASYNCHRONOUS</tt>  
Fortran attribute in a scoping unit (or <tt> BLOCK</tt>)  
informs the compiler that any statement in the scoping unit may be executed while the buffer  
is affected by a pending asynchronous Fortran input/output operation (since Fortran 2003)  
or by an asynchronous communication (TS 29113 extension).  
Without the extensions specified in TS 29113, a Fortran compiler may totally ignore this  
attribute if the Fortran compiler implements asynchronous Fortran input/output operations  
with blocking I/O.  
The <tt> ASYNCHRONOUS</tt> attribute protects the buffer accesses  
from optimizations through code movements across routine calls,  
and the buffer itself from temporary and permanent data movements.  
If the choice buffer dummy argument of a nonblocking <font face="sans-serif"> MPI</font> routine is declared  
with <tt> ASYNCHRONOUS</tt>  
(which is mandatory for the <tt>mpi_f08</tt> module, with allowable exceptions listed in  
Section <a href="node472.htm#Node472"><font face="sans-serif"> MPI</font> for Different Fortran Standard Versions</a>),  
then the compiler has to guarantee call by reference  
and should report a compile-time error if call by reference is  
impossible, e.g., if vector subscripts are used.  
The <font face="sans-serif"> MPI_ASYNC_PROTECTS_NONBLOCKING</font> is set to <tt>.TRUE.</tt>  
if both the protection of the actual buffer argument through  
<tt> ASYNCHRONOUS</tt> according to the TS 29113 extension  
and the declaration of the dummy argument with <tt> ASYNCHRONOUS</tt>  
in the Fortran support method is guaranteed for all nonblocking routines,  
otherwise it is set to <tt>.FALSE.</tt>.  
<P> 
The <tt> ASYNCHRONOUS</tt> attribute has some restrictions.  
Section 5.4.2 of the TS 29113 specifies:  
<blockquote>  
``Asynchronous communication for a Fortran variable occurs through the action of procedures defined by means  
other than Fortran. It is initiated by execution of an asynchronous communication initiation procedure and  
completed by execution of an asynchronous communication completion procedure. Between the execution of the  
initiation and completion procedures, any variable of which any part is associated with any part of the  
asynchronous communication variable is a <b> pending communication affector</b>. Whether a procedure is an asynchronous  
communication initiation or completion procedure is processor dependent.  
<P> 
Asynchronous communication is either input communication or output communication. For input communication,  
a <em> pending communication affector</em> shall not be referenced, become defined, become undefined, become associated  
with a dummy argument that has the <tt> VALUE</tt> attribute, or have its pointer association status changed. For  
output communication, a <em> pending communication affector</em> shall not be redefined, become undefined, or have its  
pointer association status changed.''  
</blockquote>  
<P> 
In Example <a href="node486.htm#Node491">Solutions</a> Case (a) on page <a href="node486.htm#Node491">Solutions</a>,  
the read accesses to <tt>b</tt> within <tt>function(b(i-1), b(i), b(i+1))</tt>  
cannot be moved by compiler optimizations to before the wait call  
because <tt>b</tt> was declared as <tt> ASYNCHRONOUS</tt>.  
Note that only the elements 0, 1, 100, and 101 of <tt>b</tt> are  
involved in asynchronous communication but by definition,  
the total variable <tt>b</tt> is the <em> pending communication affector</em>  
and is usable for input and output asynchronous communication  
between the <tt>MPI_I<font face="sans-serif"> XXX</font></tt> routines and <tt>MPI_Waitall</tt>.  
Case (a) works fine because the read accesses to <tt>b</tt>  
occur after the communication has completed.  
<P> 
In Case (b), the read accesses to <tt>b(1:100)</tt> in the loop <tt>i=2,99</tt>  
are read accesses to a <em> pending communication affector</em> while  
input communication (i.e., the two <tt>MPI_Irecv</tt> calls)  
is <em> pending</em>.  
This is a contradiction to the rule that  
<em> for input communication, a</em>  
<em> pending communication affector</em>  
<em> shall not be referenced</em>.  
The problem can be solved by using separate variables for the halos  
and the inner array,  
or by splitting a common array into disjoint subarrays that are  
passed through different dummy arguments into a subroutine, as shown  
in Example <a href="node499.htm#Node499">Permanent Data Movement</a>.  
<P> 
If one does not overlap communication and computation on the same  
variable, then all optimization problems can be solved  
through the <tt> ASYNCHRONOUS</tt> attribute.  
<P> 
The problems with <font face="sans-serif"> MPI_BOTTOM</font>, as shown in  
Example <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a> and Example <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>,  
can also be solved by declaring the buffer <tt>buf</tt> with the  
<tt> ASYNCHRONOUS</tt> attribute.  
<P> 
In some <font face="sans-serif"> MPI</font> routines, a buffer dummy argument is defined as <tt> ASYNCHRONOUS</tt> to  
guarantee passing by reference, provided that the actual argument is also defined as  
<tt> ASYNCHRONOUS</tt>.  
<P> 

<P>
<hr>
<a href="node486.htm#Node491"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node493"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node493"> Calling <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<b>Previous: </b><a href="node486.htm#Node491"> Solutions</a>
<p>
<hr><h3><span id="Node493">20.1.17.7. Calling  MPI_F_SYNC_REG</span></h3>
<a href="node486.htm#Node492"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node494"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node494"> A User Defined Routine Instead of <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<b>Previous: </b><a href="node486.htm#Node492"> The Fortran <tt> ASYNCHRONOUS</tt> Attribute</a>
<p>
  
<P> 
The compiler may be prevented from moving a reference to a buffer  
across a call to an <font face="sans-serif"> MPI</font> subroutine by surrounding the call by calls to  
an external subroutine with the buffer as an actual argument.  
The <font face="sans-serif"> MPI</font> library provides the <font face="sans-serif"> MPI_F_SYNC_REG</font> routine for this purpose;  
see Section <a href="node474.htm#Node474">Additional Support for Fortran Register-Memory-Synchronization</a>.  
<P> 
<ul> 
 
<li>The problems illustrated by the  
   Examples <a href="node486.htm#Node487">Nonblocking Operations</a> and <a href="node486.htm#Node487">Nonblocking Operations</a>  
   can be solved by calling <font face="sans-serif"> MPI_F_SYNC_REG</font><font face="sans-serif"> (buf)</font>  
   once immediately after <font face="sans-serif"> MPI_WAIT</font>.  
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="LEFT">Example <a href="node486.htm#Node487">Nonblocking Operations</a> can be solved with  
</TD><TD ALIGN="LEFT"><P> 
Example <a href="node486.htm#Node487">Nonblocking Operations</a> can be solved with  
</TD></TR> 
<TR><TD ALIGN="LEFT"><br> 
<pre style="background-color:#EFEFEF"><tt>  <b>call</b> <b>MPI_IRECV</b>(buf,..req) 
  
  
  <b>call</b> <b>MPI_WAIT</b>(req,..) 
  <b>call</b> <b>MPI_F_SYNC_REG</b>(buf) 
  b1 = buf 
</tt></pre> 
  
</TD><TD ALIGN="LEFT"><P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>  buf = val 
  <b>call</b> <b>MPI_ISEND</b>(buf,..req) 
  copy = buf 
  <b>call</b> <b>MPI_WAIT</b>(req,..) 
  <b>call</b> <b>MPI_F_SYNC_REG</b>(buf) 
  buf = val_overwrite 
</tt></pre> 
  
</TD></TR> 
<TR><TD></TD><TD></TD></TR></TABLE> 
</div>  
  The call to <font face="sans-serif"> MPI_F_SYNC_REG</font> prevents moving the last line  
  before the <font face="sans-serif"> MPI_WAIT</font> call.  
  Further calls to <font face="sans-serif"> MPI_F_SYNC_REG</font> are not needed  
  because it is still correct if the additional read access <tt>copy=buf</tt>  
  is moved below <font face="sans-serif"> MPI_WAIT</font> and before <tt>buf=val_overwrite</tt>.  
<P> 
 
<li>The problems illustrated by the  
   Examples <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a> and <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a>  
   can be solved with two additional <font face="sans-serif"> MPI_F_SYNC_REG</font>  
   statements;  
   one directly before <font face="sans-serif"> MPI_RECV</font>/<font face="sans-serif"> MPI_SEND</font>,  
   and one directly after this communication operation.  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD ALIGN="LEFT">Example <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a> can be solved with  
</TD><TD ALIGN="LEFT"><P> 
Example <a href="node486.htm#Node490"><font face="sans-serif"> MPI_BOTTOM</font> and Combining Independent Variables in Datatypes</a> can be solved with  
</TD></TR> 
<TR><TD ALIGN="LEFT"><br> 
<pre style="background-color:#EFEFEF"><tt>  <b>call</b> <b>MPI_F_SYNC_REG</b>(buf) 
  <b>call</b> <b>MPI_RECV</b>(<b>MPI_BOTTOM</b>,...) 
  <b>call</b> <b>MPI_F_SYNC_REG</b>(buf) 
</tt></pre> 
  
</TD><TD ALIGN="LEFT"><P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>  <b>call</b> <b>MPI_F_SYNC_REG</b>(buf) 
  <b>call</b> <b>MPI_SEND</b>(<b>MPI_BOTTOM</b>,...) 
  <b>call</b> <b>MPI_F_SYNC_REG</b>(buf) 
</tt></pre> 
  
</TD></TR> 
<TR><TD></TD><TD></TD></TR></TABLE> 
</div>  
  The first call to <font face="sans-serif"> MPI_F_SYNC_REG</font>  
  is needed to finish all load and store  
  references to <font face="sans-serif"> buf</font> prior to  <font face="sans-serif"> MPI_RECV</font>/<font face="sans-serif"> MPI_SEND</font>;  
  the second call is needed to assure that any subsequent  
  access to <font face="sans-serif"> buf</font> is not moved before  
  <font face="sans-serif"> MPI_RECV</font>/<font face="sans-serif"> MPI_SEND</font>.  
<P> 
 
<li>In the Example <a href="node343.htm#Node343">Registers and Compiler Optimizations</a> in Section <a href="node343.htm#Node343">Registers and Compiler Optimizations</a>,  
   two asynchronous accesses must be protected:  
   in Process 1, the access to <font face="sans-serif"> bbbb</font> must be protected  
   similar to Example <a href="node486.htm#Node487">Nonblocking Operations</a>, i.e.,  
   a call to <font face="sans-serif"> MPI_F_SYNC_REG</font> is needed  
   after the second <font face="sans-serif"> MPI_WIN_FENCE</font> to guarantee that  
   further accesses to <font face="sans-serif"> bbbb</font> are not moved  
   ahead of the call to <font face="sans-serif"> MPI_WIN_FENCE</font>.  
   In Process 2, both calls to <font face="sans-serif"> MPI_WIN_FENCE</font> together  
   act as a communication call with <font face="sans-serif"> MPI_BOTTOM</font> as the buffer.  
   That is, before the first fence and after the second fence,  
   a call to <font face="sans-serif"> MPI_F_SYNC_REG</font> is needed  
   to guarantee that accesses to <font face="sans-serif"> buff</font> are not moved  
   after or ahead of the calls to <font face="sans-serif"> MPI_WIN_FENCE</font>.  
   Using <font face="sans-serif"> MPI_GET</font> instead of <font face="sans-serif"> MPI_PUT</font>,  
   the same calls to <font face="sans-serif"> MPI_F_SYNC_REG</font> are necessary.  
<P> 
<br><b> Example</b>  
Solution for the Fortran register optimization problems with one-sided communication in Example <a href="node343.htm#Node343">Registers and Compiler Optimizations</a>.  
  
[Fortran 90 register optimization in <font face="sans-serif"> RMA</font>]FortranFortran 90 register optimization in RMA@Fortran 90 register optimization in <font face="sans-serif"> RMA</font>MPI_WIN_FENCE,MPI_PUT,MPI_F_SYNC_REG  
<P><img width=729 height=241 src="img66.gif" alt="Image file"><P>
  
  
<P> 
 
<li>The temporary memory modification problem, (see  
      Example <a href="node498.htm#Node498">Temporary Data Movement and Temporary Memory Modification</a>),  
      can <b> not</b> be solved with this method.  
</ul> 
<br> 

<P>
<hr>
<a href="node486.htm#Node492"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node494"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node494"> A User Defined Routine Instead of <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<b>Previous: </b><a href="node486.htm#Node492"> The Fortran <tt> ASYNCHRONOUS</tt> Attribute</a>
<p>
<hr><h3><span id="Node494">20.1.17.8. A User Defined Routine Instead of  MPI_F_SYNC_REG</span></h3>
<a href="node486.htm#Node493"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node495"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node495"> Module Variables and <tt>COMMON</tt> Blocks</a>
<b>Previous: </b><a href="node486.htm#Node493"> Calling <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<p>
  
<P> 
Instead of <font face="sans-serif"> MPI_F_SYNC_REG</font>, one can also use a  
user defined external subroutine, which is separately compiled:  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>subroutine</b> DD(buf) 
  <b>integer</b> buf 
<b>end</b> 
</tt></pre> 
  
<P> 
Note that if the <tt> INTENT</tt> is declared in an explicit interface for the external subroutine, it  
must be <tt> OUT</tt> or <tt> INOUT</tt>. The subroutine itself may have an empty body, but  
the compiler does not know this and has to assume that the buffer may  
be altered.  For example, a call to  
<font face="sans-serif"> MPI_RECV</font> with <font face="sans-serif"> MPI_BOTTOM</font> as buffer might be replaced by  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>call</b> DD(buf) 
<b>call</b> <b>MPI_RECV</b>(<b>MPI_BOTTOM</b>,...) 
<b>call</b> DD(buf) 
</tt></pre> 
  
Such a user-defined routine was introduced in <font face="sans-serif"> MPI-2.0</font> and is still included here  
to document such usage in existing application programs although  
new applications should prefer <font face="sans-serif"> MPI_F_SYNC_REG</font> or one of the  
other possibilities.  
In an existing application, calls to such a user-written routine should  
be substituted by a call to <font face="sans-serif"> MPI_F_SYNC_REG</font> because the  
user-written routine may not be implemented in accordance with the  
rules specified in Section <a href="node473.htm#Node473">Requirements on Fortran Compilers</a>.  
<P> 

<P>
<hr>
<a href="node486.htm#Node493"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node495"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node495"> Module Variables and <tt>COMMON</tt> Blocks</a>
<b>Previous: </b><a href="node486.htm#Node493"> Calling <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<p>
<hr><h3><span id="Node495">20.1.17.9. Module Variables and COMMON Blocks</span></h3>
<a href="node486.htm#Node494"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node496"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node496"> The (Poorly Performing) Fortran <tt> VOLATILE</tt> Attribute</a>
<b>Previous: </b><a href="node486.htm#Node494"> A User Defined Routine Instead of <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<p>
  
  
<P> 
An alternative to the previously mentioned methods is to put the buffer or variable into a module or a  
common block and access it through a <tt>USE</tt> or <tt>COMMON</tt> statement in each  
scope where it is referenced, defined or appears as an actual argument  
in a call to an <font face="sans-serif"> MPI</font> routine. The compiler will then have to assume that  
the <font face="sans-serif"> MPI</font> procedure may alter the buffer  
or variable, provided that the compiler cannot infer that the <font face="sans-serif"> MPI</font>  
procedure does not reference the module or common block.  
<ul> 
 
<li>This method solves problems of instruction reordering, code movement,  
   and register optimization  
   related to nonblocking and one-sided communication,  
   or related to the usage of <font face="sans-serif"> MPI_BOTTOM</font> and derived datatype handles.  
 
<li>Unfortunately, this method does <b> not</b> solve problems  
   caused by asynchronous accesses between the start and  
   end of a nonblocking or one-sided communication. Specifically,  
   problems caused by temporary memory modifications are not solved.  
</ul> 
<br> 

<P>
<hr>
<a href="node486.htm#Node494"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node496"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node496"> The (Poorly Performing) Fortran <tt> VOLATILE</tt> Attribute</a>
<b>Previous: </b><a href="node486.htm#Node494"> A User Defined Routine Instead of <font face="sans-serif"> MPI_F_SYNC_REG</font></a>
<p>
<hr><h3><span id="Node496">20.1.17.10. The (Poorly Performing) Fortran  VOLATILE Attribute</span></h3>
<a href="node486.htm#Node495"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node497"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node497"> The Fortran <tt> TARGET</tt> Attribute</a>
<b>Previous: </b><a href="node486.htm#Node495"> Module Variables and <tt>COMMON</tt> Blocks</a>
<p>
  
<P> 
The <tt> VOLATILE</tt> attribute  
gives the buffer or variable the properties needed to avoid register  
optimization or code movement problems, but it may inhibit  
optimization of any code containing references or definitions of the buffer or variable.  
On many modern systems, the performance impact will be large because  
not only register, but also cache optimizations will not be  
applied. Therefore, use of the <tt> VOLATILE</tt> attribute to enforce  
correct execution of <font face="sans-serif"> MPI</font> programs is discouraged.  
<P> 

<P>
<hr>
<a href="node486.htm#Node495"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node486.htm#Node497"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node486.htm#Node497"> The Fortran <tt> TARGET</tt> Attribute</a>
<b>Previous: </b><a href="node486.htm#Node495"> Module Variables and <tt>COMMON</tt> Blocks</a>
<p>
<hr><h3><span id="Node497">20.1.17.11. The Fortran  TARGET Attribute</span></h3>
<a href="node486.htm#Node496"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node498.htm#Node498"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node498.htm#Node498"> Temporary Data Movement and Temporary Memory Modification</a>
<b>Previous: </b><a href="node486.htm#Node496"> The (Poorly Performing) Fortran <tt> VOLATILE</tt> Attribute</a>
<p>
  
<P> 
The <tt> TARGET</tt> attribute does not solve the code movement problem  
because it is not specified for the choice buffer dummy arguments  
of nonblocking routines.  
If the compiler detects that the application program specifies the  
<tt> TARGET</tt> attribute for an actual buffer argument used  
in the call to a nonblocking routine,  
the compiler may ignore this attribute if  
no pointer reference to this buffer exists.  
 
<br> 
<em> Rationale.</em>  
<P> 
The Fortran standardization body decided to extend the <tt> ASYNCHRONOUS</tt> attribute  
within the TS 29113 to protect buffers in nonblocking  
calls  
from all kinds of optimization, instead of extending the <tt> TARGET</tt> attribute.  
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node486.htm#Node496"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node486.htm#Node486"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node498.htm#Node498"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node486.htm#Node486"> Problems with Code Movement and Register Optimization</a>
<b>Next: </b><a href="node498.htm#Node498"> Temporary Data Movement and Temporary Memory Modification</a>
<b>Previous: </b><a href="node486.htm#Node496"> The (Poorly Performing) Fortran <tt> VOLATILE</tt> Attribute</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
