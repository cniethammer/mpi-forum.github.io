<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-topol/topol-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Low-Level Topology Functions</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node233">9.5.8. Low-Level Topology Functions</span></h2>
<a href="node232.htm#Node232"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node225.htm#Node225"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node234.htm#Node234"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node225.htm#Node225"> Topology Constructors</a>
<b>Next: </b><a href="node234.htm#Node234"> Neighborhood Collective Communication on Virtual Topologies</a>
<b>Previous: </b><a href="node232.htm#Node232"> Partitioning of Cartesian Structures</a>
<p>
  
The two additional functions introduced in this section can be used to  
implement all other topology functions. In general they will not be  
called by the user directly, except when creating additional  
<em> virtual topology</em> capabilities other than those provided by <font face="sans-serif"> MPI</font>.  
The two calls are both local.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_CART_MAP(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">ndims</span>, <span style="white-space:nowrap">dims</span>, <span style="white-space:nowrap">periods</span>, <span style="white-space:nowrap">newrank</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>input communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> ndims</TD><TD>number of dimensions of Cartesian structure (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dims</TD><TD>integer array of size <font face="sans-serif"> ndims</font> specifying the number of processes in each coordinate direction</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> periods</TD><TD>logical array of size <font face="sans-serif"> ndims</font> specifying the periodicity specification in each coordinate direction</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newrank</TD><TD>reordered rank of the calling <font face="sans-serif"> MPI</font> process; <font face="sans-serif"> MPI_UNDEFINED</font> if calling <font face="sans-serif"> MPI</font> process does not belong to grid (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Cart_map(MPI_Comm comm, int ndims, const int dims[], const int periods[], int *newrank) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Cart_map(comm, ndims, dims, periods, newrank, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">ndims</span>, <span style="white-space:nowrap">dims(ndims)</span><br>LOGICAL, INTENT(IN) :: <span style="white-space:nowrap">periods(ndims)</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">newrank</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_CART_MAP(COMM, NDIMS, DIMS, PERIODS, NEWRANK, IERROR) <br> INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">NDIMS</span>, <span style="white-space:nowrap">DIMS(*)</span>, <span style="white-space:nowrap">NEWRANK</span>, <span style="white-space:nowrap">IERROR</span><br>LOGICAL <span style="white-space:nowrap">PERIODS(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_CART_MAP</font>  
computes an ``optimal'' placement for the calling <font face="sans-serif"> MPI</font> process on the  
physical machine.  A possible implementation of this function is to always  
return the rank of the calling <font face="sans-serif"> MPI</font> process, that is, not to perform any reordering.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The function <font face="sans-serif"> MPI_CART_CREATE</font><tt>(comm, ndims, dims, 
periods, reorder, comm_cart)</tt>, with <font face="sans-serif"> reorder = true</font> can be implemented by  
calling  
<font face="sans-serif"> MPI_CART_MAP</font><tt>(comm, ndims, dims, periods, newrank)</tt>, then calling  
<font face="sans-serif"> MPI_COMM_SPLIT</font><tt>(comm, color, key, comm_cart)</tt>, with  
<font face="sans-serif"> color = 0</font> if <font face="sans-serif"> newrank <i>&ne;</i></font>  
<font face="sans-serif"> MPI_UNDEFINED</font>, <font face="sans-serif"> color = </font><font face="sans-serif"> MPI_UNDEFINED</font> otherwise,  
and <font face="sans-serif"> key = newrank</font>. If <font face="sans-serif"> ndims</font> is zero  
then a zero-dimensional Cartesian topology is created.  
<P> 
The function <font face="sans-serif"> MPI_CART_SUB</font><tt>(comm, remain_dims, comm_new)</tt> can be  
implemented by a call to <font face="sans-serif"> MPI_COMM_SPLIT</font><tt>(comm, color, key, comm_new)</tt>,  
using a single number encoding of the lost dimensions as <font face="sans-serif"> color</font> and a  
single number encoding of the preserved dimensions as <font face="sans-serif"> key</font>.  
<P> 
All other Cartesian topology functions can be implemented locally, using  
the topology information that is cached with the communicator.  
 (<em> End of advice to implementors.</em>) <br> 
The corresponding function for  
graph structures is as follows.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GRAPH_MAP(<span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">nnodes</span>, <span style="white-space:nowrap">index</span>, <span style="white-space:nowrap">edges</span>, <span style="white-space:nowrap">newrank</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>input communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> nnodes</TD><TD>number of graph nodes (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> index</TD><TD>integer array specifying the graph structure (for details see the definition of <font face="sans-serif"> MPI_GRAPH_CREATE</font>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> edges</TD><TD>integer array specifying the graph structure</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newrank</TD><TD>reordered rank of the calling <font face="sans-serif"> MPI</font> process; <font face="sans-serif"> MPI_UNDEFINED</font> if the calling <font face="sans-serif"> MPI</font> process does not belong to graph (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Graph_map(MPI_Comm comm, int nnodes, const int index[], const int edges[], int *newrank) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Graph_map(comm, nnodes, index, edges, newrank, ierror) <br> TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">nnodes</span>, <span style="white-space:nowrap">index(nnodes)</span>, <span style="white-space:nowrap">edges(*)</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">newrank</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GRAPH_MAP(COMM, NNODES, INDEX, EDGES, NEWRANK, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">NNODES</span>, <span style="white-space:nowrap">INDEX(*)</span>, <span style="white-space:nowrap">EDGES(*)</span>, <span style="white-space:nowrap">NEWRANK</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The function <font face="sans-serif"> MPI_GRAPH_CREATE</font><tt>(comm, nnodes, index, edges, 
reorder, comm_graph)</tt>,  
with <font face="sans-serif"> reorder = true</font> can be implemented by calling  
<font face="sans-serif"> MPI_GRAPH_MAP</font><tt>(comm, nnodes, index, edges, newrank)</tt>,  
then calling  
<font face="sans-serif"> MPI_COMM_SPLIT</font><tt>(comm, color, key, comm_graph)</tt>, with <font face="sans-serif"> color = 0</font>  
if <font face="sans-serif"> newrank <i>&ne;</i></font>  
<font face="sans-serif"> MPI_UNDEFINED</font>, <font face="sans-serif"> color = </font><font face="sans-serif"> MPI_UNDEFINED</font>  
otherwise, and <font face="sans-serif"> key = newrank</font>.  
<P> 
All other graph topology functions can be implemented locally, using the  
topology information that is cached with the communicator.  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node232.htm#Node232"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node225.htm#Node225"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node234.htm#Node234"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node225.htm#Node225"> Topology Constructors</a>
<b>Next: </b><a href="node234.htm#Node234"> Neighborhood Collective Communication on Virtual Topologies</a>
<b>Previous: </b><a href="node232.htm#Node232"> Partitioning of Cartesian Structures</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
