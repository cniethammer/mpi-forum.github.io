<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-io/io-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>File Consistency</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node385">15.6.1. File Consistency</span></h2>
<a href="node384.htm#Node384"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node386.htm#Node386"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Consistency and Semantics</a>
<b>Next: </b><a href="node386.htm#Node386"> Random Access vs. Sequential Files</a>
<b>Previous: </b><a href="node384.htm#Node384"> Consistency and Semantics</a>
<p>
  
Consistency semantics define the outcome of multiple accesses  
to a single file.  
All file accesses in <font face="sans-serif"> MPI</font> are relative to a specific file handle  
created from a collective open.  
<font face="sans-serif"> MPI</font> provides three levels of consistency:  
sequential consistency among all accesses using a single file handle,  
sequential consistency among all accesses  
using file handles created from a single collective open  
with atomic mode enabled,  
and  
user-imposed consistency among accesses other than the above.  
Sequential consistency means the behavior of a set of operations  
will be as if the operations were performed in some serial order  
consistent with program order; each access appears atomic,  
although the exact ordering of accesses is unspecified.  
User-imposed consistency may be obtained using program order  
and calls to <font face="sans-serif"> MPI_FILE_SYNC</font>.  
<P> 
Let <i>FH<SUB>1</SUB></i> be the set of file handles created  
from one particular collective open of the file <i>FOO</i>,  
and <i>FH<SUB>2</SUB></i> be the set of file handles created  
from a different collective open of <i>FOO</i>.  
Note that nothing restrictive is said about <i>FH<SUB>1</SUB></i> and <i>FH<SUB>2</SUB></i>:  
the sizes of <i>FH<SUB>1</SUB></i> and <i>FH<SUB>2</SUB></i> may be different,  
the groups of processes used for each open may or may not intersect,  
the file handles in <i>FH<SUB>1</SUB></i> may be destroyed  
before those in <i>FH<SUB>2</SUB></i> are created, etc.  
Consider the following three cases:  
a single file handle (e.g., <i>fh<SUB>1</SUB> &isin; FH<SUB>1</SUB></i>),  
two file handles created from a single collective open  
  (e.g., <i>fh<SUB>1a</SUB> &isin; FH<SUB>1</SUB></i> and <i>fh<SUB>1b</SUB> &isin; FH<SUB>1</SUB></i>), and  
two file handles from different collective opens  
  (e.g., <i>fh<SUB>1</SUB> &isin; FH<SUB>1</SUB></i> and <i>fh<SUB>2</SUB> &isin; FH<SUB>2</SUB></i>).  
<P> 
For the purpose of consistency semantics, a matched   
pair (Section <a href="node376.htm#Node376">Split Collective Data Access Routines</a>) of split  
collective data access operations (e.g., <font face="sans-serif"> MPI_FILE_READ_ALL_BEGIN</font> and  
<font face="sans-serif"> MPI_FILE_READ_ALL_END</font>) compose a single data access  
operation.  
Similarly, a nonblocking data access routine  
(e.g., <font face="sans-serif"> MPI_FILE_IREAD</font>) and the  
routine that completes the request  
(e.g., <font face="sans-serif"> MPI_WAIT</font>) also compose a single data  
access operation.  
For all cases below, these data access operations   
are subject to the same constraints as blocking data access operations.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
For an <font face="sans-serif"> MPI_FILE_IREAD</font> and <font face="sans-serif"> MPI_WAIT</font> pair,  
the operation begins when <font face="sans-serif"> MPI_FILE_IREAD</font> is called and  
ends when <font face="sans-serif"> MPI_WAIT</font> returns.  
 (<em> End of advice to users.</em>) <br> 
Assume that <i>A<SUB>1</SUB></i> and <i>A<SUB>2</SUB></i> are two data access operations.  
Let <i>D<SUB>1</SUB></i> (<i>D<SUB>2</SUB></i>) be the set of absolute byte displacements  
of every byte accessed in <i>A<SUB>1</SUB></i> (<i>A<SUB>2</SUB></i>).  
The two data accesses <b> overlap</b>  
if <img width=122 height=22 src="img60.gif" alt="Image file">
.  
The two data accesses <b> conflict</b>  
if they overlap and at least one is a write access.  
<P> 
Let <i>SEQ<SUB>fh</SUB></i> be a sequence of file operations on a single file handle,  
bracketed by <font face="sans-serif"> MPI_FILE_SYNC</font>s on that file handle.  
(Both opening and closing a file implicitly perform an <font face="sans-serif"> MPI_FILE_SYNC</font>.)  
<i>SEQ<SUB>fh</SUB></i> is a ``write sequence''  
if any of the data access operations in the sequence are writes  
or if any of the file manipulation operations in the sequence  
change the state of the file  
(e.g., <font face="sans-serif"> MPI_FILE_SET_SIZE</font> or <font face="sans-serif"> MPI_FILE_PREALLOCATE</font>).  
Given two sequences, <i>SEQ<SUB>1</SUB></i> and <i>SEQ<SUB>2</SUB></i>,  
we say they  
are not <b> concurrent</b>  
if one sequence is guaranteed to completely precede the other (temporally).  
<P> 
The requirements for guaranteeing sequential consistency among all  
accesses to a particular file are divided into the three cases given  
below.  If any of these requirements are not met, then the value of  
all data in that file is implementation dependent.  
<P> 
<b> Case 1: <i>fh<SUB>1</SUB> &isin; FH<SUB>1</SUB></i>.</b>  
All operations on <i>fh<SUB>1</SUB></i> are sequentially consistent if atomic mode  
is set.  If nonatomic mode is set, then all operations on <i>fh<SUB>1</SUB></i>   
are sequentially consistent if they are either nonconcurrent, nonconflicting,  
or both.  
<P> 
<b> Case 2: <i>fh<SUB>1a</SUB> &isin; FH<SUB>1</SUB></i> and <i>fh<SUB>1b</SUB> &isin; FH<SUB>1</SUB></i>.</b>  
Assume <i>A<SUB>1</SUB></i> is a data access operation using <i>fh<SUB>1a</SUB></i>,  
and    <i>A<SUB>2</SUB></i> is a data access operation using <i>fh<SUB>1b</SUB></i>.  
If for any access <i>A<SUB>1</SUB></i>, there is no access <i>A<SUB>2</SUB></i> that conflicts  
with <i>A<SUB>1</SUB></i>, then <font face="sans-serif"> MPI</font> guarantees sequential consistency.  
<P> 
However, unlike POSIX semantics, the default <font face="sans-serif"> MPI</font> semantics  
for conflicting accesses  
do not guarantee sequential consistency.  
If <i>A<SUB>1</SUB></i> and <i>A<SUB>2</SUB></i> conflict,  
sequential consistency can be guaranteed by either  
enabling atomic mode via the <font face="sans-serif"> MPI_FILE_SET_ATOMICITY</font> routine, or  
meeting the   
condition  
described in Case 3 below.  
<P> 
<b> Case 3: <i>fh<SUB>1</SUB> &isin; FH<SUB>1</SUB></i> and <i>fh<SUB>2</SUB> &isin; FH<SUB>2</SUB></i>.</b>  
Consider access to a single file using file handles from distinct  
collective opens.  
In order to guarantee sequential consistency, <font face="sans-serif"> MPI_FILE_SYNC</font>  
must be used (both opening and closing a file implicitly perform an  
<font face="sans-serif"> MPI_FILE_SYNC</font>).  
<P> 
Sequential consistency is guaranteed among accesses to a single file if  
for any write sequence <i>SEQ<SUB>1</SUB></i> to the file,  
there is no sequence <i>SEQ<SUB>2</SUB></i> to the file that  
is <em> concurrent</em> with  
<i>SEQ<SUB>1</SUB></i>.  
To guarantee sequential consistency when there are write sequences,  
<font face="sans-serif"> MPI_FILE_SYNC</font> must be used  
together with a mechanism that guarantees nonconcurrency of the sequences.  
<P> 
See the examples in Section <a href="node395.htm#Node395">Examples</a> for  
further clarification of some of these consistency semantics.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_SET_ATOMICITY(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">flag</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> flag</TD><TD><font face="sans-serif"> true</font> to set atomic mode, <font face="sans-serif"> false</font> to set nonatomic mode (logical)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_set_atomicity(MPI_File fh, int flag) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_set_atomicity(fh, flag, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>LOGICAL, INTENT(IN) :: <span style="white-space:nowrap">flag</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_SET_ATOMICITY(FH, FLAG, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">IERROR</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
Let <i>FH</i> be the set of file handles created by one collective open.  
The consistency semantics for data access operations using <i>FH</i>  
is set by collectively calling <font face="sans-serif"> MPI_FILE_SET_ATOMICITY</font> on <i>FH</i>.  
<font face="sans-serif"> MPI_FILE_SET_ATOMICITY</font> is collective;  
all processes in the group must pass identical values for  
<font face="sans-serif"> fh</font> and <font face="sans-serif"> flag</font>.  
If <font face="sans-serif"> flag</font> is <font face="sans-serif"> true</font>, atomic mode is set;  
if <font face="sans-serif"> flag</font> is <font face="sans-serif"> false</font>, nonatomic mode is set.  
<P> 
Changing the consistency semantics for an open file only affects new  
data accesses.  All completed data accesses are guaranteed to abide  
by the consistency semantics in effect during their execution.  
Nonblocking data accesses  
and split collective operations  
that  
have not completed  
(e.g., via <font face="sans-serif"> MPI_WAIT</font>) are only guaranteed  
to abide by nonatomic mode consistency semantics.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Since the semantics guaranteed by atomic mode are stronger than  
those guaranteed by nonatomic mode, an implementation is  
free to adhere to the more stringent atomic mode semantics  
for outstanding requests.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_GET_ATOMICITY(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">flag</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> flag</TD><TD><font face="sans-serif"> true</font> if atomic mode, <font face="sans-serif"> false</font> if nonatomic mode (logical)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_get_atomicity(MPI_File fh, int *flag) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_get_atomicity(fh, flag, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">flag</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_GET_ATOMICITY(FH, FLAG, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">IERROR</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_GET_ATOMICITY</font> returns  
the current consistency semantics for  
data access operations on  
the set of file handles created by one collective open.  
If <font face="sans-serif"> flag</font> is <font face="sans-serif"> true</font>, atomic mode is enabled;  
if <font face="sans-serif"> flag</font> is <font face="sans-serif"> false</font>, nonatomic mode is enabled.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_SYNC(<span style="white-space:nowrap">fh</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_sync(MPI_File fh) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_sync(fh, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_SYNC(FH, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Calling <font face="sans-serif"> MPI_FILE_SYNC</font> with <font face="sans-serif"> fh</font> causes  
all previous writes to <font face="sans-serif"> fh</font> by the calling process   
to be transferred to the storage device.  
If other processes have made updates to the storage device,  
then all such updates become visible to  
subsequent reads of <font face="sans-serif"> fh</font> by the calling process.  
<font face="sans-serif"> MPI_FILE_SYNC</font>   
may be necessary to ensure sequential consistency in certain  
cases (see above).  
<P> 
<font face="sans-serif"> MPI_FILE_SYNC</font> is a collective operation.  
<P> 
The user is responsible for ensuring that all nonblocking requests  
and split collective operations  
on <font face="sans-serif"> fh</font> have been completed before calling  
<font face="sans-serif"> MPI_FILE_SYNC</font>---otherwise, the call to  
<font face="sans-serif"> MPI_FILE_SYNC</font> is erroneous.  
<P> 

<P>
<hr>
<a href="node384.htm#Node384"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node384.htm#Node384"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node386.htm#Node386"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node384.htm#Node384"> Consistency and Semantics</a>
<b>Next: </b><a href="node386.htm#Node386"> Random Access vs. Sequential Files</a>
<b>Previous: </b><a href="node384.htm#Node384"> Consistency and Semantics</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
