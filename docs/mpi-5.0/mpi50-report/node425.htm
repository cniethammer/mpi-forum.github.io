<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-tools/mpit-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Performance Variables</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node425">16.3.7. Performance Variables</span></h2>
<a href="node421.htm#Node424"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node415.htm#Node415"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node426"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node415.htm#Node415"> The <font face="sans-serif"> MPI</font> Tool Information Interface</a>
<b>Next: </b><a href="node425.htm#Node426"> Performance Variable Classes</a>
<b>Previous: </b><a href="node421.htm#Node424"> Control Variable Access Functions</a>
<p>
  
  
  
<P> 
The following section focuses on the ability to list and to query  
performance variables provided by the <font face="sans-serif"> MPI</font> implementation.  Performance  
variables provide insight into <font face="sans-serif"> MPI</font> implementation-specific internals and  
can represent information such as the state of the <font face="sans-serif"> MPI</font> implementation  
(e.g., waiting blocked, receiving, not active), aggregated timing data for  
submodules, or queue sizes and lengths.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The interface for performance variables is separate from the interface for  
control variables, since performance variables have different requirements  
and parameters.  By keeping them separate, the interface provides cleaner  
semantics and allows for more performance optimization opportunities.  
 (<em> End of rationale.</em>) <br> 
Some performance variables and classes refer to <b> events</b>.  
In general,  
such events describe state transitions within software or hardware related  
to the performance of an <font face="sans-serif"> MPI</font> application. The events offered through the  
callback-driven event-notification interface described in  
Section <a href="node432.htm#Node432">Events</a> also refer to such state transitions;  
however, the set of state transitions referred to by performance variables and  
events as described in Section <a href="node432.htm#Node432">Events</a> may not be identical.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node421.htm#Node424"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node415.htm#Node415"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node426"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node415.htm#Node415"> The <font face="sans-serif"> MPI</font> Tool Information Interface</a>
<b>Next: </b><a href="node425.htm#Node426"> Performance Variable Classes</a>
<b>Previous: </b><a href="node421.htm#Node424"> Control Variable Access Functions</a>
<p>
<hr><h3><span id="Node426">16.3.7.1. Performance Variable Classes</span></h3>
<a href="node425.htm#Node425"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node427"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node427"> Performance Variable Query Functions</a>
<b>Previous: </b><a href="node425.htm#Node425"> Performance Variables</a>
<p>
  
<P> 
Each performance variable is associated with a class that describes its  
basic semantics, possible datatypes, basic behavior, its starting value,  
whether it can overflow, and when and how an <font face="sans-serif"> MPI</font> implementation can  
change the variable's value.  The starting value is the value that is  
assigned to the variable the first time that it is used or whenever it is  
reset.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
If a performance variable belongs to a class that can overflow, it is up to  
the user to protect against this overflow, e.g., by frequently reading and  
resetting the variable value.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
<font face="sans-serif"> MPI</font> implementations should use large enough datatypes for each  
performance variable to avoid overflows under normal circumstances.  
 (<em> End of advice to implementors.</em>) <br> 
The classes are defined by the following constants:  
<P> 
  
<P> 
<dl> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_STATE</font>:</b><dd> 
A performance variable in this  
  class represents a set of discrete states.  Variables of this class are  
  represented by <font face="sans-serif"> MPI_INT</font> and can be set by the <font face="sans-serif"> MPI</font>  
  implementation at any time.  Variables of this type should be described  
  further using an enumeration, as discussed in Section <a href="node420.htm#Node420">Datatype System</a>.  
  The starting value is the current state of the implementation at the time  
  that the starting value is set.  <font face="sans-serif"> MPI</font> implementations must ensure that  
  variables of this class cannot overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_LEVEL</font>:</b><dd> 
A performance variable in this  
  class represents a value that describes the utilization level of a  
  resource.  The value of a variable of this class can change at any time  
  to match the current utilization level of the resource.  Values returned  
  from variables in this class are nonnegative and represented by one of  
  the following datatypes: <font face="sans-serif"> MPI_UNSIGNED</font>,  
  <font face="sans-serif"> MPI_UNSIGNED_LONG</font>, <font face="sans-serif"> MPI_UNSIGNED_LONG_LONG</font>,  
  <font face="sans-serif"> MPI_DOUBLE</font>.  The starting value is the current utilization level  
  of the resource at the time that the starting value is set.  <font face="sans-serif"> MPI</font>  
  implementations must ensure that variables of this class cannot overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_SIZE</font>:</b><dd> 
A performance variable in this  
  class represents a value that is the size of a resource.  Values returned  
  from variables in this class are nonnegative and represented by one of  
  the following datatypes: <font face="sans-serif"> MPI_UNSIGNED</font>,  
  <font face="sans-serif"> MPI_UNSIGNED_LONG</font>, <font face="sans-serif"> MPI_UNSIGNED_LONG_LONG</font>,  
  <font face="sans-serif"> MPI_DOUBLE</font>.  The starting value is the current size of the  
  resource at the time that the starting value is set.  <font face="sans-serif"> MPI</font>  
  implementations must ensure that variables of this class cannot overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_PERCENTAGE</font>:</b><dd> 
The value of a performance  
  variable in this class represents the percentage utilization of a finite  
  resource.  The value of a variable of this class can change at any time  
  to match the current utilization level of the resource.  It will be  
  returned as an <font face="sans-serif"> MPI_DOUBLE</font> datatype.  The value must always be  
  between 0.0 (resource not used at all) and 1.0 (resource completely  
  used).  The starting value is the current percentage utilization level of  
  the resource at the time that the starting value is set.  <font face="sans-serif"> MPI</font>  
  implementations must ensure that variables of this class cannot overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_HIGHWATERMARK</font>:</b><dd> 
A performance variable  
  in this class represents a value that describes the maximum observed  
  utilization of a resource.  The value of a variable of this class is  
  nonnegative and grows monotonically from the initialization or reset of  
  the variable.  It can be represented by one of the following datatypes:  
  <font face="sans-serif"> MPI_UNSIGNED</font>, <font face="sans-serif"> MPI_UNSIGNED_LONG</font>,  
  <font face="sans-serif"> MPI_UNSIGNED_LONG_LONG</font>, <font face="sans-serif"> MPI_DOUBLE</font>.  The starting  
  value is the current utilization level of the resource at the time that  
  the variable is started or reset.  <font face="sans-serif"> MPI</font> implementations must ensure that  
  variables of this class cannot overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_LOWWATERMARK</font>:</b><dd> 
A performance variable in  
  this class represents a value that describes the minimum observed  
  utilization of a resource.  The value of a variable of this class is  
  nonnegative and decreases monotonically from the initialization or reset  
  of the variable.  It can be represented by one of the following  
  datatypes: <font face="sans-serif"> MPI_UNSIGNED</font>, <font face="sans-serif"> MPI_UNSIGNED_LONG</font>,  
  <font face="sans-serif"> MPI_UNSIGNED_LONG_LONG</font>, <font face="sans-serif"> MPI_DOUBLE</font>.  The starting  
  value is the current utilization level of the resource at the time that  
  the variable is started or reset.  <font face="sans-serif"> MPI</font> implementations must ensure that  
  variables of this class cannot overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_COUNTER</font>:</b><dd> 
A performance variable in this  
  class counts the number of occurrences of a specific event (e.g., the  
  number of memory allocations within an <font face="sans-serif"> MPI</font> library).  The value of a  
  variable of this class increases monotonically from the initialization or  
  reset of the performance variable by one for each specific event that is  
  observed.  Values must be nonnegative and represented by one of the  
  following datatypes: <font face="sans-serif"> MPI_UNSIGNED</font>, <font face="sans-serif"> MPI_UNSIGNED_LONG</font>,  
  <font face="sans-serif"> MPI_UNSIGNED_LONG_LONG</font>.  The starting value for variables of  
  this class is 0.  Variables of this class can overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_AGGREGATE</font>:</b><dd> 
The value of a performance  
  variable in this class is an aggregated value that represents a sum of  
  arguments processed during a specific event (e.g., the amount of memory  
  allocated by all memory allocations).  This class is similar to the  
  counter class, but instead of counting individual events, the value can  
  be incremented by arbitrary amounts.  The value of a variable of this  
  class increases monotonically from the initialization or reset of the  
  performance variable.  It must be nonnegative and represented by one of  
  the following datatypes: <font face="sans-serif"> MPI_UNSIGNED</font>,  
  <font face="sans-serif"> MPI_UNSIGNED_LONG</font>, <font face="sans-serif"> MPI_UNSIGNED_LONG_LONG</font>,  
  <font face="sans-serif"> MPI_DOUBLE</font>.  The starting value for variables of this class is  
  0.  Variables of this class can overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_TIMER</font>:</b><dd> 
The value of a performance  
  variable in this class represents the aggregated time that the <font face="sans-serif"> MPI</font>  
  implementation spends executing a particular event, type of event, or  
  section of the <font face="sans-serif"> MPI</font> library.  This class has the same basic semantics as  
  <font face="sans-serif"> MPI_T_PVAR_CLASS_AGGREGATE</font>, but explicitly records a timing  
  value.  The value of a variable of this class increases monotonically  
  from the initialization or reset of the performance variable.  It must be  
  nonnegative and represented by one of the following datatypes:  
  <font face="sans-serif"> MPI_UNSIGNED</font>, <font face="sans-serif"> MPI_UNSIGNED_LONG</font>,  
  <font face="sans-serif"> MPI_UNSIGNED_LONG_LONG</font>, <font face="sans-serif"> MPI_DOUBLE</font>.  The starting  
  value for variables of this class is 0.  If the type <font face="sans-serif"> MPI_DOUBLE</font>  
  is used, the units that represent time in this datatype must match the  
  units used by <font face="sans-serif"> MPI_WTIME</font>.  Otherwise, the time units should be  
  documented, e.g., in the description returned by  
  <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font>.  Variables of this class can overflow.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_T_PVAR_CLASS_GENERIC</font>:</b><dd> 
This class can be used to  
  describe a variable that does not fit into any of the other classes.  For  
  variables in this class, the starting value is variable-specific and  
  implementation-defined.  
<P> 
</dl> 
<br> 
  
<P> 

<P>
<hr>
<a href="node425.htm#Node425"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node427"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node427"> Performance Variable Query Functions</a>
<b>Previous: </b><a href="node425.htm#Node425"> Performance Variables</a>
<p>
<hr><h3><span id="Node427">16.3.7.2. Performance Variable Query Functions</span></h3>
<a href="node425.htm#Node426"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node428"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node428"> Performance Experiment Sessions</a>
<b>Previous: </b><a href="node425.htm#Node426"> Performance Variable Classes</a>
<p>
An <font face="sans-serif"> MPI</font> implementation exports a set of <i>N</i> performance variables through  
the <font face="sans-serif"> MPI</font> tool information interface.  If <i>N</i> is zero, then the <font face="sans-serif"> MPI</font>  
implementation does not export any performance variables; otherwise the  
provided performance variables are indexed from <i>0</i> to <i>N-1</i>.  This index  
number is used in subsequent calls to identify the individual variables.  
<P> 
An <font face="sans-serif"> MPI</font> implementation is allowed to increase the number of performance  
variables during the execution of an <font face="sans-serif"> MPI</font> application when new variables  
become available through dynamic loading.  However, <font face="sans-serif"> MPI</font> implementations  
are not allowed to change the index of a performance variable or to delete  
a variable once it has been added to the set.  When a variable becomes  
inactive, e.g., through dynamic unloading, accessing its value should  
return a corresponding return code.  
<P> 
The following function can be used to query the number of performance  
variables, <i><span style="font-family:sans-serif;"> num_pvar</span></i>:  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_GET_NUM(<span style="white-space:nowrap">num_pvar</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> num_pvar</TD><TD>returns number of performance variables (integer)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_get_num(int *num_pvar) <br></tt>  
<P> 
The function <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> provides access to  
additional information for each variable.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_GET_INFO(<span style="white-space:nowrap">pvar_index</span>, <span style="white-space:nowrap">name</span>, <span style="white-space:nowrap">name_len</span>, <span style="white-space:nowrap">verbosity</span>, <span style="white-space:nowrap">var_class</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">enumtype</span>, <span style="white-space:nowrap">desc</span>, <span style="white-space:nowrap">desc_len</span>, <span style="white-space:nowrap">bind</span>, <span style="white-space:nowrap">readonly</span>, <span style="white-space:nowrap">continuous</span>, <span style="white-space:nowrap">atomic</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pvar_index</TD><TD>index of the performance variable to be queried between <i>0</i> and <i><span style="font-family:sans-serif;"> num_pvar</span>-1</i> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> name</TD><TD>buffer to return the string containing the name of the performance variable (string)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> name_len</TD><TD>length of the string and/or buffer for <font face="sans-serif"> name</font> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> verbosity</TD><TD>verbosity level of this variable (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> var_class</TD><TD>class of performance variable (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> datatype</TD><TD><font face="sans-serif"> MPI</font> datatype of the information stored in the performance variable (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> enumtype</TD><TD>optional descriptor for enumeration information (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> desc</TD><TD>buffer to return the string containing a description of the performance variable (string)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> desc_len</TD><TD>length of the string and/or buffer for <font face="sans-serif"> desc</font> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> bind</TD><TD>type of <font face="sans-serif"> MPI</font> object to which this variable must be bound (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> readonly</TD><TD>flag indicating whether the variable can be written/reset (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> continuous</TD><TD>flag indicating whether the variable can be started and stopped or is continuously active (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> atomic</TD><TD>flag indicating whether the variable can be atomically read and reset (integer)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_get_info(int pvar_index, char *name, int *name_len, int *verbosity, int *var_class, MPI_Datatype *datatype, MPI_T_enum *enumtype, char *desc, int *desc_len, int *bind, int *readonly, int *continuous, int *atomic) <br></tt>  
<P> 
After a successful call to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> for a  
particular variable, subsequent calls to this routine that query  
information about the same variable must return the same information.  An  
<font face="sans-serif"> MPI</font> implementation is not allowed to alter any of the returned values.  
<P> 
If any <span style="font-size:0.900em;"> OUT</span> parameter to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> is a  
<tt>NULL</tt> pointer, the implementation will ignore the parameter and not  
return a value for the parameter.  
<P> 
 The arguments <font face="sans-serif"> name</font> and <font face="sans-serif"> name_len</font> are used to return the name of the performance variable as described in Section <a href="node418.htm#Node418">Convention for Returning Strings</a>.  If completed  
successfully, the routine is required to return a name of at least length  
one.  
<P> 
The argument <font face="sans-serif"> verbosity</font> returns the verbosity level of the variable  
(see Section <a href="node416.htm#Node416">Verbosity Levels</a>).  
<P> 
The class of the performance variable is returned in the parameter  
<font face="sans-serif"> var_class</font>.  The class must be one of the constants defined in  
Section <a href="node425.htm#Node426">Performance Variable Classes</a>.  
<P> 
The combination of the name and the class of the performance variable must  
be unique with respect to all other names for  performance variables used  
by the <font face="sans-serif"> MPI</font> implementation.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Groups of variables that belong closely together, but have different  
classes, can have the same name.  This choice is useful, e.g., to refer to  
multiple variables that describe a single resource (like the level, the  
total size, as well as high- and low-water marks).  
 (<em> End of advice to implementors.</em>) <br> 
The argument <font face="sans-serif"> datatype</font> returns the <font face="sans-serif"> MPI</font> datatype that is used to  
represent the performance variable.  
<P> 
If the variable is of type <font face="sans-serif"> MPI_INT</font>, <font face="sans-serif"> MPI</font> can optionally specify  
an enumeration for the values represented by this variable and return it in  
<font face="sans-serif"> enumtype</font>.  In this case, <font face="sans-serif"> MPI</font> returns an enumeration identifier,  
which can then be used to gather more information as described in  
Section <a href="node420.htm#Node420">Datatype System</a>.  Otherwise, <font face="sans-serif"> enumtype</font> is set to  
<font face="sans-serif"> MPI_T_ENUM_NULL</font>.  If the datatype is not <font face="sans-serif"> MPI_INT</font> or the  
argument <font face="sans-serif"> enumtype</font> is the null pointer, no enumeration type is  
returned.  
<P> 
Returning a description is optional.  If an <font face="sans-serif"> MPI</font> implementation does not  
return a description, the first character for <font face="sans-serif"> desc</font> must be set to  
the null character and <font face="sans-serif"> desc_len</font> must be set to one at the return  
from this function.  
<P> 
The parameter <font face="sans-serif"> bind</font> returns the type of the <font face="sans-serif"> MPI</font> object to which  
the variable must be bound or the value <font face="sans-serif"> MPI_T_BIND_NO_OBJECT</font>  
(see Section <a href="node417.htm#Node417">Binding <font face="sans-serif"> MPI</font> Tool Information Interface Variables to <font face="sans-serif"> MPI</font> Objects</a>).  
<P> 
Upon return, the argument <font face="sans-serif"> readonly</font> is set to zero if the variable  
can be written or reset by the user.  It is set to one if the variable can  
only be read.  
<P> 
Upon return, the argument <font face="sans-serif"> continuous</font> is set to zero if the  
variable can be started and stopped by the user, i.e., it is possible for  
the user to control if and when the value of a variable is updated.  It is  
set to one if the variable is always active and cannot be controlled by the  
user.  
<P> 
Upon return, the argument <font face="sans-serif"> atomic</font> is set to zero if the variable  
cannot be read and reset atomically.  Only variables for which the call  
sets <font face="sans-serif"> atomic</font> to one can be used in a call to  
<font face="sans-serif"> MPI_T_PVAR_READRESET</font>.  
<P> 
If a performance variable has an equivalent name and has the same class  
across connected <font face="sans-serif"> MPI</font> processes, the following <span style="font-size:0.900em;"> OUT</span> parameters must be  
identical: <font face="sans-serif"> verbosity</font>, <font face="sans-serif"> varclass</font>, <font face="sans-serif"> datatype</font>,  
<font face="sans-serif"> enumtype</font>, <font face="sans-serif"> bind</font>, <font face="sans-serif"> readonly</font>, <font face="sans-serif"> continuous</font>,  
and <font face="sans-serif"> atomic</font>.  The returned description must be equivalent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_GET_INDEX(<span style="white-space:nowrap">name</span>, <span style="white-space:nowrap">var_class</span>, <span style="white-space:nowrap">pvar_index</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> name</TD><TD>the name of the performance variable (string)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> var_class</TD><TD>the class of the performance variable (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> pvar_index</TD><TD>the index of the performance variable (integer)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_get_index(const char *name, int var_class, int *pvar_index) <br></tt>  
<P> 
<font face="sans-serif"> MPI_T_PVAR_GET_INDEX</font> is a function for retrieving the index  
of a performance variable given a known variable name and class.  The  
<font face="sans-serif"> name</font> and <font face="sans-serif"> var_class</font> parameters are provided by the  
caller, and <font face="sans-serif"> pvar_index</font> is returned by the <font face="sans-serif"> MPI</font> implementation.  
The <font face="sans-serif"> name</font> parameter is a string terminated with a null character.  
<P> 
This routine returns <span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> on success and returns  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_INVALID_NAME</span></font> if <font face="sans-serif"> name</font> does not match the name  
of any performance variable of the specified <font face="sans-serif"> var_class</font> provided  
by the implementation at the time of the call.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This routine is provided to enable fast retrieval of performance variables  
by a tool, assuming it knows the name of the variable for which it is  
looking.  The number of variables exposed by the implementation can change  
over time, so it is not possible for the tool to simply iterate over the  
list of variables once at initialization.  Although using <font face="sans-serif"> MPI</font>  
implementation specific variable names is not portable across <font face="sans-serif"> MPI</font>  
implementations, tool developers may choose to take this route for lower  
overhead at runtime because the tool will not have to iterate over the  
entire set of variables to find a specific one.  
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node425.htm#Node426"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node428"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node428"> Performance Experiment Sessions</a>
<b>Previous: </b><a href="node425.htm#Node426"> Performance Variable Classes</a>
<p>
<hr><h3><span id="Node428">16.3.7.3. Performance Experiment Sessions</span></h3>
<a href="node425.htm#Node427"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node429"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node429"> Handle Allocation and Deallocation</a>
<b>Previous: </b><a href="node425.htm#Node427"> Performance Variable Query Functions</a>
<p>
  
<P> 
Within a single program, multiple components can use the <font face="sans-serif"> MPI</font> tool  
information interface.  To avoid collisions with respect to accesses to  
performance variables, users of the <font face="sans-serif"> MPI</font> tool information interface must  
first create a performance experiment session.  Subsequent calls that  
access performance variables can then be made within the context of this  
performance experiment session.   Starting, stopping, reading, writing, or  
resetting a variable in one performance experiment session shall not  
influence whether a variable is started, stopped, read, written, or reset  
in another performance experiment session.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_SESSION_CREATE(<span style="white-space:nowrap">pe_session</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_session_create(MPI_T_pvar_session *pe_session) <br></tt>  
<P> 
This call creates a new performance experiment session for accessing performance variables and  
returns a handle for this performance experiment session in the argument <font face="sans-serif"> pe_session</font> of type  
<font face="sans-serif"> MPI_T_pvar_session</font>.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_SESSION_FREE(<span style="white-space:nowrap">pe_session</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_session_free(MPI_T_pvar_session *pe_session) <br></tt>  
<P> 
This call frees an existing performance experiment session.  Calls to the <font face="sans-serif"> MPI</font> tool information  
interface  can no longer be made within the context of a performance experiment session after it  
is freed.  On a successful return, <font face="sans-serif"> MPI</font> sets the performance experiment session identifier to  
<font face="sans-serif"> MPI_T_PVAR_SESSION_NULL</font>.  
<P> 

<P>
<hr>
<a href="node425.htm#Node427"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node429"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node429"> Handle Allocation and Deallocation</a>
<b>Previous: </b><a href="node425.htm#Node427"> Performance Variable Query Functions</a>
<p>
<hr><h3><span id="Node429">16.3.7.4. Handle Allocation and Deallocation</span></h3>
<a href="node425.htm#Node428"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node430"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node430"> Starting and Stopping of Performance Variables</a>
<b>Previous: </b><a href="node425.htm#Node428"> Performance Experiment Sessions</a>
<p>
Before using a performance variable, a user must first allocate a handle of  
type <font face="sans-serif"> MPI_T_pvar_handle</font> for  
the variable by binding it to an <font face="sans-serif"> MPI</font> object (see also  
Section <a href="node417.htm#Node417">Binding <font face="sans-serif"> MPI</font> Tool Information Interface Variables to <font face="sans-serif"> MPI</font> Objects</a>).  
<P> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_HANDLE_ALLOC(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">pvar_index</span>, <span style="white-space:nowrap">obj_handle</span>, <span style="white-space:nowrap">handle</span>, <span style="white-space:nowrap">count</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pvar_index</TD><TD>index of performance variable for which handle is to be allocated (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> obj_handle</TD><TD>reference to a handle of the <font face="sans-serif"> MPI</font> object to which this variable is supposed to be bound (pointer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> handle</TD><TD>allocated handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> count</TD><TD>number of elements used to represent this variable (integer)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_handle_alloc(MPI_T_pvar_session pe_session, int pvar_index, void *obj_handle, MPI_T_pvar_handle *handle, int *count) <br></tt>  
<P> 
This routine binds the performance variable specified by the argument  
<font face="sans-serif"> index</font> to an <font face="sans-serif"> MPI</font> object  in the performance experiment session identified by the  
parameter <font face="sans-serif"> pe_session</font>.  The object is passed in the argument  
<font face="sans-serif"> obj_handle</font> as an address to a local variable that stores the  
object's handle.  The argument <font face="sans-serif"> obj_handle</font> is ignored if the  
<font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> call for this performance variable  
returned <font face="sans-serif"> MPI_T_BIND_NO_OBJECT</font> in the argument <font face="sans-serif"> bind</font>.  
The handle allocated to reference the variable is returned in the argument  
<font face="sans-serif"> handle</font>.  Upon successful return, <font face="sans-serif"> count</font> contains the  
number of elements (of the datatype returned by a previous  
<font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> call) used to represent this variable.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> count</font> can be different based on the <font face="sans-serif"> MPI</font> object to which the  
performance variable was bound.  For example, variables bound to  
communicators could have a count that matches the size of the communicator.  
<P> 
It is not portable to pass references to predefined <font face="sans-serif"> MPI</font> object handles,  
such as <font face="sans-serif"> MPI_COMM_WORLD</font>, to this routine, since their  
implementation depends on the <font face="sans-serif"> MPI</font> library.  Instead, such an object  
handle should be stored in a local variable and the address of this local  
variable should be passed into <font face="sans-serif"> MPI_T_PVAR_HANDLE_ALLOC</font>.  
 (<em> End of advice to users.</em>) <br> 
The value of index should be in the range from <i>0</i> to <i><span style="font-family:sans-serif;"> num_pvar</span>-1</i>,  
where <i><span style="font-family:sans-serif;"> num_pvar</span></i> is the number of available performance  
variables as determined from a prior call to  
<font face="sans-serif"> MPI_T_PVAR_GET_NUM</font>.  The type of the <font face="sans-serif"> MPI</font> object it  
references must be consistent with the type returned in the <font face="sans-serif"> bind</font>  
argument in a prior call to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font>.  
<P> 
For all routines in the rest of this section that take both <font face="sans-serif"> handle</font>  
and <font face="sans-serif"> pe_session</font> as <span style="font-size:0.900em;"> IN</span> or <span style="font-size:0.900em;"> INOUT</span> arguments, if the <font face="sans-serif"> handle</font>  
argument passed in is not associated with the <font face="sans-serif"> pe_session</font> argument,  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_INVALID_HANDLE</span></font> is returned.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_HANDLE_FREE(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">handle</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> handle</TD><TD>handle to be freed (handle)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_handle_free(MPI_T_pvar_session pe_session, MPI_T_pvar_handle *handle) <br></tt>  
<P> 
When a handle is no longer needed, a user of the <font face="sans-serif"> MPI</font> tool information  
interface should call <font face="sans-serif"> MPI_T_PVAR_HANDLE_FREE</font> to free the  
handle in the performance experiment session identified by the parameter <font face="sans-serif"> pe_session</font> and the  
associated resources in the <font face="sans-serif"> MPI</font>  implementation.  On a successful return,  
<font face="sans-serif"> MPI</font> sets the handle to <font face="sans-serif"> MPI_T_PVAR_HANDLE_NULL</font>.  
<P> 

<P>
<hr>
<a href="node425.htm#Node428"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node430"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node430"> Starting and Stopping of Performance Variables</a>
<b>Previous: </b><a href="node425.htm#Node428"> Performance Experiment Sessions</a>
<p>
<hr><h3><span id="Node430">16.3.7.5. Starting and Stopping of Performance Variables</span></h3>
<a href="node425.htm#Node429"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node431"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node431"> Performance Variable Access Functions</a>
<b>Previous: </b><a href="node425.htm#Node429"> Handle Allocation and Deallocation</a>
<p>
Performance variables that have the continuous flag set during the query  
procedure are continuously updated once a handle has been allocated.  
Such variables may be queried at any time, but they cannot be started or  
stopped by the user.  All other variables are in a stopped state after  
their handle has been allocated; their values are not updated until they  
have been started by the user.  
<P> 
  
   
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_START(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">handle</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_start(MPI_T_pvar_session pe_session, MPI_T_pvar_handle handle) <br></tt>  
<P> 
This functions starts the performance variable with the handle identified  
by the parameter <font face="sans-serif"> handle</font> in the performance experiment session identified by the parameter  
<font face="sans-serif"> pe_session</font>.  
<P> 
If the constant <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> is passed in  
<font face="sans-serif"> handle</font>, the <font face="sans-serif"> MPI</font> implementation attempts to start all variables  
within the performance experiment session identified by the parameter <font face="sans-serif"> pe_session</font> for  
which handles have been allocated.  In this case, the routine returns  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> if all variables are started successfully (even if  
there are no noncontinuous variables to be started), otherwise  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_PVAR_NO_STARTSTOP</span></font> is returned.  Continuous variables  
and variables that are already started are ignored when  
<font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> is specified.  
<P> 
   
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_STOP(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">handle</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_stop(MPI_T_pvar_session pe_session, MPI_T_pvar_handle handle) <br></tt>  
<P> 
This functions stops the performance variable with the handle identified by  
the parameter <font face="sans-serif"> handle</font> in the performance experiment session identified by the parameter  
<font face="sans-serif"> pe_session</font>.  
<P> 
If the constant <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> is passed in  
<font face="sans-serif"> handle</font>, the <font face="sans-serif"> MPI</font> implementation attempts to stop all variables  
within the performance experiment session identified by the parameter <font face="sans-serif"> pe_session</font> for  
which handles have been allocated.  In this case, the routine returns  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> if all variables are stopped successfully (even if  
there are no noncontinuous variables to be stopped), otherwise  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_PVAR_NO_STARTSTOP</span></font> is returned.  Continuous variables  
and variables that are already stopped are ignored when  
<font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> is specified.  
<P> 

<P>
<hr>
<a href="node425.htm#Node429"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node425.htm#Node431"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node425.htm#Node431"> Performance Variable Access Functions</a>
<b>Previous: </b><a href="node425.htm#Node429"> Handle Allocation and Deallocation</a>
<p>
<hr><h3><span id="Node431">16.3.7.6. Performance Variable Access Functions</span></h3>
<a href="node425.htm#Node430"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node432.htm#Node432"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node432.htm#Node432"> Events</a>
<b>Previous: </b><a href="node425.htm#Node430"> Starting and Stopping of Performance Variables</a>
<p>
   
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_READ(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">handle</span>, <span style="white-space:nowrap">buf</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buf</TD><TD>initial address of storage location for variable value (choice)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_read(MPI_T_pvar_session pe_session, MPI_T_pvar_handle handle, void *buf) <br></tt>  
<P> 
The <font face="sans-serif"> MPI_T_PVAR_READ</font> call queries the value of the performance  
variable with the handle <font face="sans-serif"> handle</font> in the performance experiment session identified by the  
parameter <font face="sans-serif"> pe_session</font> and stores the result in the buffer identified  
by the parameter <font face="sans-serif"> buf</font>.  The user must ensure that the  
buffer is of the appropriate size to hold the entire value of the  
performance variable (based on the datatype and count returned by the  
corresponding previous calls to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> and  
<font face="sans-serif"> MPI_T_PVAR_HANDLE_ALLOC</font>, respectively).  
<P> 
The constant <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> cannot be used as an  
argument for the function <font face="sans-serif"> MPI_T_PVAR_READ</font>.  
<P> 
   
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_WRITE(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">handle</span>, <span style="white-space:nowrap">buf</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of storage location for variable value (choice)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_write(MPI_T_pvar_session pe_session, MPI_T_pvar_handle handle, const void *buf) <br></tt>  
<P> 
The <font face="sans-serif"> MPI_T_PVAR_WRITE</font> call attempts to write the value of the  
performance variable with the handle identified by the parameter  
<font face="sans-serif"> handle</font> in the performance experiment session identified by the parameter  
<font face="sans-serif"> pe_session</font>.  The value to be written is passed in the buffer  
identified by the parameter <font face="sans-serif"> buf</font>.  The user must ensure that the  
buffer is of the appropriate size to hold the entire value of the  
performance variable (based on the datatype and count returned by the  
corresponding previous calls to <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font> and  
<font face="sans-serif"> MPI_T_PVAR_HANDLE_ALLOC</font>, respectively).  
<P> 
If it is not possible to change the variable, the function returns  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_PVAR_NO_WRITE</span></font>.  
<P> 
The constant <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> cannot be used as an  
argument for the  function <font face="sans-serif"> MPI_T_PVAR_WRITE</font>.  
<P> 
   
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_RESET(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">handle</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_reset(MPI_T_pvar_session pe_session, MPI_T_pvar_handle handle) <br></tt>  
<P> 
The <font face="sans-serif"> MPI_T_PVAR_RESET</font> call sets the performance variable with  
the handle identified by the parameter <font face="sans-serif"> handle</font> to its starting  
value specified in Section <a href="node425.htm#Node426">Performance Variable Classes</a>.  If it is not  
possible to change the variable, the function returns  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_PVAR_NO_WRITE</span></font>.  
<P> 
If the constant <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> is passed in  
<font face="sans-serif"> handle</font>, the <font face="sans-serif"> MPI</font> implementation attempts to reset all variables  
within the performance experiment session identified by the parameter <font face="sans-serif"> pe_session</font> for which  
handles have been allocated.  In this case, the routine returns  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font> if all variables are reset successfully (even if there  
are no valid handles or all are read-only), otherwise  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_PVAR_NO_WRITE</span></font> is returned.  Read-only variables are  
ignored when <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> is specified.  
<P> 
   
  
<TABLE><TR><TD COLSPAN=2>MPI_T_PVAR_READRESET(<span style="white-space:nowrap">pe_session</span>, <span style="white-space:nowrap">handle</span>, <span style="white-space:nowrap">buf</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> pe_session</TD><TD>identifier of performance experiment session (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> handle</TD><TD>handle of a performance variable (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buf</TD><TD>initial address of storage location for variable value (choice)</TD></TR>  
</TABLE>  
  <tt> int MPI_T_pvar_readreset(MPI_T_pvar_session pe_session, MPI_T_pvar_handle handle, void *buf) <br></tt>  
<P> 
This call atomically combines the functionality of  
<font face="sans-serif"> MPI_T_PVAR_READ</font> and <font face="sans-serif"> MPI_T_PVAR_RESET</font> with the  
same semantics as if these two calls were called separately.  If the  
variable cannot be read and reset atomically, this routine returns  
<span style="font-size:0.900em;"><font face="sans-serif"> MPI_T_ERR_PVAR_NO_ATOMIC</span></font>.  
<P> 
The constant <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font> cannot be used as an  
argument for the  function <font face="sans-serif"> MPI_T_PVAR_READRESET</font>.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Sampling-based tools rely on the ability to call the <font face="sans-serif"> MPI</font> tool information  
interface, in particular routines to start, stop, read, write, and reset  
performance variables, from any program context, including asynchronous  
contexts such as signal handlers.  <font face="sans-serif"> MPI</font> implementations should strive, if  
possible in their particular environment, to enable these usage scenarios  
for all or a subset of the routines mentioned above.  If implementing only  
a subset, the read, write, and reset routines are typically the most  
critical for sampling-based tools.  An <font face="sans-serif"> MPI</font> implementation should clearly  
document any restrictions on the program contexts in which the <font face="sans-serif"> MPI</font> tool  
information interface can be used.  Restrictions might include guaranteeing  
usage outside of all signals or outside a specific set of signals.  Any  
restrictions could be documented, for example, through the description  
returned by <font face="sans-serif"> MPI_T_PVAR_GET_INFO</font>.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
All routines to read, to write or to reset performance variables require  
the performance experiment session argument.  This requirement keeps the interface consistent and  
allows the use of <font face="sans-serif"> MPI_T_PVAR_ALL_HANDLES</font>  where appropriate.  
Further, this opens up additional performance optimizations for the  
implementation of handles.  
 (<em> End of rationale.</em>) <br> 
<br><b> Example</b>  
Detecting receives with long unexpected message queues.  
  
<P> 
The following example shows a sample tool to identify receive operations  
that occur during times with long message queues.  This examples assumes  
that the <font face="sans-serif"> MPI</font> implementation exports a variable with the name  
``<tt>MPI_T_UMQ_LENGTH</tt>'' to represent the current length of the  
unexpected message queue.  The tool is implemented as a <font face="sans-serif"> PMPI</font>  
tool using the  
<font face="sans-serif"> MPI</font> profiling interface.  
<P> 
The tool consists of three parts: (1) the initialization (by intercepting  
the call to <font face="sans-serif"> MPI_INIT</font>), (2) the test for long unexpected message  
queues (by intercepting calls to <font face="sans-serif"> MPI_RECV</font>), and (3) the clean-up  
phase (by intercepting the call to <font face="sans-serif"> MPI_FINALIZE</font>).  To capture  
all receives, the example would have to be extended to have similar  
wrappers for all receive operations.  
<P> 
<b> Part 1---Initialization:</b>  
During initialization, the tool searches for the variable and, once the  
right index is found, allocates a performance experiment session and a handle for the variable  
with the found index, and starts the performance variable.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>#include</b> &lt;stdio.h&gt; 
<b>#include</b> &lt;stdlib.h&gt; 
<b>#include</b> &lt;string.h&gt; 
<b>#include</b> &lt;assert.h&gt; 
<b>#include</b> &lt;mpi.h&gt; 
 
/* Global variables <b>for</b> the tool */ 
static <b>MPI_T_pvar_session</b> pe_session; 
static <b>MPI_T_pvar_handle</b> handle; 
 
<b>int</b> <b>MPI_Init</b>(<b>int</b> *argc, <b>char</b> ***argv ) { 
    <b>int</b>  err, num, i, index, namelen, verbosity; 
    <b>int</b>  var_class, bind, threadsup; 
    <b>int</b>  readonly, continuous, atomic, count; 
    <b>char</b> name[18]; 
 
    <b>MPI_Comm</b>     comm; 
    <b>MPI_Datatype</b> datatype; 
    <b>MPI_T_enum</b>   enumtype; 
 
    err=<b>PMPI_Init</b>(argc, argv); 
    <b>if</b> (err!=<b>MPI_SUCCESS</b>) 
        <b>return</b> err; 
 
    err=<b>PMPI_T_init_thread</b>(<b>MPI_THREAD_SINGLE</b>, &amp;threadsup); 
    <b>if</b> (err!=<b>MPI_SUCCESS</b>) 
        <b>return</b> err; 
 
    err=<b>PMPI_T_pvar_get_num</b>(&amp;num); 
    <b>if</b> (err!=<b>MPI_SUCCESS</b>) 
        <b>return</b> err; 
 
    index=-1; 
    i=0; 
    <b>while</b> ((i&lt;num) &amp;&amp; (index&lt;0) &amp;&amp; (err==<b>MPI_SUCCESS</b>)) { 
        /* Pass a buffer that is at least one character longer than */ 
        /* the name of the variable being searched <b>for</b> to avoid */ 
        /* finding variables that have a name that has a prefix */ 
        /* equal to the name of the variable being searched. */ 
        namelen=18; 
        err=<b>PMPI_T_pvar_get_info</b>(i, name, &amp;namelen, &amp;verbosity, 
                                 &amp;var_class, &amp;datatype, &amp;enumtype, 
                                 NULL, NULL, &amp;bind,&amp;readonly, 
                                 &amp;continuous, &amp;atomic); 
        <b>if</b> (strcmp(name,"MPI_T_UMQ_LENGTH")==0) index=i; 
        i++; 
    } 
    <b>if</b> (err!=<b>MPI_SUCCESS</b>) 
        <b>return</b> err; 
 
    /* this could be handled in a more flexible way <b>for</b> a generic tool */ 
    assert(index&gt;=0); 
    assert(var_class==<b>MPI_T_PVAR_CLASS_LEVEL</b>); 
    assert(datatype==<b>MPI_INT</b>); 
    assert(bind==<b>MPI_T_BIND_MPI_COMM</b>); 
 
    /* Create a session */ 
    err=<b>PMPI_T_pvar_session_create</b>(&amp;pe_session); 
    <b>if</b> (err!=<b>MPI_SUCCESS</b>) <b>return</b> err; 
 
    /* Get a handle and bind to <b>MPI_COMM_WORLD</b> */ 
    comm=<b>MPI_COMM_WORLD</b>; 
    err=<b>PMPI_T_pvar_handle_alloc</b>(pe_session, index, &amp;comm, &amp;handle, 
                                 &amp;count); 
    <b>if</b> (err!=<b>MPI_SUCCESS</b>) <b>return</b> err; 
 
    /* this could be handled in a more flexible way <b>for</b> a generic tool */ 
    assert(count==1); 
 
    /* Start variable */ 
    err=<b>PMPI_T_pvar_start</b>(pe_session, handle); 
    <b>if</b> (err!=<b>MPI_SUCCESS</b>) <b>return</b> err; 
 
    <b>return</b> <b>MPI_SUCCESS</b>; 
} 
</tt></pre> 
  
<P> 
<b> Part 2---Testing the Queue Lengths During Receives:</b>  
During every receive operation, the tool reads the unexpected queue length  
through the matching performance variable and compares it against a  
predefined threshold.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>#define</b> THRESHOLD 5 
 
<b>int</b> <b>MPI_Recv</b>(<b>void</b> *buf, <b>int</b> count, <b>MPI_Datatype</b> datatype, <b>int</b> source, 
             <b>int</b> tag, <b>MPI_Comm</b> comm, <b>MPI_Status</b> *status) 
{ 
        <b>int</b> value, err; 
 
        <b>if</b> (comm==<b>MPI_COMM_WORLD</b>) { 
                err=<b>PMPI_T_pvar_read</b>(pe_session, handle, &amp;value); 
                <b>if</b> ((err==<b>MPI_SUCCESS</b>) &amp;&amp; (value&gt;THRESHOLD)) 
                { 
                        /* tool identified receive called with <b>long</b> UMQ */ 
                        /* execute tool functionality, */ 
                        /* e.g., gather and print call stack */ 
                } 
        } 
 
        <b>return</b> <b>PMPI_Recv</b>(buf, count, datatype, source, tag, comm, status); 
} 
</tt></pre> 
  
<P> 
<b> Part 3---Termination:</b>  
In the wrapper for <font face="sans-serif"> MPI_FINALIZE</font>, the <font face="sans-serif"> MPI</font> tool information  
interface is finalized.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>int</b> <b>MPI_Finalize</b>(<b>void</b>) 
{ 
    <b>int</b> err; 
 
    err=<b>PMPI_T_pvar_handle_free</b>(pe_session, &amp;handle); 
    err=<b>PMPI_T_pvar_session_free</b>(&amp;pe_session); 
    err=<b>PMPI_T_finalize</b>(); 
    <b>return</b> <b>PMPI_Finalize</b>(); 
} 
</tt></pre> 
  
<P> 
  
<P> 

<P>
<hr>
<a href="node425.htm#Node430"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node425.htm#Node425"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node432.htm#Node432"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node425.htm#Node425"> Performance Variables</a>
<b>Next: </b><a href="node432.htm#Node432"> Events</a>
<b>Previous: </b><a href="node425.htm#Node430"> Starting and Stopping of Performance Variables</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
