<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Datatype Constructors</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node100">6.1.2. Datatype Constructors</span></h2>
<a href="node99.htm#Node99"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node101.htm#Node101"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node101.htm#Node101"> Subarray Datatype Constructor</a>
<b>Previous: </b><a href="node99.htm#Node99"> Type Constructors with Explicit Addresses</a>
<p>
  
<P> 
<b> Contiguous.</b>  
The simplest datatype constructor is  
<font face="sans-serif"> MPI_TYPE_CONTIGUOUS</font>, which  
allows replication of a datatype into contiguous locations.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CONTIGUOUS(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>replication count (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_contiguous(int count, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_contiguous_c(MPI_Count count, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_contiguous(count, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_contiguous(count, oldtype, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CONTIGUOUS(COUNT, OLDTYPE, NEWTYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
  
<font face="sans-serif"> newtype</font> is the datatype obtained by concatenating  
<font face="sans-serif"> count</font> copies of  
<font face="sans-serif"> oldtype</font>.  
Concatenation is defined using <em> extent</em> as the size of  
the concatenated copies.  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> oldtype</font> have type map  
<i>{ (<tt> double</tt>, 0), (<tt> char</tt>, 8) } , 
</i>  
with extent 16,  
and let <i><span style="font-family:sans-serif;"> count</span> = 3</i>.  The type map of  
the datatype returned by <font face="sans-serif"> newtype</font> is  
<p><i>{ (<tt> double</tt>, 0), (<tt> char</tt>, 8), (<tt> double</tt>, 16), 
   (<tt> char</tt>, 24), (<tt> double</tt>, 32), (<tt> char</tt>, 40) }; 
</i><p>  
i.e., alternating <tt> double</tt> and <tt> char</tt> elements, with displacements  
<i>0, 8, 16, 24, 32, 40</i>.  
  
<P> 
In general,  
assume that the type map of <font face="sans-serif"> oldtype</font> is  
<p><i>{ (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) } , 
</i><p>  
with extent <i>ex</i>.  
Then <font face="sans-serif"> newtype</font> has a type map with <i><span style="font-family:sans-serif;"> count</span> &#183; <span style="font-family:sans-serif;"> n</span></i>  
entries defined by:  
<P><img width=832 height=23 src="img2.gif" alt="Image file"><P>
  
<P><img width=762 height=23 src="img3.gif" alt="Image file"><P>
  
<P> 
<b> Vector.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_VECTOR</font> is a more general constructor that  
allows replication of a datatype  
into locations that consist of equally spaced blocks.  Each block  
is obtained by concatenating the same number of copies of the old datatype.  
The spacing between blocks is a multiple of the extent of the old datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_VECTOR(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of blocks (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> blocklength</TD><TD>number of elements in each block (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> stride</TD><TD>number of elements between start of each block (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_vector(int count, int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_vector_c(MPI_Count count, MPI_Count blocklength, MPI_Count stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_vector(count, blocklength, stride, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_vector(count, blocklength, stride, oldtype, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_VECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">STRIDE</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<br><b> Example</b>  
  
Assume, again, that <font face="sans-serif"> oldtype</font> has type map  
<i>{ (<tt> double</tt>, 0), (<tt> char</tt>, 8) } , 
</i>  
with extent 16.  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR</font><font face="sans-serif"> (2, 3, 4, oldtype, newtype)</font> will  
create the datatype with type map,  
<p><i>{ 
(<tt> double</tt>, 0), (<tt> char</tt>, 8), (<tt> double</tt>, 16), (<tt> char</tt>, 
24), (<tt> double</tt>, 32), (<tt> char</tt>, 40), 
</i><p>  
<p><i>(<tt> double</tt>, 64), (<tt> char</tt>, 72), (<tt> double</tt>, 80), (<tt> char</tt>, 
88), (<tt> double</tt>, 96), (<tt> char</tt>, 104) 
} . 
</i><p>  
That is, two blocks with three copies each of the old  
type, with a stride of 4 elements (<i>4 &#183; 16</i> bytes) between the start of each block.  
  
<P> 
<br><b> Example</b>  
  
A call to <font face="sans-serif"> MPI_TYPE_VECTOR</font><font face="sans-serif"> (3, 1, -2, oldtype, newtype)</font> will create  
the datatype,  
<p><i>{ 
(<tt> double</tt>, 0), (<tt> char</tt>, 8), (<tt> double</tt>, -32), (<tt> char</tt>, 
-24), (<tt> double</tt>, -64), (<tt> char</tt>, -56) 
} . 
</i><p>  
  
<P> 
In general, assume that <font face="sans-serif"> oldtype</font> has type map,  
<p><i>{ (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ..., (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) } , 
</i><p>  
with extent <i>ex</i>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<i><span style="font-family:sans-serif;"> count</span> &#183; <span style="font-family:sans-serif;"> bl</span> &#183; <span style="font-family:sans-serif;"> n</span></i><P> 
entries:  
<p><i>{ 
(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>), 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> ,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + ex) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + ex ), ..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + (<span style="font-family:sans-serif;"> bl</span> -1) &#183; ex 
) , ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + (<span style="font-family:sans-serif;"> bl</span> -1) &#183; ex ) , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> ,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; ex ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; ex ), ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + (<span style="font-family:sans-serif;"> stride</span> + <span style="font-family:sans-serif;"> bl</span> -1) &#183; ex ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + (<span style="font-family:sans-serif;"> stride</span> + <span style="font-family:sans-serif;"> bl</span> -1) &#183; 
ex ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> ,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span>-1) &#183; ex ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span> -1) &#183; 
ex ) 
, ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + (<span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span> -1) 
+ <span style="font-family:sans-serif;"> bl</span> -1) &#183; ex ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + (<span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span> -1) 
+ <span style="font-family:sans-serif;"> bl</span> -1) &#183; ex ) 
} . 
</i><p>  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_CONTIGUOUS</font><font face="sans-serif"> (count, oldtype, newtype)</font> is  
equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR</font><font face="sans-serif"> (count, 1, 1, oldtype, newtype)</font>, or to a call to  
<font face="sans-serif"> MPI_TYPE_VECTOR</font><font face="sans-serif"> (1, count, n, oldtype, newtype)</font>, where <font face="sans-serif"> n</font>  
is an arbitrary integer value.  
<P> 
<b> Hvector.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_CREATE_HVECTOR</font>  
is identical to  
<font face="sans-serif"> MPI_TYPE_VECTOR</font>, except that <font face="sans-serif"> stride</font> is given in bytes,  
rather than in elements.  The use for both types of vector  
constructors is illustrated in Section <a href="node112.htm#Node112">Examples</a>.  
(<font face="sans-serif"> H</font> stands for ``heterogeneous'').  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HVECTOR(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of blocks (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> blocklength</TD><TD>number of elements in each block (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> stride</TD><TD>number of bytes between start of each block (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_hvector(int count, int blocklength, MPI_Aint stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_hvector_c(MPI_Count count, MPI_Count blocklength, MPI_Count stride, MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_hvector(count, blocklength, stride, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">stride</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_hvector(count, blocklength, stride, oldtype, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">stride</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_HVECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE, NEWTYPE, IERROR) <br> INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">STRIDE</span> <br></tt>  
<P> 
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<p><i>{ (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ..., (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) } , 
</i><p>  
with extent <i>ex</i>.  Let <font face="sans-serif"> bl</font> be the <font face="sans-serif"> blocklength</font>.  
The newly created  datatype has a type map with  
<i><span style="font-family:sans-serif;"> count</span> &#183; <span style="font-family:sans-serif;"> bl</span> &#183; n</i><P> 
entries:  
<p><i>{ 
(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>), 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> ,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + ex) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + ex ), ..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + (<span style="font-family:sans-serif;"> bl</span> -1) &#183; ex 
) , ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + (<span style="font-family:sans-serif;"> bl</span> -1) &#183; ex ) , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> ,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> stride</span>  ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> stride</span> ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> stride</span> + ( <span style="font-family:sans-serif;"> bl</span> -1) &#183; ex 
) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> stride</span> + (<span style="font-family:sans-serif;"> bl</span> -1) &#183; 
ex ) , 
... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> ,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span>-1) ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span> -1)  ) 
, ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span> -1) 
+ (<span style="font-family:sans-serif;"> bl</span> -1) &#183; ex ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> stride</span> &#183; (<span style="font-family:sans-serif;"> count</span> -1) 
+ (<span style="font-family:sans-serif;"> bl</span> -1) &#183; ex ) 
} . 
</i><p>  
<P> 
<b> Indexed.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_INDEXED</font> allows  
replication of an old datatype into a sequence of blocks (each block is  
a concatenation of the old datatype), where  
each block can contain a different number of copies and have a different  
displacement.  All block displacements are multiples of the old type  
extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_INDEXED(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> and <font face="sans-serif"> array_of_blocklengths</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_blocklengths</TD><TD>number of elements per block (array of nonnegative integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_displacements</TD><TD>displacement for each block, in multiples of <font face="sans-serif"> oldtype</font> (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_indexed(int count, const int array_of_blocklengths[], const int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_indexed_c(MPI_Count count, const MPI_Count array_of_blocklengths[], const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_indexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_indexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_INDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_BLOCKLENGTHS(*)</span>, <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> oldtype</font> have type map  
<i>{ (<tt> double</tt>, 0), (<tt> char</tt>, 8) } , 
</i>  
with extent 16.  
Let  <font face="sans-serif"> B = (3, 1)</font> and let <font face="sans-serif"> D = (4, 0)</font>.  A call to  
<font face="sans-serif"> MPI_TYPE_INDEXED</font><font face="sans-serif"> (2, B, D, oldtype, newtype)</font> returns a datatype with  
type map,  
<p><i>{ 
(<tt> double</tt>, 64), (<tt> char</tt>, 72), (<tt> double</tt>, 80), (<tt> char</tt>, 
88), (<tt> double</tt>, 96), (<tt> char</tt>, 104), 
</i><p>  
<p><i>(<tt> double</tt>, 0), (<tt> char</tt>, 8) 
} . 
</i><p>  
That is, three copies of the old type starting at displacement  
64, and one copy starting at displacement 0.  
  
<P> 
In general,  
assume that <font face="sans-serif"> oldtype</font> has type map,  
<p><i>{ (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ..., (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) } , 
</i><p>  
with extent <em> ex</em>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklengths</font> argument and  
<font face="sans-serif"> D</font> be the  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has <i>n &#183; &sum;<SUB>i=0</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> count</span></span>-1</SUP> 
<span style="font-family:sans-serif;"> B[i]</span></i> entries:  
<p><i>{ 
(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> D[0]</span> &#183; ex ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> D[0]</span> &#183; ex ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + (<span style="font-family:sans-serif;"> D[0]</span> + <span style="font-family:sans-serif;"> B[0]</span> -1) &#183; ex) ,..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + (<span style="font-family:sans-serif;"> D[0]</span> +<span style="font-family:sans-serif;"> B[0]</span> -1) &#183; ex ) , 
..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> D[count-1]</span> &#183; ex ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> D[count-1]</span> &#183; ex ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + (<span style="font-family:sans-serif;"> D[count-1]</span> + <span style="font-family:sans-serif;"> B[count-1]</span> -1) &#183; ex) 
,..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + (<span style="font-family:sans-serif;"> D[count-1]</span> +<span style="font-family:sans-serif;"> B[count-1]</span> -1) 
&#183; ex ) 
} . 
</i><p>  
<P> 
A call to <font face="sans-serif"> MPI_TYPE_VECTOR</font><font face="sans-serif"> (count, blocklength, stride, oldtype,  
newtype)</font> is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_INDEXED</font><font face="sans-serif"> (count, B, D, oldtype, newtype)</font> where  
<P><img width=361 height=23 src="img4.gif" alt="Image file"><P>
  
and  
<P><img width=388 height=23 src="img5.gif" alt="Image file"><P>
  
<P> 
<b> Hindexed.</b>  
The procedure  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>  
is identical to  
<font face="sans-serif"> MPI_TYPE_INDEXED</font>, except that block displacements in  
<font face="sans-serif"> array_of_displacements</font> are specified in  
bytes, rather than in multiples of the <font face="sans-serif"> oldtype</font> extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HINDEXED(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> and <font face="sans-serif"> array_of_blocklengths</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_blocklengths</TD><TD>number of elements in each block (array of nonnegative integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_displacements</TD><TD>byte displacement of each block (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_hindexed(int count, const int array_of_blocklengths[], const MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_hindexed_c(MPI_Count count, const MPI_Count array_of_blocklengths[], const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_hindexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_hindexed(count, array_of_blocklengths, array_of_displacements, oldtype, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_HINDEXED(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br> INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_BLOCKLENGTHS(*)</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span> <br></tt>  
<P> 
Assume that <font face="sans-serif"> oldtype</font> has type map,  
<p><i>{ (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>,<span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB>), ..., (<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB>) } , 
</i><p>  
with extent <i>ex</i>.  
Let <font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklengths</font> argument and  
<font face="sans-serif"> D</font> be the  
<font face="sans-serif"> array_of_displacements</font> argument. The newly created datatype  
has a type map with  
<i>n &#183; &sum;<SUB>i=0</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> count</span></span>-1</SUP> 
<span style="font-family:sans-serif;"> B[i]</span></i> entries:  
<p><i>{ 
(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> D[0]</span>  ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> D[0]</span> ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> D[0]</span> +(<span style="font-family:sans-serif;"> B[0]</span> -1) &#183; ex) ,..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> D[0]</span> +(<span style="font-family:sans-serif;"> B[0]</span> -1) &#183; ex ) , 
..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB>, <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> D[count-1]</span> ) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> D[count-1]</span> ) , ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB> + <span style="font-family:sans-serif;"> D[count-1]</span> +(<span style="font-family:sans-serif;"> B[count-1]</span> -1) &#183; ex) 
,..., 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n-1</SUB> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n-1</SUB> + <span style="font-family:sans-serif;"> D[count-1]</span> +(<span style="font-family:sans-serif;"> B[count-1]</span> -1) 
&#183; ex ) 
} . 
</i><p>  
<P> 
<b> Indexed_block.</b>  
This procedure is the same as <font face="sans-serif"> MPI_TYPE_INDEXED</font> except that the  
blocklength is the same for all blocks.  
There are many codes using indirect addressing arising from  
unstructured grids where the blocksize is always 1 (gather/scatter).  The  
following convenience procedure allows for constant blocksize and arbitrary  
displacements.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_INDEXED_BLOCK(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> blocklength</TD><TD>number of elements in each block (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_displacements</TD><TD>array of displacements, in multiples of <font face="sans-serif"> oldtype</font> (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_indexed_block(int count, int blocklength, const int array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_indexed_block_c(MPI_Count count, MPI_Count blocklength, const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_indexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_indexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_INDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<b> Hindexed_block.</b>  
The procedure <font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED_BLOCK</font> is identical  
to <font face="sans-serif"> MPI_TYPE_CREATE_INDEXED_BLOCK</font>, except that block  
displacements in <font face="sans-serif"> array_of_displacements</font> are specified in  
bytes, rather than in multiples of the <font face="sans-serif"> oldtype</font> extent.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_HINDEXED_BLOCK(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">oldtype</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of blocks---also number of entries in <font face="sans-serif"> array_of_displacements</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> blocklength</TD><TD>number of elements in each block (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_displacements</TD><TD>byte displacement of each block (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> oldtype</TD><TD>old datatype (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_hindexed_block(int count, int blocklength, const MPI_Aint array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_hindexed_block_c(MPI_Count count, MPI_Count blocklength, const MPI_Count array_of_displacements[], MPI_Datatype oldtype, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_hindexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_hindexed_block(count, blocklength, array_of_displacements, oldtype, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">blocklength</span>, <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">oldtype</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_HINDEXED_BLOCK(COUNT, BLOCKLENGTH, ARRAY_OF_DISPLACEMENTS, OLDTYPE, NEWTYPE, IERROR) <br> INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">BLOCKLENGTH</span>, <span style="white-space:nowrap">OLDTYPE</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span> <br></tt>  
<P> 
<b> Struct.</b>  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT</font> is the most general type constructor.  
It further generalizes  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>  
in that it allows each block to consist of replications of  
different datatypes.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_STRUCT(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths</span>, <span style="white-space:nowrap">array_of_displacements</span>, <span style="white-space:nowrap">array_of_types</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of blocks---also number of entries in arrays <font face="sans-serif"> array_of_types</font>, <font face="sans-serif"> array_of_displacements</font>, and <font face="sans-serif"> array_of_blocklengths</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_blocklengths</TD><TD>number of elements in each block (array of nonnegative integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_displacements</TD><TD>byte displacement of each block (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> array_of_types</TD><TD>type of elements in each block (array of handles)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>new datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_struct(int count, const int array_of_blocklengths[], const MPI_Aint array_of_displacements[], const MPI_Datatype array_of_types[], MPI_Datatype *newtype) <br></tt>  
  
  <tt> int MPI_Type_create_struct_c(MPI_Count count, const MPI_Count array_of_blocklengths[], const MPI_Count array_of_displacements[], const MPI_Datatype array_of_types[], MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_struct(count, array_of_blocklengths, array_of_displacements, array_of_types, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">array_of_types(count)</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_create_struct(count, array_of_blocklengths, array_of_displacements, array_of_types, newtype, ierror) !(_c) <br> INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_blocklengths(count)</span>, <span style="white-space:nowrap">array_of_displacements(count)</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">array_of_types(count)</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS, ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR) <br> INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_BLOCKLENGTHS(*)</span>, <span style="white-space:nowrap">ARRAY_OF_TYPES(*)</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ARRAY_OF_DISPLACEMENTS(*)</span> <br></tt>  
<P> 
<br><b> Example</b>  
  
Let <font face="sans-serif"> type1</font> have type map,  
<p><i>{ (<tt> double</tt>, 0), (<tt> char</tt>, 8) } , 
</i><p>  
with extent 16.  
Let <font face="sans-serif"> B = (2, 1, 3)</font>, <font face="sans-serif"> D = (0, 16, 26)</font>,  
and <font face="sans-serif"> T = (MPI_FLOAT, type1, MPI_CHAR)</font>.  Then a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT(3, B, D, T, newtype)</font> returns  
a datatype with type map,  
<p><i>{ 
(<tt> float</tt>, 0), (<tt> float</tt>, 4), (<tt> double</tt>, 16), (<tt> char</tt>, 
24), (<tt> char</tt>, 26), (<tt> char</tt>, 27), (<tt> char</tt>, 28) 
} . 
</i><p>  
That is, two copies of <font face="sans-serif"> MPI_FLOAT</font> starting at 0, followed by  
one copy of <font face="sans-serif"> type1</font> starting at 16, followed by three copies of  
<font face="sans-serif"> MPI_CHAR</font>, starting at 26.  
In this example, we assume that a float occupies four bytes.  
  
<P> 
In general,  
let <font face="sans-serif"> T</font> be the <font face="sans-serif"> array_of_types</font> argument, where <font face="sans-serif"> T[i]</font>  
is a handle to,  
<p><i><span style="font-family:serif;"> <em>typemap</em></span><SUB>i</SUB> = { (<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB><SUP>i</SUP> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB><SUP>i</SUP> ) , ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>ni-1</SUB><SUP>i</SUP> , 
<span style="font-family:serif;"> <em>disp</em></span><SUB>ni-1</SUB><SUP>i</SUP> ) } , 
</i><p>  
with extent <i>ex<SUB>i</SUB></i>.  
Let  
<font face="sans-serif"> B</font> be the <font face="sans-serif"> array_of_blocklength</font> argument and <font face="sans-serif"> D</font> be  
the <font face="sans-serif"> array_of_displacements</font> argument.Let <font face="sans-serif"> c</font> be the  
<font face="sans-serif"> count</font> argument.  
Then the newly created datatype has a type map with  
<i>&sum;<SUB>i=0</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP><span style="font-family:sans-serif;"> B[i]</span> &#183; n<SUB>i</SUB></i><P> 
entries:  
<p><i>{ 
(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB><SUP>0</SUP> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB><SUP>0</SUP> +<span style="font-family:sans-serif;"> D[0]</span>) , ... , (<span style="font-family:serif;"> <em>type</em></span><SUB>n0</SUB><SUP>0</SUP> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n0</SUB><SUP>0</SUP> + 
<span style="font-family:sans-serif;"> D[0]</span> ) , 
... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB><SUP>0</SUP> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB><SUP>0</SUP> + <span style="font-family:sans-serif;"> D[0]</span> + (<span style="font-family:sans-serif;"> B[0]</span>-1) &#183; ex<SUB>0</SUB> ) , ... 
, 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n0</SUB><SUP>0</SUP> , <span style="font-family:serif;"> <em>disp</em></span><SUB>n0</SUB><SUP>0</SUP> + <span style="font-family:sans-serif;"> D[0]</span> + (<span style="font-family:sans-serif;"> B[0]-1)</span> &#183; 
ex<SUB>0</SUB> ) 
, ... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> +<span style="font-family:sans-serif;"> D[c-1]</span>) , ... , 
(<span style="font-family:serif;"> <em>type</em></span><SUB>n<span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1-1</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> , 
<span style="font-family:serif;"> <em>disp</em></span><SUB>n<span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1-1</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> + <span style="font-family:sans-serif;"> D[c-1]</span> ) , 
... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>0</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> , <span style="font-family:serif;"> <em>disp</em></span><SUB>0</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> + 
<span style="font-family:sans-serif;"> D[c-1]</span> + (<span style="font-family:sans-serif;"> B[c-1]</span>-1) &#183; ex<SUB><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUB> ) , 
... , 
</i><p>  
<p><i>(<span style="font-family:serif;"> <em>type</em></span><SUB>n<span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1-1</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> , 
<span style="font-family:serif;"> <em>disp</em></span><SUB>n<span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1-1</SUB><SUP><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUP> + <span style="font-family:sans-serif;"> D[c-1]</span> + 
(<span style="font-family:sans-serif;"> B[c-1]-1)</span> &#183; ex<SUB><span style="font-family:sans-serif;"> <span style="font-size:0.700em;"> c</span></span>-1</SUB> ) 
} . 
</i><p>  
<P> 
A call to  
<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font><font face="sans-serif"> (count, B, D, oldtype, newtype)</font>  
is equivalent to a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT</font><font face="sans-serif"> (count, B, D, T, newtype)</font>,  
where each entry of <font face="sans-serif"> T</font> is equal to <font face="sans-serif"> oldtype</font>.  
<P> 

<P>
<hr>
<a href="node99.htm#Node99"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node101.htm#Node101"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node101.htm#Node101"> Subarray Datatype Constructor</a>
<b>Previous: </b><a href="node99.htm#Node99"> Type Constructors with Explicit Addresses</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
