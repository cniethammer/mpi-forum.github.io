<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-io/io-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Data Access with Shared File Pointers</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node372">15.4.4. Data Access with Shared File Pointers</span></h2>
<a href="node371.htm#Node371"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node364.htm#Node364"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node372.htm#Node373"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node364.htm#Node364"> Data Access</a>
<b>Next: </b><a href="node372.htm#Node373"> Noncollective Operations</a>
<b>Previous: </b><a href="node371.htm#Node371"> Data Access with Individual File Pointers</a>
<p>
  
  
  
<P> 
<font face="sans-serif"> MPI</font> maintains exactly one shared file pointer  
per collective <font face="sans-serif"> MPI_FILE_OPEN</font>  
(shared among processes in the communicator group).  
The current value of this pointer implicitly specifies  
the offset in the data access routines described in this section.  
These routines only use and update the shared file pointer  
maintained by <font face="sans-serif"> MPI</font>.  
The individual file pointers are not used nor updated.  
<P> 
The shared file pointer routines  
have the same semantics as the data access with explicit offset routines  
described in Section <a href="node370.htm#Node370">Data Access with Explicit Offsets</a>,  
with the following modifications:  
<ul> 
 
<li>the <font face="sans-serif"> offset</font> is defined to be the current value  
        of the <font face="sans-serif"> MPI</font>-maintained shared file pointer,  
 
<li>the effect of multiple calls to shared file pointer routines  
        is defined to behave as if the calls were serialized, and  
 
<li>the use of shared file pointer routines is erroneous unless  
        all processes use the same file view.  
</ul> 
<br> 
For the noncollective shared file pointer routines,  
the  
serialization ordering is not deterministic.  
The user needs to use other synchronization means  
to enforce a specific order.  
<P> 
After a shared file pointer operation is initiated,  
the shared file pointer is updated to point to the next  
etype after the last one   
that will be accessed.  
The file pointer is updated relative to the current view of the file.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node371.htm#Node371"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node364.htm#Node364"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node372.htm#Node373"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node364.htm#Node364"> Data Access</a>
<b>Next: </b><a href="node372.htm#Node373"> Noncollective Operations</a>
<b>Previous: </b><a href="node371.htm#Node371"> Data Access with Individual File Pointers</a>
<p>
<hr><h3><span id="Node373">15.4.4.1. Noncollective Operations</span></h3>
<a href="node372.htm#Node372"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node372.htm#Node374"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<b>Next: </b><a href="node372.htm#Node374"> Collective Operations</a>
<b>Previous: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<p>
  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_READ_SHARED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_read_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_read_shared_c(MPI_File fh, void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_read_shared(fh, buf, count, datatype, status, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_read_shared(fh, buf, count, datatype, status, ierror) !(_c) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_READ_SHARED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_READ_SHARED</font> reads a file  
using the shared file pointer.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_WRITE_SHARED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_write_shared(MPI_File fh, const void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_write_shared_c(MPI_File fh, const void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_write_shared(fh, buf, count, datatype, status, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_write_shared(fh, buf, count, datatype, status, ierror) !(_c) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_WRITE_SHARED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_WRITE_SHARED</font> writes a file  
using the shared file pointer.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IREAD_SHARED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_iread_shared(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_File_iread_shared_c(MPI_File fh, void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_iread_shared(fh, buf, count, datatype, request, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_iread_shared(fh, buf, count, datatype, request, ierror) !(_c) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_IREAD_SHARED(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_IREAD_SHARED</font> is a nonblocking version  
of <font face="sans-serif"> MPI_FILE_READ_SHARED</font>.  
 <P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_IWRITE_SHARED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>request object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_iwrite_shared(MPI_File fh, const void *buf, int count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_File_iwrite_shared_c(MPI_File fh, const void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_iwrite_shared(fh, buf, count, datatype, request, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_iwrite_shared(fh, buf, count, datatype, request, ierror) !(_c) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_IWRITE_SHARED(FH, BUF, COUNT, DATATYPE, REQUEST, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_IWRITE_SHARED</font> is a nonblocking version  
of the <font face="sans-serif"> MPI_FILE_WRITE_SHARED</font> interface.  
<P> 

<P>
<hr>
<a href="node372.htm#Node372"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node372.htm#Node374"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<b>Next: </b><a href="node372.htm#Node374"> Collective Operations</a>
<b>Previous: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<p>
<hr><h3><span id="Node374">15.4.4.2. Collective Operations</span></h3>
<a href="node372.htm#Node373"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node372.htm#Node375"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<b>Next: </b><a href="node372.htm#Node375"> Seek</a>
<b>Previous: </b><a href="node372.htm#Node373"> Noncollective Operations</a>
<p>
  
  
  
  
<P> 
The semantics of collective access using a shared file pointer are  
that the accesses to the file will be  
in the order determined by the ranks of the processes  
within the group.  
For each process in the group, the location in the file at which data is accessed is the   
position at which the shared file pointer would be after all processes with   
ranks in the group less than that of this process had accessed their data.  
In addition, in order to prevent subsequent  
shared offset accesses by the same processes from interfering  
with this collective   
access, the call might return only after all the processes   
within the group have initiated their   
accesses.  
When the call returns, the shared file pointer points  
to the next etype accessible,  
according to the file view used by all processes,  
after the last etype requested.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
There may be some programs in which all processes in the  
group  
need to access the  
file using the shared file pointer, but the program may not <em> require</em>  
that data be accessed in order of process rank.  
In such programs, using the shared ordered routines  
(e.g., <font face="sans-serif"> MPI_FILE_WRITE_ORDERED</font>  
rather than <font face="sans-serif"> MPI_FILE_WRITE_SHARED</font>)  
may enable an implementation to optimize access, improving performance.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Accesses to the data requested by all processes do not have to be serialized.   
Once all processes have issued their requests, locations within the file for  
all accesses can be computed, and accesses can proceed independently from each  
other, possibly in parallel.  
 (<em> End of advice to implementors.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_READ_ORDERED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_read_ordered(MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_read_ordered_c(MPI_File fh, void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_read_ordered(fh, buf, count, datatype, status, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_read_ordered(fh, buf, count, datatype, status, ierror) !(_c) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..) :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_READ_ORDERED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_READ_ORDERED</font> is a collective version of the  
<font face="sans-serif"> MPI_FILE_READ_SHARED</font> interface.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_WRITE_ORDERED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements in buffer (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of each buffer element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_write_ordered(MPI_File fh, const void *buf, int count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  
  <tt> int MPI_File_write_ordered_c(MPI_File fh, const void *buf, MPI_Count count, MPI_Datatype datatype, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_write_ordered(fh, buf, count, datatype, status, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_File_write_ordered(fh, buf, count, datatype, status, ierror) !(_c) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>TYPE(*), DIMENSION(..), INTENT(IN) :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_WRITE_ORDERED(FH, BUF, COUNT, DATATYPE, STATUS, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span><br>&lt;type&gt; <span style="white-space:nowrap">BUF(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_WRITE_ORDERED</font> is a collective version of the  
<font face="sans-serif"> MPI_FILE_WRITE_SHARED</font> interface.  
<P> 

<P>
<hr>
<a href="node372.htm#Node373"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node372.htm#Node375"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<b>Next: </b><a href="node372.htm#Node375"> Seek</a>
<b>Previous: </b><a href="node372.htm#Node373"> Noncollective Operations</a>
<p>
<hr><h3><span id="Node375">15.4.4.3. Seek</span></h3>
<a href="node372.htm#Node374"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node376.htm#Node376"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<b>Next: </b><a href="node376.htm#Node376"> Split Collective Data Access Routines</a>
<b>Previous: </b><a href="node372.htm#Node374"> Collective Operations</a>
<p>
  
  
<P> 
If <font face="sans-serif"> MPI_MODE_SEQUENTIAL</font> mode was specified when the file was opened,  
it is erroneous to call the following two routines  
(<font face="sans-serif"> MPI_FILE_SEEK_SHARED</font> and <font face="sans-serif"> MPI_FILE_GET_POSITION_SHARED</font>).  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_SEEK_SHARED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">offset</span>, <span style="white-space:nowrap">whence</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> offset</TD><TD>file offset (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> whence</TD><TD>update mode (state)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_seek_shared(MPI_File fh, MPI_Offset offset, int whence) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_seek_shared(fh, offset, whence, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: <span style="white-space:nowrap">offset</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">whence</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_SEEK_SHARED(FH, OFFSET, WHENCE, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">WHENCE</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_OFFSET_KIND) <span style="white-space:nowrap">OFFSET</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_SEEK_SHARED</font> updates the shared file pointer according to   
<font face="sans-serif"> whence</font>,  
which has  
the following possible values:  
  
    <TABLE><TR><TD ALIGN="LEFT"> 
<li>[<font face="sans-serif"> MPI_SEEK_SET</font>]the pointer is set to <font face="sans-serif"> offset</font>  
 
<li>[<font face="sans-serif"> MPI_SEEK_CUR</font>]the pointer is set to the current pointer  
  position plus <font face="sans-serif"> offset</font>  
 
<li>[<font face="sans-serif"> MPI_SEEK_END</font>]the pointer is set to the end of file plus  
  <font face="sans-serif"> offset</font>  
</TD><TD></TD></TR></TABLE> 
<font face="sans-serif"> MPI_FILE_SEEK_SHARED</font> is collective;  
all the processes in the communicator group associated with the file  
handle <font face="sans-serif"> fh</font> must call <font face="sans-serif"> MPI_FILE_SEEK_SHARED</font> with the same  
values for  
<font face="sans-serif"> offset</font> and <font face="sans-serif"> whence</font>.  
 <P> 
The <font face="sans-serif"> offset</font> can be negative, which allows seeking backwards.  
It is erroneous to seek to a negative position in the view.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FILE_GET_POSITION_SHARED(<span style="white-space:nowrap">fh</span>, <span style="white-space:nowrap">offset</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> fh</TD><TD>file handle (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> offset</TD><TD>offset of shared pointer (integer)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_File_get_position_shared(MPI_File fh, MPI_Offset *offset) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_File_get_position_shared(fh, offset, ierror) <br> TYPE(MPI_File), INTENT(IN) :: <span style="white-space:nowrap">fh</span><br>INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: <span style="white-space:nowrap">offset</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FILE_GET_POSITION_SHARED(FH, OFFSET, IERROR) <br> INTEGER <span style="white-space:nowrap">FH</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_OFFSET_KIND) <span style="white-space:nowrap">OFFSET</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_FILE_GET_POSITION_SHARED</font> returns, in <font face="sans-serif"> offset</font>,  
the current position of the shared file pointer in etype units  
relative to the current  
view.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The <font face="sans-serif"> offset</font> can be used in a future call  
to <font face="sans-serif"> MPI_FILE_SEEK_SHARED</font>  
using <font face="sans-serif"> whence = </font><font face="sans-serif"> MPI_SEEK_SET</font> to return to the current position.  
To set the displacement to the current file pointer position,  
first convert <font face="sans-serif"> offset</font> into an absolute byte position using  
<font face="sans-serif"> MPI_FILE_GET_BYTE_OFFSET</font>,  
then call <font face="sans-serif"> MPI_FILE_SET_VIEW</font> with the resulting  
displacement.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node372.htm#Node374"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node372.htm#Node372"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node376.htm#Node376"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node372.htm#Node372"> Data Access with Shared File Pointers</a>
<b>Next: </b><a href="node376.htm#Node376"> Split Collective Data Access Routines</a>
<b>Previous: </b><a href="node372.htm#Node374"> Collective Operations</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
