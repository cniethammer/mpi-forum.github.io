<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Accumulate Functions</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node322">13.3.4. Accumulate Functions</span></h2>
<a href="node321.htm#Node321"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node318.htm#Node318"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node323"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node318.htm#Node318"> Communication Calls</a>
<b>Next: </b><a href="node322.htm#Node323"> Accumulate</a>
<b>Previous: </b><a href="node321.htm#Node321"> Examples for Communication Calls</a>
<p>
  
<P> 
It is often useful in a put operation to combine the data moved to the  
target process with the data that resides at that <font face="sans-serif"> MPI</font> process, rather  
than replacing it.  
This will allow, for example, the  
accumulation of  
a sum by having all involved <font face="sans-serif"> MPI</font> processes add their  
contributions to the  
sum variable in the memory of one <font face="sans-serif"> MPI</font> process.  
The accumulate functions have slightly different  
semantics with respect to overlapping data accesses than  
the put and get functions; see Section <a href="node339.htm#Node339">Semantics and Correctness</a>  
for details.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node321.htm#Node321"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node318.htm#Node318"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node323"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node318.htm#Node318"> Communication Calls</a>
<b>Next: </b><a href="node322.htm#Node323"> Accumulate</a>
<b>Previous: </b><a href="node321.htm#Node321"> Examples for Communication Calls</a>
<p>
<hr><h3><span id="Node323">13.3.4.1. Accumulate</span></h3>
<a href="node322.htm#Node322"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node324"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node322.htm#Node324"> Get Accumulate</a>
<b>Previous: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<p>
<TABLE><TR><TD COLSPAN=2>MPI_ACCUMULATE(<span style="white-space:nowrap">origin_addr</span>, <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_disp</span>, <span style="white-space:nowrap">target_count</span>, <span style="white-space:nowrap">target_datatype</span>, <span style="white-space:nowrap">op</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_addr</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_count</TD><TD>number of entries in buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_datatype</TD><TD>datatype of each entry (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_rank</TD><TD>rank of target (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_disp</TD><TD>displacement from start of window to beginning of target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_count</TD><TD>number of entries in target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_datatype</TD><TD>datatype of each entry in target buffer (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> op</TD><TD>accumulate operator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Accumulate(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win) <br></tt>  
  
  <tt> int MPI_Accumulate_c(const void *origin_addr, MPI_Count origin_count, MPI_Datatype origin_datatype, int target_rank, MPI_Aint target_disp, MPI_Count target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Accumulate(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, op, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">target_datatype</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Op), INTENT(IN) :: <span style="white-space:nowrap">op</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Accumulate(origin_addr, origin_count, origin_datatype, target_rank, target_disp, target_count, target_datatype, op, win, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">target_count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">target_datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">target_rank</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Op), INTENT(IN) :: <span style="white-space:nowrap">op</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_ACCUMULATE(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">ORIGIN_ADDR(*)</span><br>INTEGER <span style="white-space:nowrap">ORIGIN_COUNT</span>, <span style="white-space:nowrap">ORIGIN_DATATYPE</span>, <span style="white-space:nowrap">TARGET_RANK</span>, <span style="white-space:nowrap">TARGET_COUNT</span>, <span style="white-space:nowrap">TARGET_DATATYPE</span>, <span style="white-space:nowrap">OP</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">TARGET_DISP</span> <br></tt>  
<P> 
Accumulate the contents of the origin buffer  
(as defined by <font face="sans-serif"> origin_addr</font>,  
<font face="sans-serif"> origin_count</font>, and   
<font face="sans-serif"> origin_datatype</font>)  
to the buffer specified by arguments <font face="sans-serif"> target_count</font> and  
<font face="sans-serif"> target_datatype</font>,  
at offset <font face="sans-serif"> target_disp</font>, in  
the target window specified by <font face="sans-serif"> target_rank</font> and <font face="sans-serif"> win</font>,  
using the operator  
<font face="sans-serif"> op</font>.  
This is like <font face="sans-serif"> MPI_PUT</font> except that data is combined into  
the target area instead of overwriting it.  
<P> 
Any of the predefined operators for <font face="sans-serif"> MPI_REDUCE</font> can be  
used.  User-defined operators cannot be used.  
For example, if <font face="sans-serif"> op</font> is <font face="sans-serif"> MPI_SUM</font>,  
each element of the origin buffer is added to the corresponding element  
in the target, replacing the former value in the target.  
<P> 
Each datatype argument must be a predefined datatype or a derived  
datatype, where all basic components are of the same predefined  
datatype.  Both datatype arguments must be constructed from the same  
predefined datatype.  
The operator <font face="sans-serif"> op</font> applies to elements of that predefined  
type. The parameter <font face="sans-serif"> target_datatype</font> must not specify overlapping   
entries, and the target buffer must fit in the target window.  
<P> 
An additional predefined operator, <font face="sans-serif"> MPI_REPLACE</font>, is defined.  
It corresponds to the associative function <i>f(a,b) = b</i>; i.e., the current  
value in the target memory is replaced by the value supplied by the  
origin.  
<P> 
<font face="sans-serif"> MPI_REPLACE</font> can be used only in <font face="sans-serif"> MPI_ACCUMULATE</font>,  
<font face="sans-serif"> MPI_RACCUMULATE</font>,  
  <font face="sans-serif"> MPI_GET_ACCUMULATE</font>, <font face="sans-serif"> MPI_FETCH_AND_OP</font>, and  
  <font face="sans-serif"> MPI_RGET_ACCUMULATE</font>, but not in collective  
reduction operations such as <font face="sans-serif"> MPI_REDUCE</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_PUT</font> can be considered a special case of <font face="sans-serif"> MPI_ACCUMULATE</font>  
with the  operator <font face="sans-serif"> MPI_REPLACE</font>.  
Note, however, that <font face="sans-serif"> MPI_PUT</font> and <font face="sans-serif"> MPI_ACCUMULATE</font>  
have different constraints on concurrent updates.  
 (<em> End of advice to users.</em>) <br> 
<br><b> Example</b>  
  
[Accumulate in <font face="sans-serif"> RMA</font>]FortranAccumulate in RMA@Accumulate in <font face="sans-serif"> RMA</font>MPI_Win_create,MPI_Type_get_extent,MPI_Win_fence,MPI_Accumulate,MPI_Win_freeWe want to compute <i><tt>B(j)</tt> = &sum;<SUB><tt><span style="font-size:0.700em;">map(i)</tt> =</span> <tt><span style="font-size:0.700em;">j</tt></span></SUB> <tt>A(i)</tt></i>.  
The arrays  
<tt>A</tt>, <tt>B</tt>, and <tt>map</tt> are  
distributed in the same manner.  We write  
the simple version.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>SUBROUTINE</b> SUM(A, B, map, m, comm, p) 
<b>USE</b> MPI 
<b>INTEGER</b> m, map(m), comm, p, win, ierr, disp_int, i, j 
<b>REAL</b> A(m), B(m) 
<b>INTEGER</b>(<b>KIND</b>=<b>MPI_ADDRESS_KIND</b>) lowerbound, size, realextent, disp_aint 
 
<b>CALL</b> <b>MPI_TYPE_GET_EXTENT</b>(<b>MPI_REAL</b>, lowerbound, realextent, ierr) 
size = m * realextent 
disp_int = realextent 
<b>CALL</b> <b>MPI_WIN_CREATE</b>(B, size, disp_int, <b>MPI_INFO_NULL</b>,  &amp; 
                    comm, win, ierr) 
 
<b>CALL</b> <b>MPI_WIN_FENCE</b>(0, win, ierr) 
<b>DO</b> i=1,m 
   j = map(i)/m 
   disp_aint = MOD(map(i),m) 
   <b>CALL</b> <b>MPI_ACCUMULATE</b>(A(i), 1, <b>MPI_REAL</b>, j, disp_aint, 1, <b>MPI_REAL</b>,   &amp; 
                       <b>MPI_SUM</b>, win, ierr) 
<b>END</b> <b>DO</b> 
<b>CALL</b> <b>MPI_WIN_FENCE</b>(0, win, ierr) 
 
<b>CALL</b> <b>MPI_WIN_FREE</b>(win, ierr) 
<b>RETURN</b> 
<b>END</b> 
</tt></pre> 
  
<P> 
This code is identical to the code in  
Example <a href="node321.htm#Node321">Examples for Communication Calls</a>,  
except that a call to <font face="sans-serif"> MPI_GET</font> has been  
replaced by a call to <font face="sans-serif"> MPI_ACCUMULATE</font>.  (Note that, if <tt>map</tt> is  
one-to-one, the code computes <i><tt>B</tt> = 
<tt>A(map</tt><SUP>-1</SUP><tt>)</tt></i>, which is the   
reverse assignment to the one computed in that previous example.)  
In a similar manner, we can replace  
in Example <a href="node321.htm#Node321">Examples for Communication Calls</a>,  
the call to get by a call to accumulate,  
thus  
performing the computation with only one communication between any  
two <font face="sans-serif"> MPI</font> processes.  
  
<P> 

<P>
<hr>
<a href="node322.htm#Node322"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node324"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node322.htm#Node324"> Get Accumulate</a>
<b>Previous: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<p>
<hr><h3><span id="Node324">13.3.4.2. Get Accumulate</span></h3>
<a href="node322.htm#Node323"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node325"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node322.htm#Node325"> Fetch and Op</a>
<b>Previous: </b><a href="node322.htm#Node323"> Accumulate</a>
<p>
  
<P> 
It is often useful to have fetch-and-accumulate semantics such that  
the remote data is returned to the caller before the sent data is  
accumulated into the remote data.  The get and accumulate  
steps are executed atomically for each basic element in the datatype  
(see Section <a href="node339.htm#Node339">Semantics and Correctness</a> for details).  
The predefined operator <font face="sans-serif"> MPI_REPLACE</font> provides fetch-and-set  
behavior.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_GET_ACCUMULATE(<span style="white-space:nowrap">origin_addr</span>, <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">result_addr</span>, <span style="white-space:nowrap">result_count</span>, <span style="white-space:nowrap">result_datatype</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_disp</span>, <span style="white-space:nowrap">target_count</span>, <span style="white-space:nowrap">target_datatype</span>, <span style="white-space:nowrap">op</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_addr</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_count</TD><TD>number of entries in origin buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_datatype</TD><TD>datatype of each entry in origin buffer (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> result_addr</TD><TD>initial address of result buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> result_count</TD><TD>number of entries in result buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> result_datatype</TD><TD>datatype of each entry in result buffer (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_rank</TD><TD>rank of target (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_disp</TD><TD>displacement from start of window to beginning of target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_count</TD><TD>number of entries in target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_datatype</TD><TD>datatype of each entry in target buffer (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> op</TD><TD>accumulate operator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Get_accumulate(const void *origin_addr, int origin_count, MPI_Datatype origin_datatype, void *result_addr, int result_count, MPI_Datatype result_datatype, int target_rank, MPI_Aint target_disp, int target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win) <br></tt>  
  
  <tt> int MPI_Get_accumulate_c(const void *origin_addr, MPI_Count origin_count, MPI_Datatype origin_datatype, void *result_addr, MPI_Count result_count, MPI_Datatype result_datatype, int target_rank, MPI_Aint target_disp, MPI_Count target_count, MPI_Datatype target_datatype, MPI_Op op, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Get_accumulate(origin_addr, origin_count, origin_datatype, result_addr, result_count, result_datatype, target_rank, target_disp, target_count, target_datatype, op, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">result_count</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">result_datatype</span>, <span style="white-space:nowrap">target_datatype</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">result_addr</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Op), INTENT(IN) :: <span style="white-space:nowrap">op</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Get_accumulate(origin_addr, origin_count, origin_datatype, result_addr, result_count, result_datatype, target_rank, target_disp, target_count, target_datatype, op, win, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">origin_count</span>, <span style="white-space:nowrap">result_count</span>, <span style="white-space:nowrap">target_count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">origin_datatype</span>, <span style="white-space:nowrap">result_datatype</span>, <span style="white-space:nowrap">target_datatype</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">result_addr</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">target_rank</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Op), INTENT(IN) :: <span style="white-space:nowrap">op</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_GET_ACCUMULATE(ORIGIN_ADDR, ORIGIN_COUNT, ORIGIN_DATATYPE, RESULT_ADDR, RESULT_COUNT, RESULT_DATATYPE, TARGET_RANK, TARGET_DISP, TARGET_COUNT, TARGET_DATATYPE, OP, WIN, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">ORIGIN_ADDR(*)</span>, <span style="white-space:nowrap">RESULT_ADDR(*)</span><br>INTEGER <span style="white-space:nowrap">ORIGIN_COUNT</span>, <span style="white-space:nowrap">ORIGIN_DATATYPE</span>, <span style="white-space:nowrap">RESULT_COUNT</span>, <span style="white-space:nowrap">RESULT_DATATYPE</span>, <span style="white-space:nowrap">TARGET_RANK</span>, <span style="white-space:nowrap">TARGET_COUNT</span>, <span style="white-space:nowrap">TARGET_DATATYPE</span>, <span style="white-space:nowrap">OP</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">TARGET_DISP</span> <br></tt>  
<P> 
Accumulate <font face="sans-serif"> origin_count</font> elements of type <font face="sans-serif"> origin_datatype</font> from   
the origin buffer (<font face="sans-serif"> origin_addr</font>) to the buffer at offset  
<font face="sans-serif"> target_disp</font>, in the target window specified by  
<font face="sans-serif"> target_rank</font> and <font face="sans-serif"> win</font>, using the operator <font face="sans-serif"> op</font>  
and return in the result buffer <font face="sans-serif"> result_addr</font> the content  
of the target buffer before the accumulation, specified by  
<font face="sans-serif"> target_disp</font>, <font face="sans-serif"> target_count</font>, and  
<font face="sans-serif"> target_datatype</font>.  
The data transferred from origin to target must fit, without  
truncation, in the target buffer.  Likewise, the data copied from target to  
origin must fit, without truncation, in the result buffer.  
<P> 
The origin and result buffers (<font face="sans-serif"> origin_addr</font> and  
<font face="sans-serif"> result_addr</font>) must be disjoint.   
Each datatype argument must be a predefined datatype or a derived  
datatype where all basic components are of the same predefined  
datatype.  All datatype arguments must be constructed from the same  
predefined datatype.  
The operator <font face="sans-serif"> op</font> applies to elements of that predefined  
type. <font face="sans-serif"> target_datatype</font> must not specify overlapping   
entries, and the target buffer must fit in the target window or in  
attached memory in a dynamic window.  
The operation is executed atomically for each basic datatype; see  
Section <a href="node339.htm#Node339">Semantics and Correctness</a> for details.  
<P> 
Any of the predefined operators for <font face="sans-serif"> MPI_REDUCE</font>,  
as well as  
<font face="sans-serif"> MPI_NO_OP</font> or <font face="sans-serif"> MPI_REPLACE</font> can be specified as  
<font face="sans-serif"> op</font>.  User-defined functions cannot be used.   
An additional predefined operator, <font face="sans-serif"> MPI_NO_OP</font>, is defined.  
It corresponds to the associative function <i>f(a,b) = a</i>; i.e., the current  
value in the target memory is returned in the result buffer at the  
origin and the target buffer is not updated.  
If <font face="sans-serif"> MPI_NO_OP</font> is specified as the operator, the  
<font face="sans-serif"> origin_addr</font>,  
<font face="sans-serif"> origin_count</font>, and <font face="sans-serif"> origin_datatype</font> arguments are ignored.  
<font face="sans-serif"> MPI_NO_OP</font> can be used only in <font face="sans-serif"> MPI_GET_ACCUMULATE</font>,  
<font face="sans-serif"> MPI_RGET_ACCUMULATE</font>, and <font face="sans-serif"> MPI_FETCH_AND_OP</font>.  
<font face="sans-serif"> MPI_NO_OP</font> cannot be used  
in <font face="sans-serif"> MPI_ACCUMULATE</font>, <font face="sans-serif"> MPI_RACCUMULATE</font>, or collective  
reduction operations, such as <font face="sans-serif"> MPI_REDUCE</font> and others.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<font face="sans-serif"> MPI_GET</font> is similar to   
<font face="sans-serif"> MPI_GET_ACCUMULATE</font>,  
with the  operator <font face="sans-serif"> MPI_NO_OP</font>.  
Note, however, that <font face="sans-serif"> MPI_GET</font> and  
<font face="sans-serif"> MPI_GET_ACCUMULATE</font>  
have different constraints on concurrent updates.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node322.htm#Node323"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node325"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node322.htm#Node325"> Fetch and Op</a>
<b>Previous: </b><a href="node322.htm#Node323"> Accumulate</a>
<p>
<hr><h3><span id="Node325">13.3.4.3. Fetch and Op</span></h3>
<a href="node322.htm#Node324"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node326"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node322.htm#Node326"> Compare and Swap</a>
<b>Previous: </b><a href="node322.htm#Node324"> Get Accumulate</a>
<p>
  
<P> 
The generic functionality of <font face="sans-serif"> MPI_GET_ACCUMULATE</font> might  
limit the performance of fetch-and-increment or fetch-and-add  
calls that might be supported by special hardware operations.  
<font face="sans-serif"> MPI_FETCH_AND_OP</font> thus allows for a fast implementation of  
a commonly used subset of the functionality of  
<font face="sans-serif"> MPI_GET_ACCUMULATE</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_FETCH_AND_OP(<span style="white-space:nowrap">origin_addr</span>, <span style="white-space:nowrap">result_addr</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_disp</span>, <span style="white-space:nowrap">op</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_addr</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> result_addr</TD><TD>initial address of result buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of the entry in origin, result, and target buffers (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_rank</TD><TD>rank of target (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_disp</TD><TD>displacement from start of window to beginning of target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> op</TD><TD>accumulate operator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Fetch_and_op(const void *origin_addr, void *result_addr, MPI_Datatype datatype, int target_rank, MPI_Aint target_disp, MPI_Op op, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Fetch_and_op(origin_addr, result_addr, datatype, target_rank, target_disp, op, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">result_addr</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">target_rank</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Op), INTENT(IN) :: <span style="white-space:nowrap">op</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_FETCH_AND_OP(ORIGIN_ADDR, RESULT_ADDR, DATATYPE, TARGET_RANK, TARGET_DISP, OP, WIN, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">ORIGIN_ADDR(*)</span>, <span style="white-space:nowrap">RESULT_ADDR(*)</span><br>INTEGER <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">TARGET_RANK</span>, <span style="white-space:nowrap">OP</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">TARGET_DISP</span> <br></tt>  
<P> 
Accumulate one element of type <font face="sans-serif"> datatype</font> from the origin buffer  
<font face="sans-serif"> origin_addr</font> to the buffer at offset <font face="sans-serif"> target_disp</font>,  
in the target window specified by <font face="sans-serif"> target_rank</font> and  
<font face="sans-serif"> win</font>, using the operator <font face="sans-serif"> op</font> and return in the result  
buffer <font face="sans-serif"> result_addr</font> the content of the target buffer before the  
accumulation.  
<P> 
The origin and result buffers (<font face="sans-serif"> origin_addr</font> and  
<font face="sans-serif"> result_addr</font>) must be disjoint.  
Any of the predefined operators for <font face="sans-serif"> MPI_REDUCE</font>, as well as  
<font face="sans-serif"> MPI_NO_OP</font> or <font face="sans-serif"> MPI_REPLACE</font>, can be specified as  
<font face="sans-serif"> op</font>; user-defined functions cannot be used.   
The <font face="sans-serif"> datatype</font> argument must be a predefined datatype.  
The operation is executed atomically.  
<P> 

<P>
<hr>
<a href="node322.htm#Node324"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node322.htm#Node326"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node322.htm#Node326"> Compare and Swap</a>
<b>Previous: </b><a href="node322.htm#Node324"> Get Accumulate</a>
<p>
<hr><h3><span id="Node326">13.3.4.4. Compare and Swap</span></h3>
<a href="node322.htm#Node325"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node327.htm#Node327"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node327.htm#Node327"> Request-based <font face="sans-serif"> RMA</font> Communication Operations</a>
<b>Previous: </b><a href="node322.htm#Node325"> Fetch and Op</a>
<p>
  
<P> 
Another useful operation is an atomic compare and swap where the  
value at the origin is compared to the value at the target,  
which is atomically replaced by a third value only  
if the values at origin and target are equal.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_COMPARE_AND_SWAP(<span style="white-space:nowrap">origin_addr</span>, <span style="white-space:nowrap">compare_addr</span>, <span style="white-space:nowrap">result_addr</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">target_rank</span>, <span style="white-space:nowrap">target_disp</span>, <span style="white-space:nowrap">win</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> origin_addr</TD><TD>initial address of buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> compare_addr</TD><TD>initial address of compare buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> result_addr</TD><TD>initial address of result buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype of the element in all buffers (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_rank</TD><TD>rank of target (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> target_disp</TD><TD>displacement from start of window to beginning of target buffer (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> win</TD><TD>window object (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Compare_and_swap(const void *origin_addr, const void *compare_addr, void *result_addr, MPI_Datatype datatype, int target_rank, MPI_Aint target_disp, MPI_Win win) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Compare_and_swap(origin_addr, compare_addr, result_addr, datatype, target_rank, target_disp, win, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">origin_addr</span>, <span style="white-space:nowrap">compare_addr</span><br>TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">result_addr</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">target_rank</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: <span style="white-space:nowrap">target_disp</span><br>TYPE(MPI_Win), INTENT(IN) :: <span style="white-space:nowrap">win</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_COMPARE_AND_SWAP(ORIGIN_ADDR, COMPARE_ADDR, RESULT_ADDR, DATATYPE, TARGET_RANK, TARGET_DISP, WIN, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">ORIGIN_ADDR(*)</span>, <span style="white-space:nowrap">COMPARE_ADDR(*)</span>, <span style="white-space:nowrap">RESULT_ADDR(*)</span><br>INTEGER <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">TARGET_RANK</span>, <span style="white-space:nowrap">WIN</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">TARGET_DISP</span> <br></tt>  
<P> 
<P> 
This function compares one element of type <font face="sans-serif"> datatype</font> in the  
compare buffer <font face="sans-serif"> compare_addr</font> with the buffer at offset  
<font face="sans-serif"> target_disp</font> in the target window specified by  
<font face="sans-serif"> target_rank</font> and <font face="sans-serif"> win</font> and replaces the  
value at the target with the value in the origin buffer  
<font face="sans-serif"> origin_addr</font> if the compare buffer and the   
target buffer are identical.  
The original value at the target is returned  
in the buffer <font face="sans-serif"> result_addr</font>. The parameter <font face="sans-serif"> datatype</font>  
must belong to one of the following categories of predefined datatypes: C integer, Fortran  
integer, Logical, Multi-language types, or Byte as specified in  
Section <a href="node133.htm#Node133">Predefined Reduction Operations</a>.  
The origin and result buffers (<font face="sans-serif"> origin_addr</font> and  
<font face="sans-serif"> result_addr</font>) must be disjoint.   
<P> 

<P>
<hr>
<a href="node322.htm#Node325"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node322.htm#Node322"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node327.htm#Node327"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node322.htm#Node322"> Accumulate Functions</a>
<b>Next: </b><a href="node327.htm#Node327"> Request-based <font face="sans-serif"> RMA</font> Communication Operations</a>
<b>Previous: </b><a href="node322.htm#Node325"> Fetch and Op</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
