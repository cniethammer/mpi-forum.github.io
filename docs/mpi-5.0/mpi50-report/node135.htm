<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-coll/coll-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>MINLOC and MAXLOC</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node135">7.9.4. MINLOC and MAXLOC</span></h2>
<a href="node134.htm#Node134"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node131.htm#Node131"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node136.htm#Node136"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node131.htm#Node131"> Global Reduction Operations</a>
<b>Next: </b><a href="node136.htm#Node136"> User-Defined Reduction Operations</a>
<b>Previous: </b><a href="node134.htm#Node134"> Signed Characters and Reductions</a>
<p>
  
<P> 
The operator <font face="sans-serif"> MPI_MINLOC</font> is used to compute  
a global minimum and also  
an index attached to the minimum value.  
<font face="sans-serif"> MPI_MAXLOC</font> similarly computes a global maximum and index.  
One application of these is to compute a global minimum (maximum) and the  
rank of the <font face="sans-serif"> MPI</font> process containing this value.  
<P> 
The operation that defines <font face="sans-serif"> MPI_MAXLOC</font> is:  
<P> 
<P><img width=245 height=62 src="img25.gif" alt="Image file"><P>
  
where  
<p><i>w = <tt> max</tt> (u,v) 
</i><p>  
and  
<P><img width=251 height=87 src="img26.gif" alt="Image file"><P>
  
<P> 
<font face="sans-serif"> MPI_MINLOC</font> is defined similarly:  
<P> 
<P><img width=245 height=62 src="img27.gif" alt="Image file"><P>
  
where  
<p><i>w = <tt> min</tt> (u,v) 
</i><p>  
and  
<P><img width=251 height=87 src="img28.gif" alt="Image file"><P>
  
<P> 
Both operations are associative and commutative.  
Note that if <font face="sans-serif"> MPI_MAXLOC</font>  
is applied to reduce a sequence of pairs  
<i>(u<SUB>0</SUB>, 0), (u<SUB>1</SUB>, 1) , ..., (u<SUB>n-1</SUB> , n-1)</i>, then the value  
returned is <i>(u , r)</i>, where <i>u = <tt> max</tt><SUB>i</SUB> u<SUB>i</SUB></i> and <i>r</i> is the index of  
the first global maximum in the sequence.  Thus, if each <font face="sans-serif"> MPI</font> process  
supplies a value and its rank within the group, then a reduce  
operation with <font face="sans-serif"> op</font> = <font face="sans-serif"> MPI_MAXLOC</font> will return the  
maximum value and the rank of the first <font face="sans-serif"> MPI</font> process with that value.  
Similarly, <font face="sans-serif"> MPI_MINLOC</font> can be used to return a minimum and its  
index.  
More generally, <font face="sans-serif"> MPI_MINLOC</font> computes a <em> lexicographic  
minimum</em>, where elements are ordered according to the first component  
of each pair, and ties are resolved according to the second component.  
<P> 
The reduce operation is defined to operate on arguments that  
consist of a pair: value and index.  
For both Fortran and C, types are provided to describe the pair.  
The potentially mixed-type nature of such arguments  
is a problem in older versions of Fortran.  The problem is circumvented there by  
having the <font face="sans-serif"> MPI</font>-provided type consist of a pair of the same type as  
value, and coercing the index to this type also.  In C, the <font face="sans-serif"> MPI</font>-provided  
pair type has distinct types and the index is an integer type. For  
named predefined pair types in C the index is of type <tt>int</tt>.  
For unnamed predefined pair types, other integer types are allowed as  
index instead.  
To use pair types with distinct value and index in Fortran, these types need to be defined using <tt>BIND(C)</tt> and be equivalent to the corresponding C struct.  
<P> 
In order to use <font face="sans-serif"> MPI_MINLOC</font> and <font face="sans-serif"> MPI_MAXLOC</font> in a  
reduce operation, one must provide a <font face="sans-serif"> datatype</font> argument  
that represents a pair (value and index).  <font face="sans-serif"> MPI</font> provides  
nine  
such named predefined datatypes as well as the function <font face="sans-serif"> MPI_TYPE_GET_VALUE_INDEX</font> to query named and unnamed predefined types using value type and index type.  The operations <font face="sans-serif"> MPI_MAXLOC</font> and  
<font face="sans-serif"> MPI_MINLOC</font> can be used with each of the following named datatypes.  
  
    <TABLE><TR><TD ALIGN="LEFT">Fortran:</TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
Name</TD><TD ALIGN="LEFT">Description</TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_2REAL</font></TD><TD ALIGN="LEFT">pair of <tt> REAL</tt>s</TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_2DOUBLE_PRECISION</font></TD><TD ALIGN="LEFT">pair of <tt> DOUBLE PRECISION</tt> variables</TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_2INTEGER</font></TD><TD ALIGN="LEFT">pair of <tt> INTEGER</tt>s</TD></TR> 
<TR><TD ALIGN="LEFT"></TD><TD></TD></TR></TABLE> 
  
    <TABLE><TR><TD ALIGN="LEFT">C:</TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
Name</TD><TD ALIGN="LEFT">Description</TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_FLOAT_INT</font></TD><TD ALIGN="LEFT"><tt> float</tt> and <tt> int</tt></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_DOUBLE_INT</font></TD><TD ALIGN="LEFT"><tt> double</tt> and <tt> int</tt></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_LONG_INT</font></TD><TD ALIGN="LEFT"><tt> long</tt> and <tt> int</tt></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_2INT</font></TD><TD ALIGN="LEFT">pair of <tt> int</tt> </TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_SHORT_INT</font></TD><TD ALIGN="LEFT"><tt> short</tt> and <tt> int</tt> </TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_LONG_DOUBLE_INT</font></TD><TD ALIGN="LEFT"><tt> long double</tt> and <tt> int</tt> </TD></TR> 
<TR><TD ALIGN="LEFT"></TD><TD></TD></TR></TABLE> 
The datatype <font face="sans-serif"> MPI_2REAL</font> is <em> as if</em> defined by the following  
(see Section <a href="node98.htm#Node98">Derived Datatypes</a>).  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>call</b> <b>MPI_Type_contiguous</b>(2, <b>MPI_REAL</b>, <b>MPI_2REAL</b>, ierror) 
</tt></pre> 
  
<P> 
Similar statements apply for <font face="sans-serif"> MPI_2INTEGER</font>,  
<font face="sans-serif"> MPI_2DOUBLE_PRECISION</font>, and <font face="sans-serif"> MPI_2INT</font>.  
<P> 
The datatype <font face="sans-serif"> MPI_SHORT_INT</font> is <em> as if</em> defined by the  
following sequence of instructions.  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>struct</b> mystruct { 
    <b>short</b> val; 
    <b>int</b> rank; 
}; 
type[0] = <b>MPI_SHORT</b>; 
type[1] = <b>MPI_INT</b>; 
disp[0] = 0; 
disp[1] = offsetof(<b>struct</b> mystruct, rank); 
block[0] = 1; 
block[1] = 1; 
<b>MPI_Type_create_struct</b>(2, block, disp, type, &amp;<b>MPI_SHORT_INT</b>); 
<b>MPI_Type_commit</b>(&amp;<b>MPI_SHORT_INT</b>); 
</tt></pre> 
  
Similar statements apply for <font face="sans-serif"> MPI_FLOAT_INT</font>, <font face="sans-serif"> MPI_LONG_INT</font>  
and <font face="sans-serif"> MPI_DOUBLE_INT</font>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_VALUE_INDEX(<span style="white-space:nowrap">value_type</span>, <span style="white-space:nowrap">index_type</span>, <span style="white-space:nowrap">pair_type</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> value_type</TD><TD>datatype of the value in pair (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> index_type</TD><TD>datatype of the index in pair (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> pair_type</TD><TD>datatype of the value-index pair (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_get_value_index(MPI_Datatype value_type, MPI_Datatype index_type, MPI_Datatype *pair_type) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_get_value_index(value_type, index_type, pair_type, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">value_type</span>, <span style="white-space:nowrap">index_type</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">pair_type</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_GET_VALUE_INDEX(VALUE_TYPE, INDEX_TYPE, PAIR_TYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">VALUE_TYPE</span>, <span style="white-space:nowrap">INDEX_TYPE</span>, <span style="white-space:nowrap">PAIR_TYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_TYPE_GET_VALUE_INDEX</font> returns a handle to a predefined datatype suitable for the use with <font face="sans-serif"> MPI_MINLOC</font> and <font face="sans-serif"> MPI_MAXLOC</font> if such a predefined type exists.  
If the provided combination of <font face="sans-serif"> value_type</font> and <font face="sans-serif"> index_type</font> does not match a predefined pair datatype (named or unnamed), the function will set <font face="sans-serif"> pair_type</font> to <font face="sans-serif"> MPI_DATATYPE_NULL</font> and return <font face="sans-serif"> MPI_SUCCESS</font>.  
The returned type is not a duplicate.  
This type cannot be freed.  
Types supported by the underlying compiler for which the operators <font face="sans-serif"> MPI_MIN</font> and <font face="sans-serif"> MPI_MAX</font> are defined in Section <a href="node133.htm#Node133">Predefined Reduction Operations</a> are acceptable value types.  
Integer types supported by the underlying compiler are acceptable index types.  
<P> 
  
 
<br> 
<em> Advice to users.</em>  
<P> 
Note that a named type handle returned by <font face="sans-serif"> MPI_TYPE_GET_VALUE_INDEX</font> will yield the combiner value <font face="sans-serif"> MPI_COMBINER_NAMED</font> when queried with <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> to ensure backward compatibility to existing behavior, whereas all unnamed type handles returned by <font face="sans-serif"> MPI_TYPE_GET_VALUE_INDEX</font> will yield the combiner value <font face="sans-serif"> MPI_COMBINER_VALUE_INDEX</font> when queried with <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font>.  
    There is no observable difference between the named constant value used via its symbol name or via <font face="sans-serif"> MPI_TYPE_GET_VALUE_INDEX</font>.  
    Code evaluating the combiner of type handles returned from <font face="sans-serif"> MPI_TYPE_GET_VALUE_INDEX</font> must therefore handle both <font face="sans-serif"> MPI_COMBINER_NAMED</font> and <font face="sans-serif"> MPI_COMBINER_VALUE_INDEX</font>.  
 (<em> End of advice to users.</em>) <br> 
  
<P> 
<br><b> Example</b>  
  
  
An unnamed predefined value-index type is retrieved for use with the corresponding C struct.  
If the requested value-index pair does not exist as a predefined type <font face="sans-serif"> MPI_DATATYPE_NULL</font> is returned.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>    <b>struct</b> mystruct { 
        <b>double</b> val; 
        uint64_t index; 
    }; 
 
    <b>MPI_Datatype</b> dtype; 
    <b>MPI_Type_get_value_index</b>(<b>MPI_DOUBLE</b>, <b>MPI_UINT64_T</b>, &amp;dtype); 
 
    <b>if</b> (dtype == <b>MPI_DATATYPE_NULL</b>) { 
        // Handling <b>for</b> unsupported value-index type 
    } 
</tt></pre> 
  
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Implementations may apply certain optimizations to operations on compound types with equally sized value and index types. Such optimizations may not be applicable to operations on compound types where value and index type are of different size.  
 (<em> End of advice to users.</em>) <br> 
The following examples use intra-communicators.  
<P> 
<br><b> Example</b>  
  
Each <font face="sans-serif"> MPI</font> process has an array of 30 <tt> double</tt>s, in C.  For each  
of the 30 locations, compute the value and rank of the <font face="sans-serif"> MPI</font> process containing  
the largest value.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>... 
/* each MPI process has an array of 30 <b>double</b>: ain[30] 
 */ 
<b>double</b> ain[30], aout[30]; 
<b>int</b>  ind[30]; 
<b>struct</b> { 
    <b>double</b> val; 
    <b>int</b>   rank; 
} in[30], out[30]; 
<b>int</b> i, myrank, root; 
 
<b>MPI_Comm_rank</b>(comm, &amp;myrank); 
<b>for</b> (i=0; i&lt;30; ++i) { 
    in[i].val = ain[i]; 
    in[i].rank = myrank; 
} 
<b>MPI_Reduce</b>(in, out, 30, <b>MPI_DOUBLE_INT</b>, <b>MPI_MAXLOC</b>, root, comm); 
/* At this point, the answer resides on root MPI process 
 */ 
<b>if</b> (myrank == root) { 
    /* read ranks out 
     */ 
    <b>for</b> (i=0; i&lt;30; ++i) { 
        aout[i] = out[i].val; 
        ind[i] = out[i].rank; 
    } 
} 
</tt></pre> 
  
  
<P> 
<br><b> Example</b>  
  
Same example, in Fortran.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>... 
! each process has an array of 30 <b>double</b>: ain(30) 
 
<b>DOUBLE</b> <b>PRECISION</b> ain(30), aout(30) 
<b>INTEGER</b> ind(30) 
<b>DOUBLE</b> <b>PRECISION</b> in(2,30), out(2,30) 
<b>INTEGER</b> i, myrank, root, ierr 
 
<b>CALL</b> <b>MPI_COMM_RANK</b>(comm, myrank, ierr) 
<b>DO</b> i=1,30 
   in(1,i) = ain(i) 
   in(2,i) = myrank    ! myrank is coerced to a <b>double</b> 
<b>END</b> <b>DO</b> 
 
<b>CALL</b> <b>MPI_REDUCE</b>(in, out, 30, <b>MPI_2DOUBLE_PRECISION</b>, <b>MPI_MAXLOC</b>, root,&amp; 
                comm, ierr) 
! At this point, the answer resides on root MPI process 
 
<b>IF</b> (myrank .EQ. root) <b>THEN</b> 
   ! <b>read</b> ranks out 
   <b>DO</b> i=1,30 
      aout(i) = out(1,i) 
      ind(i) = out(2,i)  ! rank is coerced back to an <b>integer</b> 
   <b>END</b> <b>DO</b> 
<b>END</b> <b>IF</b> 
</tt></pre> 
  
  
<P> 
<br><b> Example</b>  
  
Each <font face="sans-serif"> MPI</font> process has a nonempty array of values.  
Find the minimum global value, the rank of the <font face="sans-serif"> MPI</font> process that holds it  
and its index on this <font face="sans-serif"> MPI</font> process.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>#define</b>  LEN   1000 
 
<b>float</b> val[LEN];        /* local array of values */ 
<b>int</b> count;             /* local number of values */ 
<b>int</b> myrank, minrank, minindex; 
<b>float</b> minval; 
 
<b>struct</b> { 
    <b>float</b> value; 
    <b>int</b>   index; 
} in, out; 
 
/* local minloc */ 
in.value = val[0]; 
in.index = 0; 
<b>for</b> (i=1; i &lt; count; i++) { 
    <b>if</b> (in.value &gt; val[i]) { 
        in.value = val[i]; 
        in.index = i; 
    } 
} 
/* global minloc */ 
<b>MPI_Comm_rank</b>(comm, &amp;myrank); 
in.index = myrank*LEN + in.index; 
<b>MPI_Reduce</b>(&amp;in, &amp;out, 1, <b>MPI_FLOAT_INT</b>, <b>MPI_MINLOC</b>, root, comm); 
 
/* At this point, the answer resides on the root */ 
<b>if</b> (myrank == root) { 
    /* read answer out */ 
    minval = out.value; 
    minrank = out.index / LEN; 
    minindex = out.index % LEN; 
} 
</tt></pre> 
  
  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The definition of <font face="sans-serif"> MPI_MINLOC</font> and <font face="sans-serif"> MPI_MAXLOC</font> given  
here has the advantage that it does not require any special-case  
handling of these two operations: they are handled like any other  
reduce operation.  By assigning a value other than <tt>myrank</tt> to the <tt>in.index</tt> field, a programmer can provide a different definition  
of <font face="sans-serif"> MPI_MAXLOC</font> and <font face="sans-serif"> MPI_MINLOC</font>, if so desired.  
The disadvantage is that values and indices have to be first  
interleaved, and that indices and values have to be coerced to the  
same type, in Fortran.  
 (<em> End of rationale.</em>) <br> 

<P>
<hr>
<a href="node134.htm#Node134"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node131.htm#Node131"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node136.htm#Node136"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node131.htm#Node131"> Global Reduction Operations</a>
<b>Next: </b><a href="node136.htm#Node136"> User-Defined Reduction Operations</a>
<b>Previous: </b><a href="node134.htm#Node134"> Signed Characters and Reductions</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
