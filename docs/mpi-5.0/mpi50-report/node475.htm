<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Additional Support for Fortran Numeric Intrinsic Types</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node475">20.1.9. Additional Support for Fortran Numeric Intrinsic Types</span></h2>
<a href="node474.htm#Node474"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node466.htm#Node466"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node475.htm#Node476"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node466.htm#Node466"> Support for Fortran</a>
<b>Next: </b><a href="node475.htm#Node476"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<b>Previous: </b><a href="node474.htm#Node474"> Additional Support for Fortran Register-Memory-Synchronization</a>
<p>
  
<P> 
<font face="sans-serif"> MPI</font>  
provides a small number of named datatypes that correspond to  
named intrinsic types supported by C and Fortran. These include  
<font face="sans-serif"> MPI_INTEGER</font>, <font face="sans-serif"> MPI_REAL</font>, <font face="sans-serif"> MPI_INT</font>,  
<font face="sans-serif"> MPI_DOUBLE</font>, etc., as well as the optional types  
<font face="sans-serif"> MPI_REAL4</font>, <font face="sans-serif"> MPI_REAL8</font>, etc.  There is a one-to-one  
correspondence between language declarations and <font face="sans-serif"> MPI</font> types.  
<P> 
Fortran (starting with Fortran 90) provides so-called <tt>KIND</tt>-parameterized  
types. These types are declared using an intrinsic type (one of  
<tt> INTEGER</tt>, <tt> REAL</tt>, <tt> COMPLEX</tt>, <tt> LOGICAL</tt>, and  
<tt> CHARACTER</tt>) with an optional integer  
<tt>KIND</tt> parameter that selects from among one or more variants.  
The specific meaning of different <tt>KIND</tt> values themselves are  
implementation dependent and not specified by the language.  
Fortran  
provides the <tt>KIND</tt> selection functions <tt>selected_real_kind</tt>  
for <tt> REAL</tt> and <tt> COMPLEX</tt> types, and  
<tt>selected_int_kind</tt> for <tt> INTEGER</tt> types  
that allow users to declare variables  
with a minimum precision or number of digits. These functions provide  
a portable way to declare <tt>KIND</tt>-parameterized <tt> REAL</tt>,  
<tt> COMPLEX</tt>, and <tt> INTEGER</tt> variables in Fortran.  
This scheme is backward compatible with Fortran 77. <tt> REAL</tt> and  
<tt> INTEGER</tt> Fortran variables have a default <tt>KIND</tt> if none  
is specified. Fortran <tt> DOUBLE PRECISION</tt> variables are of  
intrinsic type <tt> REAL</tt> with a nondefault <tt>KIND</tt>. The following  
two declarations are equivalent:  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>double</b> <b>precision</b> x 
<b>real</b>(<b>KIND</b>(0.0d0)) x 
</tt></pre> 
  
<P> 
<font face="sans-serif"> MPI</font> provides two orthogonal methods for handling communication  
buffers of  
numeric intrinsic types. The first method  
(see the following section)  
can be used when  
variables have been declared in a portable way---using  
default <tt>KIND</tt> or using <tt>KIND</tt> parameters obtained with  
the <tt>selected_int_kind</tt> or <tt>selected_real_kind</tt>  
functions. With this method, <font face="sans-serif"> MPI</font> automatically  
selects the correct data size (e.g., 4 or 8 bytes) and  
provides representation conversion in heterogeneous  
environments.  The second method  
(see ``<a href="node475.htm#Node477">Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>''  
on page <a href="node475.htm#Node477">Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>)  
gives the user complete  
control over communication by exposing machine representations.  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node474.htm#Node474"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node466.htm#Node466"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node475.htm#Node476"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node466.htm#Node466"> Support for Fortran</a>
<b>Next: </b><a href="node475.htm#Node476"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<b>Previous: </b><a href="node474.htm#Node474"> Additional Support for Fortran Register-Memory-Synchronization</a>
<p>
<hr><h3><span id="Node476">20.1.9.1. Parameterized Datatypes with Specified Precision and Exponent Range</span></h3>
<a href="node475.htm#Node475"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node475.htm#Node475"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node475.htm#Node477"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node475.htm#Node477"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<b>Previous: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<p>
<font face="sans-serif"> MPI</font>  
provides named datatypes corresponding to standard Fortran 77  
numeric types: <font face="sans-serif"> MPI_INTEGER</font>, <font face="sans-serif"> MPI_COMPLEX</font>,  
<font face="sans-serif"> MPI_REAL</font>, <font face="sans-serif"> MPI_DOUBLE_PRECISION</font> and <font face="sans-serif"> MPI_DOUBLE_COMPLEX</font>.  
<font face="sans-serif"> MPI</font> automatically selects the correct data size and provides  
representation conversion in heterogeneous environments. The  
mechanism described in this section extends this model  
to support portable parameterized numeric types.  
<P> 
The model for supporting portable parameterized types is as follows.  
Real variables are declared (perhaps indirectly) using  
<tt>selected_real_kind(p, r)</tt> to determine the <tt>KIND</tt> parameter, where  
<tt>p</tt> is decimal digits of precision and <tt>r</tt> is an exponent range.  
Implicitly <font face="sans-serif"> MPI</font> maintains  
a two-dimensional array of predefined <font face="sans-serif"> MPI</font> datatypes <tt>D(p, r)</tt>.  
<tt>D(p, r)</tt> is defined for each value of <tt>(p, r)</tt> supported  
by the compiler, including pairs for which one value is unspecified.  
Attempting to access an element of the array with an index <tt>(p, r)</tt> not  
supported by the compiler is erroneous.  
<font face="sans-serif"> MPI</font> implicitly maintains a similar array of <tt> COMPLEX</tt> datatypes.  
For integers, there is a similar implicit array related to  
<tt>selected_int_kind</tt> and indexed by  
the requested number of digits <tt>r</tt>. Note that the predefined datatypes  
contained in these implicit arrays are not the same as the named  
<font face="sans-serif"> MPI</font> datatypes <font face="sans-serif"> MPI_REAL</font>, etc., but a new set.  
<P> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The above description is for explanatory purposes only. It is not  
expected that implementations will have such internal arrays.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
<tt>selected_real_kind()</tt> maps a large number of <tt>(p,r)</tt> pairs  
to a much smaller number of <tt>KIND</tt> parameters supported by the compiler.  
<tt>KIND</tt> parameters are not specified by the language and are not  
portable.  From the language point of view intrinsic types of the  
same base type and <tt>KIND</tt> parameter are of the same type.  
In order to allow interoperability in a heterogeneous environment,  
<font face="sans-serif"> MPI</font> is more stringent. The corresponding <font face="sans-serif"> MPI</font> datatypes match if  
and only if they have the same <tt>(p,r)</tt> value (<tt> REAL</tt> and <tt> COMPLEX</tt>) or  
<tt>r</tt> value (<tt> INTEGER</tt>). Thus <font face="sans-serif"> MPI</font> has many more datatypes than  
there are fundamental language types.  
 (<em> End of advice to users.</em>) <br> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_REAL(<span style="white-space:nowrap">p</span>, <span style="white-space:nowrap">r</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> p</TD><TD>precision, in decimal digits (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> r</TD><TD>decimal exponent range (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_f90_real(int p, int r, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_f90_real(p, r, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">p</span>, <span style="white-space:nowrap">r</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_F90_REAL(P, R, NEWTYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">P</span>, <span style="white-space:nowrap">R</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> REAL</tt> variable  
of <tt>KIND</tt> <tt>selected_real_kind(p, r)</tt>. In the model described above  
it returns a handle for the element <tt>D(p, r)</tt>.  
Either <tt>p</tt> or <tt>r</tt> may be omitted from calls to  
<tt>selected_real_kind(p, r)</tt> (but not both).  Analogously, either  
<tt>p</tt> or <tt>r</tt> may be set to <font face="sans-serif"> MPI_UNDEFINED</font>.  
In communication, an <font face="sans-serif"> MPI</font> datatype <tt>A</tt> returned by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font> matches a datatype <tt>B</tt>  
if and only if <tt>B</tt> was returned by <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>  
called with the same values for <tt>p</tt> and <tt>r</tt> or <tt>B</tt>  
is a duplicate of such a datatype.  
Restrictions on using the returned datatype with the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font>  
data  
representation are given on page <a href="node475.htm#Node476">Parameterized Datatypes with Specified Precision and Exponent Range</a>.  
<P> 
It is erroneous to supply values for <font face="sans-serif"> p</font> and <font face="sans-serif"> r</font> not  
supported by the compiler.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_COMPLEX(<span style="white-space:nowrap">p</span>, <span style="white-space:nowrap">r</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> p</TD><TD>precision, in decimal digits (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> r</TD><TD>decimal exponent range (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_f90_complex(int p, int r, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_f90_complex(p, r, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">p</span>, <span style="white-space:nowrap">r</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_F90_COMPLEX(P, R, NEWTYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">P</span>, <span style="white-space:nowrap">R</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches a <tt> COMPLEX</tt> variable  
of <tt>KIND</tt> <tt>selected_real_kind(p, r)</tt>.  
Either <tt>p</tt> or <tt>r</tt> may be omitted from calls to  
<tt>selected_real_kind(p, r)</tt> (but not both).  Analogously, either  
<tt>p</tt> or <tt>r</tt> may be set to <font face="sans-serif"> MPI_UNDEFINED</font>.  
Matching rules for datatypes created by this function are  
analogous to the matching rules for datatypes created by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
Restrictions on using the returned datatype with the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font>  
data  
representation are given on page <a href="node475.htm#Node476">Parameterized Datatypes with Specified Precision and Exponent Range</a>.  
<P> 
It is erroneous to supply values for <font face="sans-serif"> p</font> and <font face="sans-serif"> r</font> not  
supported by the compiler.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_CREATE_F90_INTEGER(<span style="white-space:nowrap">r</span>, <span style="white-space:nowrap">newtype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> r</TD><TD>decimal exponent range, i.e., number of decimal digits (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> newtype</TD><TD>the requested <font face="sans-serif"> MPI</font> datatype (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_create_f90_integer(int r, MPI_Datatype *newtype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_create_f90_integer(r, newtype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">r</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">newtype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_CREATE_F90_INTEGER(R, NEWTYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">R</span>, <span style="white-space:nowrap">NEWTYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
This function returns a predefined <font face="sans-serif"> MPI</font> datatype that matches an <tt> INTEGER</tt> variable  
of <tt>KIND</tt> <tt>selected_int_kind(r)</tt>.  
Matching rules for datatypes created by this function are  
analogous to the matching rules for datatypes created by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
Restrictions on using the returned datatype with the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font>  
data  
representation are given on page <a href="node475.htm#Node476">Parameterized Datatypes with Specified Precision and Exponent Range</a>.  
<P> 
It is erroneous to supply a value for <font face="sans-serif"> r</font> that is not  
supported by the compiler.  
<P> 
<br><b> Example</b>  
Fortran selected integer and real kind buffers in <font face="sans-serif"> MPI</font> communications.  
  
[Fortran 90, with selected <tt> KIND</tt>]FortranFortran 90!selected KIND@selected <tt> KIND</tt>MPI_TYPE_CREATE_F90_INTEGER,MPI_TYPE_CREATE_F90_REAL<br> 
<pre style="background-color:#EFEFEF"><tt><b>integer</b>       longtype, quadtype 
<b>integer</b>, parameter :: long = selected_int_kind(15) 
<b>integer</b>(long) ii(10) 
<b>real</b>(selected_real_kind(30)) x(10) 
<b>call</b> <b>MPI_TYPE_CREATE_F90_INTEGER</b>(15, longtype, ierror) 
<b>call</b> <b>MPI_TYPE_CREATE_F90_REAL</b>(30, <b>MPI_UNDEFINED</b>, quadtype, ierror) 
... 
 
<b>call</b> <b>MPI_SEND</b>(ii, 10, longtype, ...) 
<b>call</b> <b>MPI_SEND</b>(x,  10, quadtype, ...) 
</tt></pre> 
  
  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The datatypes returned by the procedures in Example <a href="node475.htm#Node476">Parameterized Datatypes with Specified Precision and Exponent Range</a> are  
predefined datatypes. They cannot be freed; they do not need to be  
committed; they can be used with predefined reduction operations.  
There are two situations in which they behave differently syntactically,  
but not semantically, from the <font face="sans-serif"> MPI</font> named predefined datatypes.  
<ol> 
 
1. <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> returns special  
combiners that allow a program to retrieve the values of  
<font face="sans-serif"> p</font> and <font face="sans-serif"> r</font>.  
 
<br> 
2. Because the datatypes are not named, they cannot  
be used as compile-time initializers or otherwise  
accessed before a call to one of the <font face="sans-serif"> MPI_TYPE_CREATE_F90_ XXX</font>  
routines.  
</ol> 
If a variable was declared specifying a nondefault <tt>KIND</tt> value that was  
not obtained with  <tt>selected_real_kind()</tt> or  
<tt>selected_int_kind()</tt>, the only way to obtain a matching  
<font face="sans-serif"> MPI</font> datatype is to use the size-based mechanism described  
in the next section.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
An application may often repeat a call to  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_ XXX</font> with the same combination of  
(<font face="sans-serif">  XXX</font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>).  
The application is not allowed to free the returned predefined, unnamed  
datatype handles. To prevent the creation of a potentially huge amount of handles,  
a high quality  
<font face="sans-serif"> MPI</font> implementation should return the same datatype handle for  
the same  
(<font face="sans-serif"> REAL</font>/<font face="sans-serif"> COMPLEX</font>/ <font face="sans-serif"> INTEGER</font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>)  
combination.  
Checking for the  
combination (<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>) in the preceding call to  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_ XXX</font> and  
using a hash table to find formerly generated handles should limit the  
overhead of finding a previously generated datatype with same combination  
of (<font face="sans-serif">  XXX</font>,<font face="sans-serif"> p</font>,<font face="sans-serif"> r</font>).  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
The <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL/COMPLEX/INTEGER</font> interface  
needs as input the original range and precision values to be able to  
define useful and compiler-independent  
external (Section <a href="node379.htm#Node379">External Data Representation: <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font></a>)  
or user-defined (Section <a href="node380.htm#Node380">User-Defined Data Representations</a>) data representations, and in  
order to be able to perform automatic and efficient data conversions in a  
heterogeneous environment.  
 (<em> End of rationale.</em>) <br> 
We now specify how the datatypes described in this section  
behave when used with the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font> external data representation  
described in Section <a href="node379.htm#Node379">External Data Representation: <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font></a>.  
<P> 
The <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font> representation specifies data formats for integer  
and floating point values. Integer values are represented in two's complement  
big-endian format. Floating point values are represented by one  
of three IEEE formats. These are the IEEE ``Single,'' ``Double,'' and  
``Double Extended'' formats, requiring 4, 8, and 16 bytes of storage,  
respectively.  
For the IEEE ``Double Extended'' formats, <font face="sans-serif"> MPI</font> specifies a  
Format Width of 16 bytes, with 15 exponent bits, bias = +10383,  
112 fraction bits, and an encoding analogous to the ``Double'' format.  
<P> 
The <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font> representations of the datatypes returned by  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL/COMPLEX/INTEGER</font>  
are given by the following rules.  
<br>  
  
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>:  
<br> 
<pre><tt>   if      (p &gt; 33) or (r &gt; 4931) then  external32 representation 
                                        is undefined 
   else if (p &gt; 15) or (r &gt;  307) then  external32_size = 16 
   else if (p &gt;  6) or (r &gt;   37) then  external32_size =  8 
   else                                 external32_size =  4 
</tt></pre> 
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_COMPLEX</font>: twice the size  
as for<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>.  
<br>  
For <font face="sans-serif"> MPI_TYPE_CREATE_F90_INTEGER</font>:  
<br> 
<pre><tt>   if      (r &gt; 38) then  external32 representation is undefined 
   else if (r &gt; 18) then  external32_size =  16 
   else if (r &gt;  9) then  external32_size =  8 
   else if (r &gt;  4) then  external32_size =  4 
   else if (r &gt;  2) then  external32_size =  2 
   else                   external32_size =  1 
</tt></pre> 
If the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font> representation of  
a datatype is undefined, the result of using the datatype directly  
or indirectly (i.e., as part of another datatype or through a  
duplicated datatype) in operations that require the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font>  
representation is undefined. These operations include <font face="sans-serif"> MPI_PACK_EXTERNAL</font>,  
<font face="sans-serif"> MPI_UNPACK_EXTERNAL</font>, and many <font face="sans-serif"> MPI_FILE</font>  
functions, when the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font> data representation is used.  
The ranges for which the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font> representation is undefined are  
reserved for future standardization.  
<P> 

<P>
<hr>
<a href="node475.htm#Node475"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node475.htm#Node475"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node475.htm#Node477"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node475.htm#Node477"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<b>Previous: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<p>
<hr><h3><span id="Node477">20.1.9.2. Support for Size-specific  MPI Datatypes</span></h3>
<a href="node475.htm#Node476"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node475.htm#Node475"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node475.htm#Node478"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node475.htm#Node478"> Communication With Size-specific Types</a>
<b>Previous: </b><a href="node475.htm#Node476"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<p>
  
<P> 
<font face="sans-serif"> MPI</font>  
provides named datatypes corresponding to optional Fortran 77  
numeric types that contain explicit byte lengths---<font face="sans-serif"> MPI_REAL4</font>,  
<font face="sans-serif"> MPI_INTEGER8</font>, etc. This section describes a mechanism  
that generalizes this model to support all Fortran numeric  
intrinsic types.  
<P> 
We assume that for each <b> typeclass</b> (integer, real, complex) and each  
word size <b> n</b> there is a unique machine representation.  
For every pair (<b> typeclass</b>, <b> n</b>) supported by a compiler,  
<font face="sans-serif"> MPI</font> must provide a named size-specific datatype.  
The name of this datatype is of the form  
<font face="sans-serif"> <span style="font-size:0.900em;"> MPI_<i>&lt;</i>TYPECLASS<i>&gt;&lt;</i><b> n</b><i>&gt;</i></span></font> in C and  
Fortran where <font face="sans-serif"> <span style="font-size:0.900em;"> <i>&lt;</i>TYPECLASS<i>&gt;</i></span></font> is one of  
<tt> REAL</tt>, <tt> INTEGER</tt>, or <tt> COMPLEX</tt>,and <font face="sans-serif"> <span style="font-size:0.900em;"> <i>&lt;</i><b> n</b><i>&gt;</i></span></font> is the length in bytes of the  
machine representation.  This datatype locally matches all variables  
of type (<b> typeclass</b>, <b> n</b>) in Fortran.  The list of names for such types  
includes:  
  
    <TABLE><TR><TD ALIGN="LEFT"><font face="sans-serif"> MPI_REAL4</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_REAL8</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_REAL16</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_COMPLEX8</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_COMPLEX16</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_COMPLEX32</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_INTEGER1</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_INTEGER2</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_INTEGER4</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_INTEGER8</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_INTEGER16</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_LOGICAL1</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_LOGICAL2</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_LOGICAL4</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_LOGICAL8</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT">  
<font face="sans-serif"> MPI_LOGICAL16</font></TD><TD ALIGN="LEFT"></TD><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD></TR> 
<TR><TD ALIGN="LEFT"></TD><TD></TD></TR></TABLE> 
One  
datatype is required for each representation supported by  
the Fortran compiler.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
Particularly for the longer floating-point types, C and Fortran may  
  use different representations. For example, a Fortran compiler may  
  define a 16-byte <tt> REAL</tt> type with 33 decimal digits of  
  precision while a C compiler may define a 16-byte <tt> long  
    double</tt> type that implements an 80-bit (10 byte) extended  
  precision floating point value. Both of these types are 16 bytes  
  long, but they are not interoperable. Thus, these types are defined  
  by Fortran, even though C may define types of the same length.  
 (<em> End of rationale.</em>) <br> 
To be backward compatible with the interpretation of  
these types in <font face="sans-serif"> MPI-1</font>, we assume that the nonstandard declarations  
<tt> REAL*n</tt>, <tt> INTEGER*n</tt>, <tt> LOGICAL*n</tt>, always create a variable whose  
representation is of size <b> n</b>.  
These datatypes may also be used for variables declared with  
<tt> KIND=INT8/16/32/64</tt> or <tt> KIND=REAL32/64/128</tt>,  
which are defined in the <tt> ISO_FORTRAN_ENV</tt> intrinsic module.  
Note that the <font face="sans-serif"> MPI</font> datatypes and the <tt> REAL*n</tt>, <tt> INTEGER*n</tt>  
<tt> LOGICAL*n</tt>  
declarations count bytes whereas  
the Fortran <tt> KIND</tt> values count bits.  
All these datatypes are predefined.  
<P> 
The following function allows a user to obtain a size-specific <font face="sans-serif"> MPI</font> datatype  
for any intrinsic Fortran type.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_MATCH_SIZE(<span style="white-space:nowrap">typeclass</span>, <span style="white-space:nowrap">size</span>, <span style="white-space:nowrap">datatype</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> typeclass</TD><TD>generic type specifier (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> size</TD><TD>size, in bytes, of representation (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> datatype</TD><TD>datatype with correct type, size (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_match_size(int typeclass, int size, MPI_Datatype *datatype) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_match_size(typeclass, size, datatype, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">typeclass</span>, <span style="white-space:nowrap">size</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_MATCH_SIZE(TYPECLASS, SIZE, DATATYPE, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">TYPECLASS</span>, <span style="white-space:nowrap">SIZE</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> typeclass</font> is one of <font face="sans-serif"> MPI_TYPECLASS_REAL</font>,  
<font face="sans-serif"> MPI_TYPECLASS_INTEGER</font>, and  
<font face="sans-serif"> MPI_TYPECLASS_COMPLEX</font>,  
corresponding to the  desired <b> typeclass</b>.  The function returns  
an <font face="sans-serif"> MPI</font> datatype matching a local variable of type (<b> typeclass</b>,  
<b> size</b>).  
<P> 
This function  
returns a reference (handle) to one of the predefined named  
datatypes, not a duplicate. This type cannot be freed.  
<font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> can be used to obtain a size-specific type that  
matches a Fortran numeric intrinsic type by first calling  
<font face="sans-serif"> storage_size()</font> in order to compute the variable size in bits,  
dividing it by eight, and then  
calling <font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> to find a suitable  
datatype.  
In C,  
one can use the C operator <font face="sans-serif"> sizeof()</font> (which returns the size  
in bytes) instead of <font face="sans-serif"> storage_size()</font> (which returns the size in  
bits).  
In addition, for variables of default kind  
the variable's size can be computed by a call to  
<font face="sans-serif"> MPI_TYPE_GET_EXTENT</font>, if the <tt>typeclass</tt> is known.  
It is erroneous to specify a size not supported by the compiler.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
This is a convenience function. Without it, it can be tedious to  
find the correct named type. See note to implementors below.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
This function could be implemented as a series of tests.  
<br><b> Example</b>  
Example of an implementation of <font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font>.  
  
[<font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> implementation]CMPI_TYPE_MATCH_SIZE implementation@<font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font> implementationMPI_TYPE_MATCH_SIZE<br> 
<pre style="background-color:#EFEFEF"><tt><b>int</b> <b>MPI_Type_match_size</b>(<b>int</b> typeclass, <b>int</b> size, <b>MPI_Datatype</b> *rtype) 
{ 
  <b>switch</b>(typeclass) { 
      <b>case</b> <b>MPI_TYPECLASS_REAL</b>: <b>switch</b>(size) { 
        <b>case</b> 4: *rtype = <b>MPI_REAL4</b>; <b>return</b> <b>MPI_SUCCESS</b>; 
        <b>case</b> 8: *rtype = <b>MPI_REAL8</b>; <b>return</b> <b>MPI_SUCCESS</b>; 
        <b>default</b>: error(...); 
      } 
      <b>case</b> <b>MPI_TYPECLASS_INTEGER</b>: <b>switch</b>(size) { 
         <b>case</b> 4: *rtype = <b>MPI_INTEGER4</b>; <b>return</b> <b>MPI_SUCCESS</b>; 
         <b>case</b> 8: *rtype = <b>MPI_INTEGER8</b>; <b>return</b> <b>MPI_SUCCESS</b>; 
         <b>default</b>: error(...); 
      } 
     ... etc. ... 
   } 
 
   <b>return</b> <b>MPI_SUCCESS</b>; 
} 
</tt></pre> 
  
  
 (<em> End of advice to implementors.</em>) <br> 

<P>
<hr>
<a href="node475.htm#Node476"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node475.htm#Node475"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node475.htm#Node478"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node475.htm#Node478"> Communication With Size-specific Types</a>
<b>Previous: </b><a href="node475.htm#Node476"> Parameterized Datatypes with Specified Precision and Exponent Range</a>
<p>
<hr><h3><span id="Node478">20.1.9.3. Communication With Size-specific Types</span></h3>
<a href="node475.htm#Node477"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node475.htm#Node475"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node479.htm#Node479"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node479.htm#Node479"> Problems With Fortran Bindings for <font face="sans-serif"> MPI</font></a>
<b>Previous: </b><a href="node475.htm#Node477"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<p>
The usual type matching rules apply to size-specific datatypes: a  
value sent with datatype  
<font face="sans-serif"> <span style="font-size:0.900em;"> MPI_<i>&lt;</i>TYPECLASS<i>&gt;&lt;</i><b> n</b><i>&gt;</i></span></font> can be received with this same datatype on  
another <font face="sans-serif"> MPI</font> process.  
Most modern computers use two's complement for integers and  
IEEE format for floating point.  Thus, communication using these  
size-specific datatypes will not entail loss of precision or  
truncation errors.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Care is required when communicating in a heterogeneous  
environment. Consider the following code:  
<br><b> Example</b>  
Unsafe heterogeneous communication due to the use of <font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font>.  
  
[Fortran 90, with heterogeneous communication (unsafe)]FortranFortran 90!heterogeneous communication (unsafe)MPI_TYPE_MATCH_SIZE<br> 
<pre style="background-color:#EFEFEF"><tt><b>real</b>(selected_real_kind(5)) x(100) 
size = storage_size(x) / 8 
<b>call</b> <b>MPI_TYPE_MATCH_SIZE</b>(<b>MPI_TYPECLASS_REAL</b>, size, xtype, ierror) 
<b>if</b> (myrank .eq. 0) <b>then</b> 
    ... initialize x ... 
    <b>call</b> <b>MPI_SEND</b>(x, xtype, 100, 1, ...) 
<b>else</b> <b>if</b> (myrank .eq. 1) <b>then</b> 
    <b>call</b> <b>MPI_RECV</b>(x, xtype, 100, 0, ...) 
endif 
</tt></pre> 
  
  
  
This may not work in a heterogeneous environment  
if the value of <font face="sans-serif"> size</font> is not the same on the <font face="sans-serif"> MPI</font> processes with ranks 0 and 1.  
There should be no problem in a homogeneous environment.  
To communicate in a heterogeneous environment, there are at least four  
options. The first is to declare variables of default type and use  
the <font face="sans-serif"> MPI</font> datatypes for these types, e.g., declare a variable of type  
<tt> REAL</tt> and use <font face="sans-serif"> MPI_REAL</font>.  The second is to use  
<tt>selected_real_kind</tt> or <tt>selected_int_kind</tt> and  
with the functions of the previous section.  
The third is to declare a variable  
that is known to be the same size on all architectures (e.g.,  
<tt>selected_real_kind(12)</tt> on almost all compilers will result in an 8-byte  
representation). The fourth is to carefully check  
representation size before communication. This may require explicit  
conversion to a variable of size that can be communicated and  
handshaking between sender and receiver to agree on a size.  
<P> 
Note finally that using the <font face="sans-serif"> <span style="font-size:0.900em;"><tt>"</span></tt>external32<span style="font-size:0.900em;"><tt>"</span></tt></font> representation for I/O  
requires explicit attention to the representation sizes. Consider the  
following code:  
<P> 
<br><b> Example</b>  
Unsafe heterogeneous <font face="sans-serif"> MPI</font> file I/O due to the use of <font face="sans-serif"> MPI_TYPE_MATCH_SIZE</font>.  
  
[Fortran 90, with heterogeneous <font face="sans-serif"> MPI</font> I/O (unsafe)]FortranFortran 90!heterogeneous MPI I/O (unsafe)@heterogeneous <font face="sans-serif"> MPI</font> I/O (unsafe)MPI_TYPE_MATCH_SIZE,MPI_FILE_SET_VIEW<br> 
<pre style="background-color:#EFEFEF"><tt><b>real</b>(selected_real_kind(5)) x(100) 
size = storage_size(x) / 8 
<b>call</b> <b>MPI_TYPE_MATCH_SIZE</b>(<b>MPI_TYPECLASS_REAL</b>, size, xtype, ierror) 
 
<b>if</b> (myrank .eq. 0) <b>then</b> 
   <b>call</b> <b>MPI_FILE_OPEN</b>(<b>MPI_COMM_SELF</b>, 'foo',                &amp; 
                      <b>MPI_MODE_CREATE</b>+<b>MPI_MODE_WRONLY</b>,     &amp; 
                      <b>MPI_INFO_NULL</b>, fh, ierror) 
   <b>call</b> <b>MPI_FILE_SET_VIEW</b>(fh, zero, xtype, xtype, 'external32',&amp; 
                          <b>MPI_INFO_NULL</b>, ierror) 
   <b>call</b> <b>MPI_FILE_WRITE</b>(fh, x, 100, xtype, status, ierror) 
   <b>call</b> <b>MPI_FILE_CLOSE</b>(fh, ierror) 
endif 
 
<b>call</b> <b>MPI_BARRIER</b>(<b>MPI_COMM_WORLD</b>, ierror) 
 
<b>if</b> (myrank .eq. 1) <b>then</b> 
   <b>call</b> <b>MPI_FILE_OPEN</b>(<b>MPI_COMM_SELF</b>, 'foo', <b>MPI_MODE_RDONLY</b>,   &amp; 
                      <b>MPI_INFO_NULL</b>, fh, ierror) 
   <b>call</b> <b>MPI_FILE_SET_VIEW</b>(fh, zero, xtype, xtype, 'external32',&amp; 
                          <b>MPI_INFO_NULL</b>, ierror) 
   <b>call</b> <b>MPI_FILE_READ</b>(fh, x, 100, xtype, status, ierror) 
   <b>call</b> <b>MPI_FILE_CLOSE</b>(fh, ierror) 
endif 
</tt></pre> 
  
  
  
If the <font face="sans-serif"> MPI</font> processes with ranks 0 and 1 are on different machines, this code may not work  
as expected if the <font face="sans-serif"> size</font> is different on the two machines.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node475.htm#Node477"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node475.htm#Node475"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node479.htm#Node479"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node475.htm#Node475"> Additional Support for Fortran Numeric Intrinsic Types</a>
<b>Next: </b><a href="node479.htm#Node479"> Problems With Fortran Bindings for <font face="sans-serif"> MPI</font></a>
<b>Previous: </b><a href="node475.htm#Node477"> Support for Size-specific <font face="sans-serif"> MPI</font> Datatypes</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
