<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Communication Completion</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node76">4.7.3. Communication Completion</span></h2>
<a href="node75.htm#Node75"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node73.htm#Node73"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node77.htm#Node77"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node73.htm#Node73"> Nonblocking Communication</a>
<b>Next: </b><a href="node77.htm#Node77"> Semantics of Nonblocking Communication Operations</a>
<b>Previous: </b><a href="node75.htm#Node75"> Communication Initiation</a>
<p>
  
  
  
<P> 
The functions <font face="sans-serif"> MPI_WAIT</font> and <font face="sans-serif"> MPI_TEST</font> are used to complete a  
nonblocking communication.  The <em> completion</em> of a send operation indicates that  
the sender is now free  
to update the send buffer  
(the send operation itself leaves the content  
of the send buffer unchanged). It does not indicate that the  
message has been received,  
rather, it may have been buffered by the communication  
subsystem.  However, if a <em> synchronous mode send</em>  
was used, the <em> completion</em> of the  
send operation indicates that a matching receive was <em> initiated</em>, and that the  
message will eventually be received by this matching receive.  
<P> 
The <em> completion</em> of a receive operation indicates that the receive buffer  
contains the received message, the receiver is now free to access it,  
and that the status object is set.  It does  
not indicate that the matching send operation has <em> completed</em> (but indicates, of  
course, that the send was <em> initiated</em>).  
<P> 
We shall use the following terminology:  
A <b> null handle</b> is a handle with  
value  
<font face="sans-serif"> MPI_REQUEST_NULL</font>.  
A <em> persistent communication request</em>  
and the handle to it are <b> inactive</b>  
if the request is not associated with any ongoing  
communication (see Section <a href="node85.htm#Node85">Persistent Communication Requests</a>).  
A handle is <b> active</b> if it is neither <em> null</em> nor <em> inactive</em>.  
An  
<b> empty</b> status is a status that is set to return  
<font face="sans-serif"> tag</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_ANY_TAG</font>,  
<font face="sans-serif"> source</font><font face="sans-serif">  = </font><font face="sans-serif"> MPI_ANY_SOURCE</font>,  
<font face="sans-serif"> error</font><font face="sans-serif">  = </font><span style="font-size:0.900em;"><font face="sans-serif"> MPI_SUCCESS</span></font>,  
and is also internally configured so that calls to  
<font face="sans-serif"> MPI_GET_COUNT</font> and <font face="sans-serif"> MPI_GET_ELEMENTS</font> return  
<font face="sans-serif"> count</font><font face="sans-serif">  = 0</font>  
and <font face="sans-serif"> MPI_TEST_CANCELLED</font> returns <font face="sans-serif"> false</font>.  
We set a status variable to <em> empty</em> when the value returned by it is not  
significant. Status is set in this  
way so as to prevent errors due to accesses of stale information.  
<P> 
The fields in a <font face="sans-serif"> status</font> object returned by a call to  
<font face="sans-serif"> MPI_WAIT</font>, <font face="sans-serif"> MPI_TEST</font>, or any of the other derived functions  
(<font face="sans-serif"> MPI_</font>{<font face="sans-serif"> TEST<i>|</i>WAIT</font>}{<font face="sans-serif"> ALL<i>|</i>SOME<i>|</i>ANY</font>}),  
where the <font face="sans-serif"> request</font> corresponds to a send call, are undefined, with two  
exceptions: The error status field will contain valid information if the wait  
or test call returned with <span style="font-size:0.900em;"><font face="sans-serif"> MPI_ERR_IN_STATUS</span></font>; and the returned  
status can be queried by the call <font face="sans-serif"> MPI_TEST_CANCELLED</font>.  
<P> 
Error codes belonging to the error class <span style="font-size:0.900em;"><font face="sans-serif"> MPI_ERR_IN_STATUS</span></font> should  
be returned only by the <font face="sans-serif"> MPI</font> completion functions that take arrays of  
<font face="sans-serif"> MPI_Status</font>.  
For the functions that take a single <font face="sans-serif"> MPI_Status</font> argument, the  
error code is returned by the function, and the value of the <font face="sans-serif"> MPI_ERROR</font>  
field in the <font face="sans-serif"> MPI_Status</font> argument is undefined (see <a href="node62.htm#Node62">Return Status</a>).  
<P> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_WAIT(<span style="white-space:nowrap">request</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> request</TD><TD>request (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Wait(MPI_Request *request, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Wait(request, status, ierror) <br> TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">request</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_WAIT(REQUEST, STATUS, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
A call to <font face="sans-serif"> MPI_WAIT</font> returns when the operation  
identified by <font face="sans-serif"> request</font> is <em> complete</em>.  If the request is an <em> active</em> <em> persistent communication request</em>,  
it is marked <em> inactive</em>.  Any other type of request  
is deallocated  
and the request handle is set to <font face="sans-serif"> MPI_REQUEST_NULL</font>.  
<font face="sans-serif"> MPI_WAIT</font> is in general a <em> nonlocal</em> procedure.  
When the operation represented by the <font face="sans-serif"> request</font> is  
<em> enabled</em>  
then a call to <font face="sans-serif"> MPI_WAIT</font> is a <em> local</em> procedure call.  
<P> 
The call returns, in <font face="sans-serif"> status</font>, information on  
the completed operation.  The content of the status object for a receive  
operation can be accessed as  
described in Section <a href="node62.htm#Node62">Return Status</a>.  
The status object for a send operation may be queried by  
a call to <font face="sans-serif"> MPI_TEST_CANCELLED</font>  
(see Section <a href="node80.htm#Node80">Probe and Cancel</a>).  
<P> 
One is allowed to call <font face="sans-serif"> MPI_WAIT</font> with a <em> null</em> or <em> inactive</em>  
<font face="sans-serif"> request</font> argument.  
In this case the procedure returns immediately with <em> empty</em> <font face="sans-serif"> status</font>.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Successful return of <font face="sans-serif"> MPI_WAIT</font> after a <font face="sans-serif"> MPI_IBSEND</font> implies  
that the user send buffer can be reused---i.e., data has been sent  
out or copied into a  
buffer attached with <font face="sans-serif"> MPI_BUFFER_ATTACH</font>, <font face="sans-serif"> MPI_COMM_ATTACH_BUFFER</font> or <font face="sans-serif"> MPI_SESSION_ATTACH_BUFFER</font>.  
Further, at this point,  
we can no longer <em> cancel</em> the send (see Section <a href="node80.htm#Node80">Probe and Cancel</a>).  
If a matching receive is never  
<em> started</em>, then the buffer cannot be freed.  This runs somewhat  
counter to the stated goal of <font face="sans-serif"> MPI_CANCEL</font> (always being able to free  
program space that was committed to the communication subsystem).  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
In a multithreaded environment, a call to  
<font face="sans-serif"> MPI_WAIT</font> should block only the calling thread, allowing the thread  
scheduler to schedule another thread for execution.  
 (<em> End of advice to implementors.</em>) <br> 
  
  
<TABLE><TR><TD COLSPAN=2>MPI_TEST(<span style="white-space:nowrap">request</span>, <span style="white-space:nowrap">flag</span>, <span style="white-space:nowrap">status</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> request</TD><TD>communication request (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> flag</TD><TD><font face="sans-serif"> true</font> if operation completed (logical)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> status</TD><TD>status object (status)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Test(MPI_Request *request, int *flag, MPI_Status *status) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Test(request, flag, status, ierror) <br> TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">request</span><br>LOGICAL, INTENT(OUT) :: <span style="white-space:nowrap">flag</span><br>TYPE(MPI_Status) :: <span style="white-space:nowrap">status</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TEST(REQUEST, FLAG, STATUS, IERROR) <br> INTEGER <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">STATUS(MPI_STATUS_SIZE)</span>, <span style="white-space:nowrap">IERROR</span><br>LOGICAL <span style="white-space:nowrap">FLAG</span> <br></tt>  
<P> 
A call to <font face="sans-serif"> MPI_TEST</font> returns <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font> if the  
operation identified by <font face="sans-serif"> request</font> is <em> complete</em>.  In such a case, the  
status object is set to contain information on the completed  
operation.  If the request is an <em> active</em> <em> persistent communication request</em>,  
it is marked as <em> inactive</em>.  Any other type of request  
is deallocated and the request handle is set to  
<font face="sans-serif"> MPI_REQUEST_NULL</font>. The call returns  
<font face="sans-serif"> flag</font><font face="sans-serif">  = false</font> if the operation identified by  
<font face="sans-serif"> request</font> is not complete.  
In this case, the value  
of the status object is undefined.  
<font face="sans-serif"> MPI_TEST</font> is a <em> local</em> procedure.  
<P> 
The return status object for a receive operation carries information that  
can be accessed as described in  
Section <a href="node62.htm#Node62">Return Status</a>.  
The status object for a send operation carries information that can be  
accessed by  
a call to <font face="sans-serif"> MPI_TEST_CANCELLED</font>  
(see Section <a href="node80.htm#Node80">Probe and Cancel</a>).  
<P> 
One  
is allowed to call <font face="sans-serif"> MPI_TEST</font> with a <em> null</em> or <em> inactive</em> <font face="sans-serif"> request</font>  
argument. In such a case the procedure returns with <font face="sans-serif"> flag</font><font face="sans-serif">  = true</font> and  
<em> empty</em> <font face="sans-serif"> status</font>.  
<P> 
The procedures <font face="sans-serif"> MPI_WAIT</font> and <font face="sans-serif"> MPI_TEST</font> can be used to  
complete any request-based nonblocking or persistent operation.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
The use of  
the nonblocking <font face="sans-serif"> MPI_TEST</font> call allows the user to  
schedule alternative activities within a single thread of execution.  
An event-driven thread scheduler can be emulated with periodic calls to  
<font face="sans-serif"> MPI_TEST</font>.  
 (<em> End of advice to users.</em>) <br> 
<br><b> Example</b>  
  
Simple usage of nonblocking operations and <font face="sans-serif"> MPI_WAIT</font>.  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>CALL</b> <b>MPI_COMM_RANK</b>(comm, rank, ierr) 
<b>IF</b> (rank .EQ. 0) <b>THEN</b> 
   <b>CALL</b> <b>MPI_ISEND</b>(a(1), 10, <b>MPI_REAL</b>, 1, tag, comm, request, ierr) 
   ! **** <b>do</b> some computation to mask latency **** 
   <b>CALL</b> <b>MPI_WAIT</b>(request, status, ierr) 
<b>ELSE</b> <b>IF</b> (rank .EQ. 1) <b>THEN</b> 
   <b>CALL</b> <b>MPI_IRECV</b>(a(1), 15, <b>MPI_REAL</b>, 0, tag, comm, request, ierr) 
   ! **** <b>do</b> some computation to mask latency **** 
   <b>CALL</b> <b>MPI_WAIT</b>(request, status, ierr) 
<b>END</b> <b>IF</b> 
</tt></pre> 
  
  
<P> 
A request object can be <em> freed</em> using the following <font face="sans-serif"> MPI</font> procedure.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_REQUEST_FREE(<span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Request_free(MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Request_free(request, ierror) <br> TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_REQUEST_FREE(REQUEST, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
<font face="sans-serif"> MPI_REQUEST_FREE</font> is a <em> local</em> procedure. Upon successful return,  
<font face="sans-serif"> MPI_REQUEST_FREE</font> sets <font face="sans-serif"> request</font> to <font face="sans-serif"> MPI_REQUEST_NULL</font>.  
For an <em> inactive</em> <font face="sans-serif"> request</font> representing any type of <font face="sans-serif"> MPI</font> operation,  
<font face="sans-serif"> MPI_REQUEST_FREE</font> shall do the <em> freeing stage</em> of the associated  
operation during its execution.  
<P> 
For a <font face="sans-serif"> request</font> representing a <em> nonblocking</em> point-to-point  
or a <em> persistent</em> point-to-point operation, it is permitted (although  
strongly discouraged) to call <font face="sans-serif"> MPI_REQUEST_FREE</font> when the  
<font face="sans-serif"> request</font> is <em> active</em>. In this special case, <font face="sans-serif"> MPI_REQUEST_FREE</font>  
will only mark the request for freeing and <font face="sans-serif"> MPI</font> will actually do the  
<em> freeing stage</em> of the operation associated with the request later.  
<P> 
The use of this procedure for generalized requests is described in  
Section <a href="node347.htm#Node347">Generalized Requests</a>.  
<P> 
Calling <font face="sans-serif"> MPI_REQUEST_FREE</font> with an <em> active</em> <font face="sans-serif"> request</font> representing any  
other type of <font face="sans-serif"> MPI</font> operation (e.g., any partitioned operation (see Chapter <a href="node87.htm#Node87">Partitioned Point-to-Point Communication</a>),  
any collective operation (see Chapter <a href="node115.htm#Node115">Collective Communication</a>), any I/O  
operation (see Chapter <a href="node350.htm#Node350">I/O</a>), or any  
request-based <font face="sans-serif"> RMA</font> operation (see Chapter <a href="node308.htm#Node308">One-Sided Communications</a>)) is <em> erroneous</em>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
For point-to-point operations, the <font face="sans-serif"> MPI_REQUEST_FREE</font> mechanism is provided for  
reasons of performance and convenience on the sending side.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Once a request is freed by a call to <font face="sans-serif"> MPI_REQUEST_FREE</font>, it is not possible  
to check for the successful completion of the associated communication  
with calls to <font face="sans-serif"> MPI_WAIT</font> or <font face="sans-serif"> MPI_TEST</font>. Also, if an error occurs subsequently  
during the communication, an error code cannot be returned to the  
user---such an error must be treated as fatal. An active receive request should  
never be freed as the receiver will have no way to verify that the receive  
has completed and the receive buffer can be reused.  
 (<em> End of advice to users.</em>) <br> 
<br><b> Example</b>  
  
An example using <font face="sans-serif"> MPI_REQUEST_FREE</font>.  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>CALL</b> <b>MPI_COMM_RANK</b>(<b>MPI_COMM_WORLD</b>, rank, ierr) 
<b>IF</b> (rank .EQ. 0) <b>THEN</b> 
   <b>DO</b> i=1,n 
      <b>CALL</b> <b>MPI_ISEND</b>(outval, 1, <b>MPI_REAL</b>, 1, 0, <b>MPI_COMM_WORLD</b>, req, ierr) 
      <b>CALL</b> <b>MPI_REQUEST_FREE</b>(req, ierr) 
      <b>CALL</b> <b>MPI_IRECV</b>(inval, 1, <b>MPI_REAL</b>, 1, 0, <b>MPI_COMM_WORLD</b>, req, ierr) 
      <b>CALL</b> <b>MPI_WAIT</b>(req, status, ierr) 
   <b>END</b> <b>DO</b> 
<b>ELSE</b> <b>IF</b> (rank .EQ. 1) <b>THEN</b> 
   <b>CALL</b> <b>MPI_IRECV</b>(inval, 1, <b>MPI_REAL</b>, 0, 0, <b>MPI_COMM_WORLD</b>, req, ierr) 
   <b>CALL</b> <b>MPI_WAIT</b>(req, status, ierr) 
   <b>DO</b> I=1,n-1 
      <b>CALL</b> <b>MPI_ISEND</b>(outval, 1, <b>MPI_REAL</b>, 0, 0, <b>MPI_COMM_WORLD</b>, req, ierr) 
      <b>CALL</b> <b>MPI_REQUEST_FREE</b>(req, ierr) 
      <b>CALL</b> <b>MPI_IRECV</b>(inval, 1, <b>MPI_REAL</b>, 0, 0, <b>MPI_COMM_WORLD</b>, req, ierr) 
      <b>CALL</b> <b>MPI_WAIT</b>(req, status, ierr) 
   <b>END</b> <b>DO</b> 
   <b>CALL</b> <b>MPI_ISEND</b>(outval, 1, <b>MPI_REAL</b>, 0, 0, <b>MPI_COMM_WORLD</b>, req, ierr) 
   <b>CALL</b> <b>MPI_WAIT</b>(req, status, ierr) 
<b>END</b> <b>IF</b> 
</tt></pre> 
  
  
<P> 

<P>
<hr>
<a href="node75.htm#Node75"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node73.htm#Node73"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node77.htm#Node77"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node73.htm#Node73"> Nonblocking Communication</a>
<b>Next: </b><a href="node77.htm#Node77"> Semantics of Nonblocking Communication Operations</a>
<b>Previous: </b><a href="node75.htm#Node75"> Communication Initiation</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
