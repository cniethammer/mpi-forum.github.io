<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-binding/binding-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Fortran Derived Types</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node484">20.1.15. Fortran Derived Types</span></h2>
<a href="node483.htm#Node483"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node466.htm#Node466"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node485.htm#Node485"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node466.htm#Node466"> Support for Fortran</a>
<b>Next: </b><a href="node485.htm#Node485"> Optimization Problems, an Overview</a>
<b>Previous: </b><a href="node483.htm#Node483"> Special Constants</a>
<p>
  
  
<P> 
<font face="sans-serif"> MPI</font> supports passing Fortran  
entities of <tt> BIND(C)</tt> and <tt> SEQUENCE</tt> derived  
types to choice dummy arguments, provided no type component  
has the <tt> ALLOCATABLE</tt> or <tt> POINTER</tt> attribute.  
<P> 
The following code fragment shows  
some possible ways to send scalars or arrays of interoperable  
derived types in Fortran. Example <a href="node484.htm#Node484">Fortran Derived Types</a> assumes that all data is passed by address.  
<br><b> Example</b>  
Fortran array of derived Fortran types: the struct <font face="sans-serif"> MPI</font> derived type should be resized.  
  
[Fortran 90, with derived types]FortranFortran 90!derived typesMPI_Type_create_resized,MPI_Type_create_struct,MPI_Get_address,MPI_Type_commit  
<br> 
<pre style="background-color:#EFEFEF"><tt><b>type</b>, <b>BIND</b>(C) :: mytype 
   <b>integer</b> :: i 
   <b>real</b> :: x 
   <b>double</b> <b>precision</b> :: d 
   logical :: l 
<b>end</b> <b>type</b> mytype 
 
<b>type</b>(mytype) :: foo, fooarr(5) 
<b>integer</b> :: blocklen(4), dtype(4) 
<b>integer</b>(<b>KIND</b>=<b>MPI_ADDRESS_KIND</b>) :: disp(4), base, lb, extent 
 
<b>call</b> <b>MPI_GET_ADDRESS</b>(foo%i, disp(1), ierr) 
<b>call</b> <b>MPI_GET_ADDRESS</b>(foo%x, disp(2), ierr) 
<b>call</b> <b>MPI_GET_ADDRESS</b>(foo%d, disp(3), ierr) 
<b>call</b> <b>MPI_GET_ADDRESS</b>(foo%l, disp(4), ierr) 
 
base = disp(1) 
disp(1) = disp(1) - base 
disp(2) = disp(2) - base 
disp(3) = disp(3) - base 
disp(4) = disp(4) - base 
 
blocklen(1) = 1 
blocklen(2) = 1 
blocklen(3) = 1 
blocklen(4) = 1 
 
dtype(1) = <b>MPI_INTEGER</b> 
dtype(2) = <b>MPI_REAL</b> 
dtype(3) = <b>MPI_DOUBLE_PRECISION</b> 
dtype(4) = <b>MPI_LOGICAL</b> 
 
<b>call</b> <b>MPI_TYPE_CREATE_STRUCT</b>(4, blocklen, disp, dtype, newtype, ierr) 
<b>call</b> <b>MPI_TYPE_COMMIT</b>(newtype, ierr) 
 
<b>call</b> <b>MPI_SEND</b>(foo%i, 1, newtype, dest, tag, comm, ierr) 
! or 
<b>call</b> <b>MPI_SEND</b>(foo, 1, newtype, dest, tag, comm, ierr) 
! expects that base == address(foo%i) == address(foo) 
 
<b>call</b> <b>MPI_GET_ADDRESS</b>(fooarr(1), disp(1), ierr) 
<b>call</b> <b>MPI_GET_ADDRESS</b>(fooarr(2), disp(2), ierr) 
extent = disp(2) - disp(1) 
lb = 0 
<b>call</b> <b>MPI_TYPE_CREATE_RESIZED</b>(newtype, lb, extent, newarrtype, ierr) 
<b>call</b> <b>MPI_TYPE_COMMIT</b>(newarrtype, ierr) 
 
<b>call</b> <b>MPI_SEND</b>(fooarr, 5, newarrtype, dest, tag, comm, ierr) 
</tt></pre> 
  
  
<P> 
Using the derived type variable <tt>foo</tt> instead of its  
first basic type element <tt>foo%i</tt> may be impossible  
if the <font face="sans-serif"> MPI</font> library implements choice buffer arguments  
through overloading instead of using  
<tt>TYPE(*), DIMENSION(..)</tt>, or through a  
nonstandardized extension such as <tt>!$PRAGMA IGNORE_TKR</tt>;  
see  
Section <a href="node472.htm#Node472"><font face="sans-serif"> MPI</font> for Different Fortran Standard Versions</a>.  
<P> 
To use a derived type in an array requires a correct extent of the datatype handle  
to take care of the alignment rules applied by the compiler.  
These alignment rules may imply that there are gaps between  
the components of a derived type, and also between the subsuquent  
elements of an array of a derived type.  
The extent of an interoperable derived type (i.e., defined with <tt> BIND(C)</tt>)  
and a <tt> SEQUENCE</tt> derived type with the same content  
may be different because C and Fortran may apply different alignment rules.  
As recommended in the advice to users  
in Section <a href="node104.htm#Node104">Lower-Bound and Upper-Bound Markers</a>,  
one should add an additional fifth structure element with one numerical storage unit  
at the end of this structure to force in most cases that the array of structures is contiguous.  
Even with such an additional element, one should keep this resizing due to the  
special alignment rules that can be used by the compiler for structures,  
as also mentioned in this advice.  
<P> 
Using the extended semantics defined in TS 29113,  
it is also possible  
to use entities or derived types without either the <tt> BIND(C)</tt> or the  
<tt> SEQUENCE</tt> attribute as choice buffer arguments; some additional  
constraints must be observed, e.g., no <tt> ALLOCATABLE</tt> or  
<tt> POINTER</tt> type components may exist.  
In this case, the <tt>base</tt> address in the example must be changed  
to become the address of <tt>foo</tt> instead of <tt>foo%i</tt>, because the  
Fortran compiler may rearrange type components or add padding.  
Sending the structure <tt>foo</tt> should then also be performed by  
providing it (and not <tt>foo%i</tt>) as actual argument for <tt>MPI_Send</tt>.  
<P> 

<P>
<hr>
<a href="node483.htm#Node483"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node466.htm#Node466"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node485.htm#Node485"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node466.htm#Node466"> Support for Fortran</a>
<b>Next: </b><a href="node485.htm#Node485"> Optimization Problems, an Overview</a>
<b>Previous: </b><a href="node483.htm#Node483"> Special Constants</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
