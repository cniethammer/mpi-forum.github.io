<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-one-side/one-side-2-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Semantics and Correctness</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node339">13.7. Semantics and Correctness</span></h1>
<a href="node338.htm#Node338"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node308.htm#Node308"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node340.htm#Node340"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node308.htm#Node308"> One-Sided Communications</a>
<b>Next: </b><a href="node340.htm#Node340"> Atomicity</a>
<b>Previous: </b><a href="node338.htm#Node338"> Error Classes</a>
<p>
  
  
<P> 
The following rules specify  
the latest point in the execution of the application an operation must complete at the origin or  
the target.  
The update initiated by a  
call to <font face="sans-serif"> MPI_GET</font> in the origin process memory is visible when the get  
operation is complete at the origin (or earlier); the update initiated by a  
call to <font face="sans-serif"> MPI_PUT</font> or  
an accumulate procedure in the public copy of the target window is visible  
when the put or accumulate operation has completed at the target (or earlier).  The  
rules  
also specify  
the latest  
point at which an update of one window copy becomes visible in another  
overlapping copy.   
<P> 
<ol> 
 
1.   
An <font face="sans-serif"> RMA</font> operation is completed at the origin  
by the ensuing call to  
<font face="sans-serif"> MPI_WIN_COMPLETE</font>, <font face="sans-serif"> MPI_WIN_FENCE</font>, <font face="sans-serif"> MPI_WIN_FLUSH</font>,  
<font face="sans-serif"> MPI_WIN_FLUSH_ALL</font>, <font face="sans-serif"> MPI_WIN_FLUSH_LOCAL</font>,  
<font face="sans-serif"> MPI_WIN_FLUSH_LOCAL_ALL</font>, <font face="sans-serif"> MPI_WIN_UNLOCK</font>, or  
<font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font>  
that synchronizes this access at the origin.  
 
<br> 
2.   
If an <font face="sans-serif"> RMA</font> operation is completed at the origin by a call to  
<font face="sans-serif"> MPI_WIN_FENCE</font>  
then the operation is completed at the target  by the  
matching call to <font face="sans-serif"> MPI_WIN_FENCE</font> by the target process.  
 
<br> 
3.   
If an <font face="sans-serif"> RMA</font> operation is completed at the origin  
by a call to <font face="sans-serif"> MPI_WIN_COMPLETE</font>  
then the operation is completed at the target  by the  
matching call to  <font face="sans-serif"> MPI_WIN_WAIT</font> by the target process.  
 
<br> 
4.   
If an <font face="sans-serif"> RMA</font> operation is completed at the origin by a call to  
<font face="sans-serif"> MPI_WIN_UNLOCK</font> or <font face="sans-serif"> MPI_WIN_FLUSH</font> (with <font face="sans-serif"> rank</font><font face="sans-serif"> =target</font>), <font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font>, or <font face="sans-serif"> MPI_WIN_FLUSH_ALL</font>,  
then the operation is completed at the target by  
that same call.  
 
<br> 
5.   
An update of a location in a private window copy in <font face="sans-serif"> MPI</font> process memory  
becomes visible in the public window copy at the latest when an ensuing call  
to <font face="sans-serif"> MPI_WIN_POST</font>, <font face="sans-serif"> MPI_WIN_FENCE</font>, <font face="sans-serif"> MPI_WIN_UNLOCK</font>,   
<font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font>, or <font face="sans-serif"> MPI_WIN_SYNC</font> is  
executed on that window by the window owner. In the <font face="sans-serif"> RMA</font> unified  
memory model, an update of a location in a private window in <font face="sans-serif"> MPI</font> process  
memory becomes visible without additional <font face="sans-serif"> RMA</font> calls.  
<P> 
 
<br> 
6. An update by a put or accumulate operation to a public window copy becomes  
visible in the private copy in <font face="sans-serif"> MPI</font> process memory at the latest when an ensuing  
call to <font face="sans-serif"> MPI_WIN_WAIT</font>, <font face="sans-serif"> MPI_WIN_FENCE</font>, <font face="sans-serif"> MPI_WIN_LOCK</font>,   
<font face="sans-serif"> MPI_WIN_LOCK_ALL</font>, or <font face="sans-serif"> MPI_WIN_SYNC</font> is executed on that window by the  
window owner. In the <font face="sans-serif"> RMA</font> unified memory model, an update by a put or  
accumulate operation to a public window copy eventually becomes visible in the private  
copy in <font face="sans-serif"> MPI</font> process memory without additional <font face="sans-serif"> RMA</font> calls.  
  
</ol> 
The <font face="sans-serif"> MPI_WIN_FENCE</font> or <font face="sans-serif"> MPI_WIN_WAIT</font> call that  
completes the transfer from public copy to private copy  
(Rule <a href="node339.htm#Node339">Semantics and Correctness</a>) is the same call that completes the put  
or accumulate operation in the window copy  
(Rule <a href="node339.htm#Node339">Semantics and Correctness</a>, Rule <a href="node339.htm#Node339">Semantics and Correctness</a>).  If a put  
or accumulate access was synchronized with a lock, then the update of  
the public window copy is complete as soon as the updating origin process  
executed <font face="sans-serif"> MPI_WIN_UNLOCK</font> or  
<font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font>.  In the  
<font face="sans-serif"> RMA</font> separate memory model, the update of a  
private copy in the target process   
memory may be delayed until the target process executes a  
synchronization call on that window (Rule <a href="node339.htm#Node339">Semantics and Correctness</a>).  
Thus, updates to target process memory can always be delayed in the <font face="sans-serif"> RMA</font>  
separate memory model until the target process executes a suitable  
synchronization call, while they must complete in the <font face="sans-serif"> RMA</font> unified  
model without additional synchronization calls.    
If fence or  
post-start-complete-wait synchronization is used, updates to a public  
window copy can be delayed in both memory models until the window owner  
executes a synchronization call.  
When passive target   
synchronization  
is used, it is necessary to update the public window  
copy  
even if the window owner does not execute any related  
synchronization call.  
<P> 
The rules above also define, by implication, when an update to a  
public window copy becomes visible in another overlapping public  
window copy.  
Consider, for example,  two overlapping windows, <font face="sans-serif"> win1</font> and <font face="sans-serif"> win2</font>.  A call to  
<font face="sans-serif"> MPI_WIN_FENCE</font> on <font face="sans-serif"> win1</font> by the window owner  
makes visible in the target process memory  
previous updates to window <font face="sans-serif"> win1</font> by origin processes.  A subsequent call  
to <font face="sans-serif"> MPI_WIN_FENCE</font> on <font face="sans-serif"> win2</font> makes these updates visible in  
the public copy of <font face="sans-serif"> win2</font>.  
<P> 
The behavior of some <font face="sans-serif"> MPI</font> <font face="sans-serif"> RMA</font> operations may be  
<em> undefined</em> in certain situations.  For example, the result of  
several origin processes performing concurrent put  
operations to the same target location is undefined.  In addition, the  
result of a single origin process performing multiple  
put operations to the same target location within the  
same access epoch is also undefined.  
The result at the target may have all of the  
data from one of the put operations (the ``last'' one,  
in some sense), some bytes from each of the operations, or  
something else.  In <font face="sans-serif"> MPI-2</font>, such operations were <em> erroneous</em>.  
That meant that an <font face="sans-serif"> MPI</font> implementation was permitted to raise an error.  
Thus, user programs or tools that used <font face="sans-serif"> MPI</font> <font face="sans-serif"> RMA</font> could not  
portably permit such operations, even if the application code could  
function correctly with such an undefined result.  Starting with <font face="sans-serif"> MPI-3</font>, these  
operations are not erroneous, but do not have a defined behavior.  
 
<br> 
<em> Rationale.</em>  
<P> 
As discussed in [<a href="node626.htm#-Bib8">8</a>], requiring  
operations such as   
overlapping puts to be erroneous makes it difficult to use <font face="sans-serif"> MPI</font>  
<font face="sans-serif"> RMA</font> to implement programming models---such as Unified Parallel C (UPC) or SHMEM---that permit  
these operations.  Further, while <font face="sans-serif"> MPI-2</font> defined these operations as  
erroneous, the <font face="sans-serif"> MPI</font> Forum is unaware of any implementation that enforces  
this rule, as it would require significant overhead.  Thus, relaxing  
this condition does not impact existing implementations or applications.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
Overlapping accesses are undefined. However, to assist users in  
debugging code, implementations may wish to provide a mode in which such  
operations are detected and reported to the user. Note, however, that starting with <font face="sans-serif"> MPI-3</font>, such operations must   
not raise an error.  
 (<em> End of advice to implementors.</em>) <br> 
A program with a well-defined outcome in the <font face="sans-serif"> MPI_WIN_SEPARATE</font> memory model   
must obey the following rules.  
<P> 
<ol> 
 
1.   
A location in a window must not be accessed  
with load/store accesses once an update to  
that location has started, until the update becomes visible in the  
private window copy in target process  
memory.  
 
<br> 
2.   
A location in a window must not  be accessed as a target of an <font face="sans-serif"> RMA</font>  
operation once an update to that location has started, until the  
update becomes visible in the public window copy. There is one  
exception to this rule, in the case where the same variable is updated  
by two concurrent accumulates with the same  
predefined datatype, on the same window. Additional restrictions on the  
operation apply, see the info key <span style="font-size:0.900em;"><font face="sans-serif"> accumulate_ops</span></font> in  
Section <a href="node311.htm#Node311">Window Creation</a>.  
 
<br> 
3.   
A put or accumulate must not access a target window once a  
storeor a put or accumulate update to another (overlapping) window  
has started on a location in the target window, until the  update  
becomes visible in the public copy of the  window.  
Conversely, a store to <font face="sans-serif"> MPI</font> process memory  
to a location in a window must not start once a put or  
accumulate update to that target window has started, until the put or accumulate  
update becomes visible in target process memory.  In both cases, the  
restriction applies to operations even if they access disjoint  
locations in the window.  
</ol> 
 
<br> 
<em> Rationale.</em>  
<P> 
The last constraint on correct <font face="sans-serif"> RMA</font> accesses may seem unduly  
restrictive, as it forbids concurrent accesses to nonoverlapping  
locations in a window.  The reason for this constraint is that, on  
some architectures, explicit coherence restoring operations may be  
needed at synchronization points.  
A different operation may be needed for locations that were  
updated by stores and for locations that were remotely  
updated by put or accumulate operations.  Without this constraint,  
the <font face="sans-serif"> MPI</font> library would have to track  
precisely which locations in a window were updated by a put or  
accumulate operation.  The additional overhead of maintaining such  
information is considered prohibitive.  
 (<em> End of rationale.</em>) <br> 
Note that <font face="sans-serif"> MPI_WIN_SYNC</font> may be used within a passive  
target epoch to synchronize the private and public window copies  
(that is, updates to one are made visible to the other).  
<P> 
In the <font face="sans-serif"> MPI_WIN_UNIFIED</font> memory model, the rules are  
simpler because the public and private windows are the same.  
However, there are restrictions to avoid concurrent access to  
the same memory locations by different <font face="sans-serif"> MPI</font> processes.  
The rules that a program with a well-defined outcome must obey in this case are:  
<P> 
<ol> 
 
1.   
A location in a window must not be accessed  
with load/store accesses once an update to  
that location has started, until the update is complete,   
subject to the special case laid out in Rule <a href="node339.htm#Node339">Semantics and Correctness</a>.  
 
<br> 
2.   
Accessing a location in the  
window that is also the target of a remote update is valid (not  
erroneous) but the precise result will depend on the behavior of the  
implementation.  Updates from an origin process will appear in the memory of  
the target, but there are no atomicity or ordering guarantees  
if more than one byte is updated.  Updates are stable in the sense  
that once data appears in the memory of the target, the data remains until  
replaced by another update.  
This permits polling on a location  
for a change from zero to nonzero or for a particular value, but not  
polling and comparing the relative magnitude of values.  
Users are cautioned that polling on one memory location and  
then accessing a different memory location has defined behavior only  
if the other rules given here and in this chapter are followed.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Some compiler optimizations can result in code that  
maintains the sequential semantics of the program, but violates  
this rule  
by introducing temporary values into locations in memory.  Most  
compilers only apply such transformations under very high levels of  
optimization and users should be aware that such aggressive optimization  
may produce unexpected results.  
 (<em> End of advice to users.</em>) <br> 
 
<br> 
3.   
Updating a location in the  
window with a store access  
  that is also the target of a remote read (but not update) is valid  
  (not erroneous) but the precise result will depend on the behavior  
  of the implementation.  Store  
  updates will appear in  
  memory, but there are no atomicity or ordering guarantees if  
  more than one byte is updated.  Updates are stable in the sense that  
  once data appears in memory, the data remains until replaced by  
  another update. This permits  
  updates to memory  
  with store accesses  
  without requiring an <font face="sans-serif"> RMA</font> epoch.  Users are cautioned that remote accesses to  
  a window that is updated by the local <font face="sans-serif"> MPI</font> process has defined  
  behavior only if the other rules given here and  
  elsewhere in this chapter  
  are followed.  
 
<br> 
4.   
A location in a window must not be accessed as a  
target of an <font face="sans-serif"> RMA</font>   
operation once an update to that location has started and until the  
update completes at the target. There is one  
exception to this rule: in the case where the same location is updated  
by two concurrent accumulates with the same  
predefined datatype on the same window. Additional restrictions on the  
operation apply; see the info key <span style="font-size:0.900em;"><font face="sans-serif"> accumulate_ops</span></font> in  
Section <a href="node311.htm#Node311">Window Creation</a>.  
 
<br> 
5.   
A put or accumulate must not access a target  
window once a store, put, or  
accumulate update to another (overlapping) target window  
has started on the same location in the target window and until the update  
completes at the target window.  
Conversely, a store access  
to a location in a window must not be executed once a put or  
accumulate update to the same location in that target window has started  
and until the put or accumulate  
update completes at the target.    
</ol> 
 
<br> 
<em> Advice to users.</em>  
  
In the unified memory model, in the case where  
the window is in <em> shared memory</em>, <font face="sans-serif"> MPI_WIN_SYNC</font> can be used to order  
store accesses and make store updates to the window visible to  
other <font face="sans-serif"> MPI</font> processes and threads. Use of this routine is necessary to  
ensure portable behavior when point-to-point, collective, or  
<em> shared memory</em> synchronization is used in place of an <font face="sans-serif"> RMA</font>  
synchronization routine. <font face="sans-serif"> MPI_WIN_SYNC</font> should be called by  
both the reader and the writer of a shared memory variable  
between any non-<font face="sans-serif"> RMA</font> synchronization and access to that variable,  
as shown in Example <a href="node344.htm#Node344">Examples</a>.  
The calls to <font face="sans-serif"> MPI_WIN_SYNC</font> can be replaced by language  
level memory synchronization operations, if available.  
 (<em> End of advice to users.</em>) <br> 
  
A program that violates these rules has undefined behavior.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
A user can write correct programs by following the following rules:  
<dl> 
 
<dt> 
<b>fence:</b><dd> 
 During each period between fence calls, each window is  
either updated by put or accumulate operation, or updated by  
stores,  
but not both.  Locations updated by put or accumulate operations  
should not be  
accessed during the same period (with the exception of  
concurrent updates to the same location by accumulate operations).  
Locations accessed by  
get operations should not be updated during the same period.  
 
<dt> 
<b>post-start-complete-wait:</b><dd> 
 A window should not be updated  
with store accesses while posted if it is being updated by put or  
accumulate operations.  Locations updated by put or accumulate  
operations should not be accessed while the window is posted (with the  
exception of concurrent updates to the same location by  
accumulate operations).  
Locations accessed by get operations should not be updated while  
the window is posted.  
<P> 
With the post-start synchronization, the target process can tell  
the origin process that its window is now ready for <font face="sans-serif"> RMA</font> access; with  
the complete-wait synchronization, the origin process can tell the  
target process that it has finished its <font face="sans-serif"> RMA</font> accesses to the   
window.  
 
<dt> 
<b>lock:</b><dd> 
 Updates to the window are protected by <em> exclusive locks</em> if  
they may conflict.  Nonconflicting accesses (such as read-only accesses  
or accumulate accesses) are protected by <em> shared locks</em>,  
both for load/store accesses and for <font face="sans-serif"> RMA</font> accesses.  
 
<dt> 
<b>changing window or synchronization mode:</b><dd> 
&nbsp;&nbsp;&nbsp;  
One can change synchronization mode, or change the window used to  
access a location that belongs to two overlapping windows, when the  
<font face="sans-serif"> MPI</font> process memory and the window copy are guaranteed to have the same  
values.  This is true for an <font face="sans-serif"> MPI</font> process after it has returned from  
<font face="sans-serif"> MPI_WIN_FENCE</font>, if  
<font face="sans-serif"> RMA</font> accesses to the window are synchronized with fences; after it has  
returned from <font face="sans-serif"> MPI_WIN_WAIT</font>, if the accesses are synchronized  
with post-start-complete-wait;  
it is true at the origin and target after the origin returned from a call to  
<font face="sans-serif"> MPI_WIN_UNLOCK</font> or <font face="sans-serif"> MPI_WIN_UNLOCK_ALL</font>   
if the accesses are synchronized with locks.  
</dl> 
<br> 
In addition, an origin process should not access the local buffer of a  
get operation until the operation is complete, and should not update  
the local buffer of a put or accumulate operation until that operation  
is complete.  
<P> 
The <font face="sans-serif"> RMA</font> synchronization operations define when updates are guaranteed  
to become visible in public and private windows. Updates may become  
visible earlier, but such behavior is implementation dependent.  
 (<em> End of advice to users.</em>) <br> 
The following examples illustrate these semantics.  
<P> 
<br><b> Example</b>  
  
The following example demonstrates updating a memory location inside a  
window for the separate memory model, according to  
Rule <a href="node339.htm#Node339">Semantics and Correctness</a>.  The <font face="sans-serif"> MPI_WIN_LOCK</font> and  
<font face="sans-serif"> MPI_WIN_UNLOCK</font> calls around the store to <tt>X</tt> in  
process B are necessary   
to ensure consistency between the public and private copies of the  
window.  
  
<P><img width=906 height=318 src="img45.gif" alt="Image file"><P>
  
  
<P> 
<br><b> Example</b>  
  
In the <font face="sans-serif"> RMA</font> unified model, although the public and private copies  
of the windows are synchronized, caution must be used when  
combining load/store accesses with multi-process synchronization.  
Although the following example appears correct, the compiler or  
hardware may delay the store to <tt>X</tt> after the barrier, possibly  
resulting in the <font face="sans-serif"> MPI_GET</font> returning  
an incorrect value   
of <tt>X</tt>.  
<P> 
  
<P><img width=906 height=242 src="img46.gif" alt="Image file"><P>
  
<font face="sans-serif"> MPI_BARRIER</font> provides process synchronization, but not  
memory  
synchronization.  The example could potentially be made safe through the use  
of compiler- and  
hardware-specific notations to ensure the  
store to <tt>X</tt> occurs   
before process B enters the <font face="sans-serif"> MPI_BARRIER</font>.  The use of one-sided  
synchronization calls, as shown in Example <a href="node339.htm#Node339">Semantics and Correctness</a>, also ensures  
the correct result.  
<P> 
  
<P> 
<br><b> Example</b>  
  
[Read data in <font face="sans-serif"> RMA</font>]NeutralRead data in RMA@Read data in <font face="sans-serif"> RMA</font>MPI_Barrier,MPI_Win_lock,MPI_Win_unlock,MPI_PutThe following example demonstrates the reading of a memory location  
updated by an origin process (Rule <a href="node339.htm#Node339">Semantics and Correctness</a>) in  
the <font face="sans-serif"> RMA</font> separate memory model.  Although the call to  
<font face="sans-serif"> MPI_WIN_UNLOCK</font> on process A and the <font face="sans-serif"> MPI_BARRIER</font>  
ensure that the public copy on process B reflects the updated value of <tt>X</tt>,  
the call to <font face="sans-serif"> MPI_WIN_LOCK</font> by process B is necessary to  
synchronize the private copy with the public copy.  
  
<P><img width=807 height=318 src="img47.gif" alt="Image file"><P>
  
Note that in this example, the barrier is not critical to the semantic  
correctness.  The use of <em> exclusive locks</em> guarantees no other <font face="sans-serif"> MPI</font> process  
will modify the public copy after <font face="sans-serif"> MPI_WIN_LOCK</font>  
synchronizes the private and public copies.  A polling  
implementation looking for changes in <tt>X</tt> on process B would be  
semantically correct.  
The barrier is required to ensure that process A   
completes the put operation at the target before process B executes the load of <tt>X</tt>.  
  
<P> 
<br><b> Example</b>  
[Read data in <font face="sans-serif"> RMA</font> (unsafe)]NeutralRead data in RMA (unsafe)@Read data in <font face="sans-serif"> RMA</font> (unsafe)MPI_Barrier,MPI_Put,MPI_Win_flush,MPI_Win_lock_all,MPI_Win_unlock_allSimilar to Example <a href="node339.htm#Node339">Semantics and Correctness</a>, the following example  
is unsafe even in the unified model, because the load of <tt>X</tt> cannot be  
guaranteed to occur after the <font face="sans-serif"> MPI_BARRIER</font>.  While Process B  
does not need to explicitly synchronize the public and private copies  
through <font face="sans-serif"> MPI_WIN_LOCK</font> as the <font face="sans-serif"> MPI_PUT</font> will update  
 both the public and private copies of the window, the scheduling of  
the load could result in old values of <tt>X</tt> being returned.  Compiler and hardware  
specific notations could ensure the load occurs after the data is updated, or   
explicit one-sided synchronization calls can be used to ensure the proper result.  
<P> 
  
<P><img width=844 height=217 src="img48.gif" alt="Image file"><P>
  
  
<P> 
<br><b> Example</b>  
[Public and private memory in <font face="sans-serif"> RMA</font>]NeutralPublic and private memory in RMA@Public and private memory in <font face="sans-serif"> RMA</font>MPI_Barrier,MPI_Win_lock,MPI_Win_unlock,MPI_GetThe following example further clarifies    
Rule <a href="node339.htm#Node339">Semantics and Correctness</a>.  <font face="sans-serif"> MPI_WIN_LOCK</font> and  
<font face="sans-serif"> MPI_WIN_LOCK_ALL</font> do <em> not</em> update the public copy of  
a window with changes to the private copy.  Therefore, there is no  
guarantee that process A in the  
following sequence will see the value of <tt>X</tt> as updated by the  
store by process B before the lock.  
<P> 
  
<P><img width=906 height=293 src="img49.gif" alt="Image file"><P>
  
The addition of a call to <font face="sans-serif"> MPI_WIN_SYNC</font> before the call to  
<font face="sans-serif"> MPI_BARRIER</font> by process B would guarantee process A would  
see the updated value of <tt>X</tt>, as the public copy of the window would be  
explicitly synchronized with the private copy.  
  
<P> 
<br><b> Example</b>  
[Public and private memory in <font face="sans-serif"> RMA</font>]NeutralPublic and private memory in RMA@Public and private memory in <font face="sans-serif"> RMA</font>MPI_Barrier,MPI_Win_lock,MPI_Win_unlock,MPI_Win_post,MPI_Win_start,MPI_Win_complete,MPI_Win_wait,MPI_GetSimilar to the previous example, Rule <a href="node339.htm#Node339">Semantics and Correctness</a> can  
have unexpected implications for general active target synchronization  
with the <font face="sans-serif"> RMA</font> separate memory model.  It is <em> not</em> guaranteed  
that process B reads the value of <tt>X</tt> as per the local update by process  
A, because neither the call to <font face="sans-serif"> MPI_WIN_WAIT</font> nor  
the call to <font face="sans-serif"> MPI_WIN_COMPLETE</font> by process A ensure visibility in  
the public window copy.  
  
<P><img width=894 height=492 src="img50.gif" alt="Image file"><P>
  
To allow process B to read the value of <tt>X</tt> stored by A, the local store must be  
replaced by a local put operation that updates the public window  
copy.  Note that by this replacement <tt>X</tt> may become visible in the  
private copy of process A only after the  
<font face="sans-serif"> MPI_WIN_WAIT</font> call in process A.  The update to <tt>Y</tt> made  
before the <font face="sans-serif"> MPI_WIN_POST</font> call is visible in the public  
window after the <font face="sans-serif"> MPI_WIN_POST</font> call and therefore process B  
will read the proper value of <tt>Y</tt>.  The get of <tt>Y</tt> could  
be moved to the epoch opened by <font face="sans-serif"> MPI_WIN_START</font>,  
and process B would still get the value stored by process A.  
  
<P> 
<br><b> Example</b>  
[Active target and local reads in <font face="sans-serif"> RMA</font>]NeutralActive target and local reads in RMA@Active target and local reads in <font face="sans-serif"> RMA</font>MPI_Barrier,MPI_Win_lock,MPI_Win_unlock,MPI_Win_post,MPI_Win_start,MPI_Win_complete,MPI_Win_wait,MPI_PutThe following example demonstrates the interaction of general  
active target synchronization with load accesses in the  
<font face="sans-serif"> RMA</font> separate memory model.  Rules <a href="node339.htm#Node339">Semantics and Correctness</a>  
and <a href="node339.htm#Node339">Semantics and Correctness</a> do <em> not</em> guarantee that the  
private copy of <tt>X</tt> at process B has been updated before the load access is executed.  
<P> 
  
<P><img width=844 height=416 src="img51.gif" alt="Image file"><P>
  
To ensure that the value put by process A is read, the load access must  
be replaced with a get operation, or must be  
placed after the call to <font face="sans-serif"> MPI_WIN_WAIT</font>.  
  
<P> 
<ul> 
</ul> 

<P>
<hr>
<a href="node338.htm#Node338"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node308.htm#Node308"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node340.htm#Node340"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node308.htm#Node308"> One-Sided Communications</a>
<b>Next: </b><a href="node340.htm#Node340"> Atomicity</a>
<b>Previous: </b><a href="node338.htm#Node338"> Error Classes</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
