<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-datatypes/datatypes-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Decoding a Datatype</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h2><span id="Node111">6.1.13. Decoding a Datatype</span></h2>
<a href="node110.htm#Node110"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node112.htm#Node112"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node112.htm#Node112"> Examples</a>
<b>Previous: </b><a href="node110.htm#Node110"> Correct Use of Addresses</a>
<p>
  
  
<P> 
<font face="sans-serif"> MPI</font>  
datatype objects  
allow users to specify  
an arbitrary layout of data in memory.  
There are several cases  
where accessing the layout information in  
opaque datatype objects would be useful.  
The opaque datatype  
object has found a number of uses outside <font face="sans-serif"> MPI</font>.  Furthermore, a  
number of tools wish to display internal information about a datatype.  
To achieve this, datatype decoding procedures are provided.  
The two procedures in this section are used together to decode datatypes  
to recreate the calling sequence used in their initial definition.  
These can be used to allow a user to determine the type map and type  
signature of a datatype.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_ENVELOPE(<span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">num_integers</span>, <span style="white-space:nowrap">num_addresses</span>, <span style="white-space:nowrap">num_large_counts</span>, <span style="white-space:nowrap">num_datatypes</span>, <span style="white-space:nowrap">combiner</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype to decode (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> num_integers</TD><TD>number of input integers used in call constructing <font face="sans-serif"> combiner</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> num_addresses</TD><TD>number of input addresses used in call constructing <font face="sans-serif"> combiner</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> num_large_counts</TD><TD>number of input large counts used in call constructing <font face="sans-serif"> combiner</font> (nonnegative integer, <b> only present for large count variants</b>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> num_datatypes</TD><TD>number of input datatypes used in call constructing <font face="sans-serif"> combiner</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> combiner</TD><TD>combiner (state)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_get_envelope(MPI_Datatype datatype, int *num_integers, int *num_addresses, int *num_datatypes, int *combiner) <br></tt>  
  
  <tt> int MPI_Type_get_envelope_c(MPI_Datatype datatype, MPI_Count *num_integers, MPI_Count *num_addresses, MPI_Count *num_large_counts, MPI_Count *num_datatypes, int *combiner) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_get_envelope(datatype, num_integers, num_addresses, num_datatypes, combiner, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">num_integers</span>, <span style="white-space:nowrap">num_addresses</span>, <span style="white-space:nowrap">num_datatypes</span>, <span style="white-space:nowrap">combiner</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_get_envelope(datatype, num_integers, num_addresses, num_large_counts, num_datatypes, combiner, ierror) !(_c) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">num_integers</span>, <span style="white-space:nowrap">num_addresses</span>, <span style="white-space:nowrap">num_large_counts</span>, <span style="white-space:nowrap">num_datatypes</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">combiner</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_GET_ENVELOPE(DATATYPE, NUM_INTEGERS, NUM_ADDRESSES, NUM_DATATYPES, COMBINER, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">NUM_INTEGERS</span>, <span style="white-space:nowrap">NUM_ADDRESSES</span>, <span style="white-space:nowrap">NUM_DATATYPES</span>, <span style="white-space:nowrap">COMBINER</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
For the given <font face="sans-serif"> datatype</font>,  
<font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> returns information on the  
number and type of input arguments used in the call that created the  
<font face="sans-serif"> datatype</font>.  The number-of-arguments values returned can be  
used to provide sufficiently large arrays in the decoding routine  
<font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font>.  This call and the meaning of the  
returned values is described below.  The <font face="sans-serif"> combiner</font> reflects  
the <font face="sans-serif"> MPI</font> datatype constructor call that was used in creating  
<font face="sans-serif"> datatype</font>.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
By requiring that the <font face="sans-serif"> combiner</font> reflect the constructor used  
in the creation  
of the <font face="sans-serif"> datatype</font>, the decoded information can be used  
to effectively recreate the calling sequence used in the original  
creation.  
This is the most useful information and  
was  
felt to be reasonable even though it constrains implementations to  
remember the original constructor sequence even if the internal  
representation is different.  
<P> 
The decoded information keeps track of datatype duplications.  This is  
important as one needs to distinguish between a predefined datatype  
and a dup of a predefined datatype.  The former is a constant object  
that cannot be freed, while the latter is a derived datatype that can  
be freed.  
 (<em> End of rationale.</em>) <br> 
The list of values that can be returned from <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> in  
<font face="sans-serif"> combiner</font> (on the left) and the call associated with them (on the right) are as follows:  
  
    <TABLE><TR><TD ALIGN="LEFT">[180pt]  
 
<li>[<font face="sans-serif"> MPI_COMBINER_NAMED</font>]a named predefined datatype  
 
<li>[<font face="sans-serif"> MPI_COMBINER_DUP</font>]<font face="sans-serif"> MPI_TYPE_DUP</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_CONTIGUOUS</font>]<font face="sans-serif"> MPI_TYPE_CONTIGUOUS</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_VECTOR</font>]<font face="sans-serif"> MPI_TYPE_VECTOR</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_HVECTOR</font>]<font face="sans-serif"> MPI_TYPE_CREATE_HVECTOR</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_INDEXED</font>]<font face="sans-serif"> MPI_TYPE_INDEXED</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_HINDEXED</font>]<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_INDEXED_BLOCK</font>]<font face="sans-serif"> MPI_TYPE_CREATE_INDEXED_BLOCK</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_HINDEXED_BLOCK</font>]<font face="sans-serif"> MPI_TYPE_CREATE_HINDEXED_BLOCK</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_STRUCT</font>]<font face="sans-serif"> MPI_TYPE_CREATE_STRUCT</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_SUBARRAY</font>]<font face="sans-serif"> MPI_TYPE_CREATE_SUBARRAY</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_DARRAY</font>]<font face="sans-serif"> MPI_TYPE_CREATE_DARRAY</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_F90_REAL</font>]<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_F90_COMPLEX</font>]<font face="sans-serif"> MPI_TYPE_CREATE_F90_COMPLEX</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_F90_INTEGER</font>]<font face="sans-serif"> MPI_TYPE_CREATE_F90_INTEGER</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_RESIZED</font>]<font face="sans-serif"> MPI_TYPE_CREATE_RESIZED</font>  
 
<li>[<font face="sans-serif"> MPI_COMBINER_VALUE_INDEX</font>]<font face="sans-serif"> MPI_TYPE_GET_VALUE_INDEX</font>  
</TD><TD></TD></TR></TABLE> 
If <font face="sans-serif"> combiner</font> is <font face="sans-serif"> MPI_COMBINER_NAMED</font> then <font face="sans-serif"> datatype</font> is a  
named predefined datatype.  
<P> 
If the <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> variant without  
<font face="sans-serif"> num_large_counts</font> is invoked with a <font face="sans-serif"> datatype</font> that  
requires an output value of <font face="sans-serif"> num_large_counts</font> <i>&gt;0</i>,  
then an error of class <span style="font-size:0.900em;"><font face="sans-serif"> MPI_ERR_TYPE</span></font> is raised.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The large count variant of this <font face="sans-serif"> MPI</font> procedure was added in <font face="sans-serif"> MPI-4</font>.  
  It contains a new <font face="sans-serif"> num_large_counts</font> parameter.  The  
  other variant---the variant that existed before <font face="sans-serif"> MPI-4</font>---was  
  not changed in order to preserve backwards compatibility.  
 (<em> End of rationale.</em>) <br> 
The actual arguments used in the creation call for a <font face="sans-serif"> datatype</font>  
can be obtained using <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font>.  
<P> 
<font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font> and <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font> also support large count types in  
separate additional <font face="sans-serif"> MPI</font> procedures in C (suffixed with the ``<tt>_c</tt>'') and interface  
polymorphism  in Fortran when using <tt>USE mpi_f08</tt>.  
<P> 
<TABLE><TR><TD COLSPAN=2>MPI_TYPE_GET_CONTENTS(<span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">max_integers</span>, <span style="white-space:nowrap">max_addresses</span>, <span style="white-space:nowrap">max_large_counts</span>, <span style="white-space:nowrap">max_datatypes</span>, <span style="white-space:nowrap">array_of_integers</span>, <span style="white-space:nowrap">array_of_addresses</span>, <span style="white-space:nowrap">array_of_large_counts</span>, <span style="white-space:nowrap">array_of_datatypes</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>datatype to decode (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> max_integers</TD><TD>number of elements in <font face="sans-serif"> array_of_integers</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> max_addresses</TD><TD>number of elements in <font face="sans-serif"> array_of_addresses</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> max_large_counts</TD><TD>number of elements in <font face="sans-serif"> array_of_large_counts</font> (nonnegative integer, <b> only present for large count variants</b>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> max_datatypes</TD><TD>number of elements in <font face="sans-serif"> array_of_datatypes</font> (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_integers</TD><TD>contains integer arguments used in constructing <font face="sans-serif"> datatype</font> (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_addresses</TD><TD>contains address arguments used in constructing <font face="sans-serif"> datatype</font> (array of integers)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_large_counts</TD><TD>contains large count arguments used in constructing <font face="sans-serif"> datatype</font> (array of integers, <b> only present for large count variants</b>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> array_of_datatypes</TD><TD>contains datatype arguments used in constructing <font face="sans-serif"> datatype</font> (array of handles)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Type_get_contents(MPI_Datatype datatype, int max_integers, int max_addresses, int max_datatypes, int array_of_integers[], MPI_Aint array_of_addresses[], MPI_Datatype array_of_datatypes[]) <br></tt>  
  
  <tt> int MPI_Type_get_contents_c(MPI_Datatype datatype, MPI_Count max_integers, MPI_Count max_addresses, MPI_Count max_large_counts, MPI_Count max_datatypes, int array_of_integers[], MPI_Aint array_of_addresses[], MPI_Count array_of_large_counts[], MPI_Datatype array_of_datatypes[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Type_get_contents(datatype, max_integers, max_addresses, max_datatypes, array_of_integers, array_of_addresses, array_of_datatypes, ierror) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">max_integers</span>, <span style="white-space:nowrap">max_addresses</span>, <span style="white-space:nowrap">max_datatypes</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">array_of_integers(max_integers)</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: <span style="white-space:nowrap">array_of_addresses(max_addresses)</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">array_of_datatypes(max_datatypes)</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Type_get_contents(datatype, max_integers, max_addresses, max_large_counts, max_datatypes, array_of_integers, array_of_addresses, array_of_large_counts, array_of_datatypes, ierror) !(_c) <br> TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">max_integers</span>, <span style="white-space:nowrap">max_addresses</span>, <span style="white-space:nowrap">max_large_counts</span>, <span style="white-space:nowrap">max_datatypes</span><br>INTEGER, INTENT(OUT) :: <span style="white-space:nowrap">array_of_integers(max_integers)</span><br>INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(OUT) :: <span style="white-space:nowrap">array_of_addresses(max_addresses)</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(OUT) :: <span style="white-space:nowrap">array_of_large_counts(max_large_counts)</span><br>TYPE(MPI_Datatype), INTENT(OUT) :: <span style="white-space:nowrap">array_of_datatypes(max_datatypes)</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_TYPE_GET_CONTENTS(DATATYPE, MAX_INTEGERS, MAX_ADDRESSES, MAX_DATATYPES, ARRAY_OF_INTEGERS, ARRAY_OF_ADDRESSES, ARRAY_OF_DATATYPES, IERROR) <br> INTEGER <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">MAX_INTEGERS</span>, <span style="white-space:nowrap">MAX_ADDRESSES</span>, <span style="white-space:nowrap">MAX_DATATYPES</span>, <span style="white-space:nowrap">ARRAY_OF_INTEGERS(*)</span>, <span style="white-space:nowrap">ARRAY_OF_DATATYPES(*)</span>, <span style="white-space:nowrap">IERROR</span><br>INTEGER(KIND=MPI_ADDRESS_KIND) <span style="white-space:nowrap">ARRAY_OF_ADDRESSES(*)</span> <br></tt>  
<P> 
<font face="sans-serif"> datatype</font> must be a predefined unnamed or a derived datatype;  
the call is erroneous if <font face="sans-serif"> datatype</font> is a predefined named  
datatype.  
<P> 
The values given for <font face="sans-serif"> max_integers</font>, <font face="sans-serif"> max_addresses</font>,  
<font face="sans-serif"> max_large_counts</font>,  
and <font face="sans-serif"> max_datatypes</font>  
must be at least as large as the value  
returned in <font face="sans-serif"> num_integers</font>, <font face="sans-serif"> num_addresses</font>,  
<font face="sans-serif"> num_large_counts</font>,  
and <font face="sans-serif"> num_datatypes</font>,  
respectively, in the call <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font>  
for the same <font face="sans-serif"> datatype</font> argument.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The arguments <font face="sans-serif"> max_integers</font>, <font face="sans-serif"> max_addresses</font>,  
<font face="sans-serif"> max_large_counts</font>,  
and  
<font face="sans-serif"> max_datatypes</font> allow for error checking in the  
call.  
 (<em> End of rationale.</em>) <br> 
If the <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font> variant without  
<font face="sans-serif"> max_large_counts</font> is invoked with a <font face="sans-serif"> datatype</font> that  
requires <i>&gt;0</i> values in <font face="sans-serif"> array_of_large_counts</font>,  
then an error of class <span style="font-size:0.900em;"><font face="sans-serif"> MPI_ERR_TYPE</span></font> is raised.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The large count variant of this <font face="sans-serif"> MPI</font> procedure was added in <font face="sans-serif"> MPI-4</font>.  
  It contains new <font face="sans-serif"> max_large_counts</font> and  
  <font face="sans-serif"> array_of_large_counts</font> parameters.  The  
  other variant---the variant that existed before <font face="sans-serif"> MPI-4</font>---was  
  not changed in order to preserve backwards compatibility.  
 (<em> End of rationale.</em>) <br> 
The datatypes returned in <font face="sans-serif"> array_of_datatypes</font> are handles to  
datatype objects that are equivalent to the datatypes used in the  
original construction call.  If these were derived datatypes, then  
the returned datatypes are new datatype objects, and the  
user is responsible for freeing these datatypes with  
<font face="sans-serif"> MPI_TYPE_FREE</font>.  
If these were predefined datatypes, then  
the returned datatype is equal to that (constant) predefined datatype  
and cannot be freed.  
<P> 
The committed state of returned derived datatypes is undefined,  
i.e., the datatypes may or  
may not be committed.  Furthermore, the content of attributes of  
returned datatypes is undefined.  
<P> 
Note that <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font> can be invoked with a  
<font face="sans-serif"> datatype</font> argument that was constructed using  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_REAL</font>,  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_INTEGER</font>, or  
<font face="sans-serif"> MPI_TYPE_CREATE_F90_COMPLEX</font>  (an unnamed predefined datatype).  
In such a case, an empty <font face="sans-serif"> array_of_datatypes</font> is returned.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
The definition of datatype equivalence implies that equivalent  
predefined datatypes are equal.  
By requiring the same handle for named predefined datatypes, it is  
possible to use the <tt>==</tt> or <tt>.EQ.</tt> comparison operator to determine the  
datatype involved.  
 (<em> End of rationale.</em>) <br> 
 
<br> 
<em> Advice  
        to implementors.</em>  
<P> 
The datatypes returned in <font face="sans-serif"> array_of_datatypes</font> must appear to the  
user as if each is an equivalent copy of the datatype used in the type  
constructor call.  
Whether this is done by  
creating a new datatype or via another mechanism such as a reference  
count mechanism is up to the implementation as long as the semantics  
are preserved.  
 (<em> End of advice to implementors.</em>) <br> 
 
<br> 
<em> Rationale.</em>  
<P> 
The committed state and attributes of the returned datatype is  
deliberately left vague.  The datatype used in the original  
construction may have been modified since its use in the constructor  
call.  Attributes can be added, removed, or modified as well as having  
the datatype committed.  The semantics given allow for a  
reference count implementation without having to track these changes.  
 (<em> End of rationale.</em>) <br> 
In the  
deprecated  
 datatype constructor calls, the address arguments in Fortran are of  
type <tt> INTEGER</tt>.  In the  
preferred  
calls, the address arguments are of  
type <font face="sans-serif"> INTEGER(KIND=MPI_ADDRESS_KIND)</font> .  The call  
<font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font> returns all addresses in an argument  
of type <font face="sans-serif"> INTEGER(KIND=MPI_ADDRESS_KIND)</font> .  This is true even if the  
deprecated  
 calls were used.  Thus, the location of values returned can  
be thought of as being returned by the C bindings.  It can also be  
determined by examining the  
preferred  
 calls for datatype constructors  
for the  
deprecated  
calls that involve addresses.  
<P> 
 
<br> 
<em> Rationale.</em>  
<P> 
By having all address arguments returned in the  
<font face="sans-serif"> array_of_addresses</font> argument, the result from a C and Fortran  
decoding of a <font face="sans-serif"> datatype</font> gives the result in the same  
argument.  It is assumed that an integer  
of type <font face="sans-serif"> INTEGER(KIND=MPI_ADDRESS_KIND)</font>  will be at least as large as  
the <tt> INTEGER</tt> argument used in datatype construction with the old <font face="sans-serif"> MPI-1</font>  
calls so no loss of information will occur.  
 (<em> End of rationale.</em>) <br> 
The following defines what values are placed in each entry of the  
returned arrays depending on the datatype constructor used for  
<font face="sans-serif"> datatype</font>.  It also specifies the size of the arrays needed,  
which is the values returned by <font face="sans-serif"> MPI_TYPE_GET_ENVELOPE</font>.  
In Fortran, the following calls were made:  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt>PARAMETER (LARGE = 1000) 
<b>INTEGER</b> DTYPE, NI, NA, ND, COMBINER, I(LARGE), D(LARGE), IERROR 
<b>INTEGER</b>(<b>KIND</b>=<b>MPI_ADDRESS_KIND</b>) A(LARGE) 
! CONSTRUCT DATATYPE DTYPE (NOT SHOWN) 
<b>CALL</b> <b>MPI_TYPE_GET_ENVELOPE</b>(DTYPE, NI, NA, ND, COMBINER, IERROR) 
<b>IF</b> ((NI .GT. LARGE) .OR. (NA .GT. LARGE) .OR. (ND .GT. LARGE)) <b>THEN</b> 
   <b>WRITE</b> (*, *) "NI, NA, OR ND = ", NI, NA, ND, &amp; 
   " RETURNED BY MPI_TYPE_GET_ENVELOPE IS LARGER THAN LARGE = ", LARGE 
   <b>CALL</b> <b>MPI_ABORT</b>(<b>MPI_COMM_WORLD</b>, 99, IERROR) 
ENDIF 
<b>CALL</b> <b>MPI_TYPE_GET_CONTENTS</b>(DTYPE, NI, NA, ND, I, A, D, IERROR) 
</tt></pre> 
  
<P> 
  
or in C the analogous calls of:  
<P> 
<br> 
<pre style="background-color:#EFEFEF"><tt><b>#define</b> LARGE 1000 
<b>int</b> ni, na, nd, combiner, i[LARGE]; 
<b>MPI_Aint</b> a[LARGE]; 
<b>MPI_Datatype</b> dtype, d[LARGE]; 
/* construct datatype dtype (not shown) */ 
<b>MPI_Type_get_envelope</b>(dtype, &amp;ni, &amp;na, &amp;nd, &amp;combiner); 
<b>if</b> ((ni &gt; LARGE) || (na &gt; LARGE) || (nd &gt; LARGE)) { 
   fprintf(stderr, "ni, na, or nd = %d %d %d returned by ", ni, na, nd); 
   fprintf(stderr, "MPI_Type_get_envelope is larger than LARGE = %d\n", 
           LARGE); 
   <b>MPI_Abort</b>(<b>MPI_COMM_WORLD</b>, 99); 
} 
<b>MPI_Type_get_contents</b>(dtype, ni, na, nd, i, a, d); 
</tt></pre> 
  
<P> 
  
The following describes the values of the arguments for each combiner.  
The lower case name of arguments is used.  
Also, the descriptions below refer to <font face="sans-serif"> MPI</font> datatypes created by  
procedures without large count arguments.  
<dl> 
[style=unboxed,leftmargin=0cm]  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_NAMED</font></b><dd> 
  
the <font face="sans-serif"> datatype</font> represents a predefined type and therefore  
it is erroneous to call <font face="sans-serif"> MPI_TYPE_GET_CONTENTS</font>.  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_DUP</font></b><dd> 
  
<tt>ni = 0</tt>, <tt>na = 0</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">  C</TD><TD ALIGN="CENTER">    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="CENTER">          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_CONTIGUOUS</font></b><dd> 
  
<tt>ni = 1</tt>, <tt>na = 0</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">  C</TD><TD ALIGN="CENTER">    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">                 i[0]</TD><TD ALIGN="CENTER">          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="CENTER">          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_VECTOR</font></b><dd> 
  
<tt>ni = 3</tt>, <tt>na = 0</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">  C</TD><TD ALIGN="CENTER">    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">                 i[0]</TD><TD ALIGN="CENTER">          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
blocklength</TD><TD ALIGN="CENTER">           i[1]</TD><TD ALIGN="CENTER">          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
stride</TD><TD ALIGN="CENTER">                i[2]</TD><TD ALIGN="CENTER">          I(3)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="CENTER">          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_HVECTOR</font></b><dd> 
  
<tt>ni = 2</tt>, <tt>na = 1</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">  C</TD><TD ALIGN="CENTER">    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">                 i[0]</TD><TD ALIGN="CENTER">          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
blocklength</TD><TD ALIGN="CENTER">           i[1]</TD><TD ALIGN="CENTER">          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
stride</TD><TD ALIGN="CENTER">                a[0]</TD><TD ALIGN="CENTER">          A(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">               d[0]</TD><TD ALIGN="CENTER">          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_INDEXED</font></b><dd> 
  
<tt>ni = 2*count+1</tt>, <tt>na = 0</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">       i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_blocklengths</TD><TD ALIGN="CENTER">       i[1] to i[i[0]]</TD><TD ALIGN="CENTER">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      i[i[0]+1] to i[2*i[0]]</TD><TD ALIGN="CENTER">        I(I(1)+2) to I(2*I(1)+1)        </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_HINDEXED</font></b><dd> 
  
<tt>ni = count+1</tt>, <tt>na = count</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">       i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_blocklengths</TD><TD ALIGN="CENTER">       i[1] to i[i[0]]</TD><TD ALIGN="CENTER">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      a[0] to a[i[0]-1]</TD><TD ALIGN="CENTER">             A(1) to A(I(1))                 </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_INDEXED_BLOCK</font></b><dd> 
  
<tt>ni = count+2</tt>, <tt>na = 0</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">       i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
blocklength</TD><TD ALIGN="CENTER">       i[1]</TD><TD ALIGN="CENTER">                          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      i[2] to i[i[0]+1]</TD><TD ALIGN="CENTER">             I(3) to I(I(1)+2)    </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_HINDEXED_BLOCK</font></b><dd> 
  
<tt>ni = 2</tt>, <tt>na = count</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">       i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
blocklength</TD><TD ALIGN="CENTER">       i[1]</TD><TD ALIGN="CENTER">                          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      a[0] to a[i[0]-1]</TD><TD ALIGN="CENTER">             A(1) to A(I(1))                 </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_STRUCT</font></b><dd> 
  
<tt>ni = count+1</tt>, <tt>na = count</tt>, <tt>nd = count</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">count</TD><TD ALIGN="CENTER">                         i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_blocklengths</TD><TD ALIGN="CENTER">       i[1] to i[i[0]]</TD><TD ALIGN="CENTER">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_displacements</TD><TD ALIGN="CENTER">      a[0] to a[i[0]-1]</TD><TD ALIGN="CENTER">             A(1) to A(I(1))                 </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_types</TD><TD ALIGN="CENTER">              d[0] to d[i[0]-1]</TD><TD ALIGN="CENTER">             D(1) to D(I(1))                 </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_SUBARRAY</font></b><dd> 
  
<tt>ni = 3*ndims+2</tt>, <tt>na = 0</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">ndims</TD><TD ALIGN="CENTER">                         i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_sizes</TD><TD ALIGN="CENTER">              i[1] to i[i[0]]</TD><TD ALIGN="CENTER">               I(2) to I(I(1)+1)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_subsizes</TD><TD ALIGN="CENTER">           i[i[0]+1] to i[2*i[0]]</TD><TD ALIGN="CENTER">        I(I(1)+2) to I(2*I(1)+1)        </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_starts</TD><TD ALIGN="CENTER">             i[2*i[0]+1] to i[3*i[0]]</TD><TD ALIGN="CENTER">      I(2*I(1)+2) to I(3*I(1)+1)      </TD></TR> 
<TR><TD ALIGN="LEFT">  
order</TD><TD ALIGN="CENTER">                         i[3*i[0]+1]</TD><TD ALIGN="CENTER">                   I(3*I(1)+2]                     </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_DARRAY</font></b><dd> 
  
<tt>ni = 4*ndims+4</tt>, <tt>na = 0</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">size</TD><TD ALIGN="CENTER">                          i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
rank</TD><TD ALIGN="CENTER">                          i[1]</TD><TD ALIGN="CENTER">                          I(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
ndims</TD><TD ALIGN="CENTER">                         i[2]</TD><TD ALIGN="CENTER">                          I(3)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_gsizes</TD><TD ALIGN="CENTER">             i[3] to i[i[2]+2]</TD><TD ALIGN="CENTER">             I(4) to I(I(3)+3)               </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_distribs</TD><TD ALIGN="CENTER">           i[i[2]+3] to i[2*i[2]+2]</TD><TD ALIGN="CENTER">      I(I(3)+4) to I(2*I(3)+3)        </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_dargs</TD><TD ALIGN="CENTER">              i[2*i[2]+3] to i[3*i[2]+2]</TD><TD ALIGN="CENTER">    I(2*I(3)+4) to I(3*I(3)+3)      </TD></TR> 
<TR><TD ALIGN="LEFT">  
array_of_psizes</TD><TD ALIGN="CENTER">             i[3*i[2]+3] to i[4*i[2]+2]</TD><TD ALIGN="CENTER">    I(3*I(3)+4) to I(4*I(3)+3)      </TD></TR> 
<TR><TD ALIGN="LEFT">  
order</TD><TD ALIGN="CENTER">                         i[4*i[2]+3]</TD><TD ALIGN="CENTER">                   I(4*I(3)+4)                     </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_F90_REAL</font></b><dd> 
  
<tt>ni = 2</tt>, <tt>na = 0</tt>, <tt>nd = 0</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">p</TD><TD ALIGN="CENTER">                             i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
r</TD><TD ALIGN="CENTER">                             i[1]</TD><TD ALIGN="CENTER">                          I(2)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_F90_COMPLEX</font></b><dd> 
  
<tt>ni = 2</tt>, <tt>na = 0</tt>, <tt>nd = 0</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">p</TD><TD ALIGN="CENTER">                             i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
r</TD><TD ALIGN="CENTER">                             i[1]</TD><TD ALIGN="CENTER">                          I(2)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_F90_INTEGER</font></b><dd> 
  
<tt>ni = 1</tt>, <tt>na = 0</tt>, <tt>nd = 0</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">r</TD><TD ALIGN="CENTER">                             i[0]</TD><TD ALIGN="CENTER">                          I(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_RESIZED</font></b><dd> 
  
<tt>ni = 0</tt>, <tt>na = 2</tt>, <tt>nd = 1</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">lb</TD><TD ALIGN="CENTER">                            a[0]</TD><TD ALIGN="CENTER">                          A(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
extent</TD><TD ALIGN="CENTER">                        a[1]</TD><TD ALIGN="CENTER">                          A(2)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
oldtype</TD><TD ALIGN="CENTER">                       d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
 
<dt> 
<b><font face="sans-serif"> MPI_COMBINER_VALUE_INDEX</font></b><dd> 
  
<tt>ni = 0</tt>, <tt>na = 0</tt>, <tt>nd = 2</tt>, and  
<P> 
<div style="text-align:center">  
<TABLE><TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">Constructor argument</TD><TD ALIGN="CENTER">          C</TD><TD ALIGN="CENTER">                    Fortran location                </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
<TR><TD ALIGN="LEFT">value_type</TD><TD ALIGN="CENTER">                   d[0]</TD><TD ALIGN="CENTER">                          D(1)                            </TD></TR> 
<TR><TD ALIGN="LEFT">  
index_type</TD><TD ALIGN="CENTER">                   d[1]</TD><TD ALIGN="CENTER">                          D(2)                            </TD></TR> 
<TR><TD colspan="3" style="border-top:solid 1px;margin:0 0 0 0"></TD></TR> 
</TABLE> 
</div>  
<P> 
</dl> 
<br> 

<P>
<hr>
<a href="node110.htm#Node110"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node98.htm#Node98"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node112.htm#Node112"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node98.htm#Node98"> Derived Datatypes</a>
<b>Next: </b><a href="node112.htm#Node112"> Examples</a>
<b>Previous: </b><a href="node110.htm#Node110"> Correct Use of Addresses</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
