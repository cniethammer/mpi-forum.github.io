<!DOCTYPE html>
<html lang=en>
<head>
<!-- This file was generated by tohtml from chap-pt2pt/pt2pt-rendered -->
<!-- with the command
tohtml -default -numbers -dosnl -htables -quietlatex -allgif -endpage mpi5-forum-tail.htm -Wnoredef --mpidoc --latexpgm pdflatex --indexfile mpi50-report-html.idx --lstlisting -basedef mpi5defs.txt -o mpi50-report.tex mpi-reporthtml.tex 
-->
<title>Persistent Communication Requests</title>
</head>
<body style="background-color:#FFFFFF">
<hr><h1><span id="Node85">4.9. Persistent Communication Requests</span></h1>
<a href="node84.htm#Node84"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node55.htm#Node55"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node86.htm#Node86"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node55.htm#Node55"> Point-to-Point Communication</a>
<b>Next: </b><a href="node86.htm#Node86"> Null <font face="sans-serif"> MPI</font> Processes</a>
<b>Previous: </b><a href="node84.htm#Node84"> Cancel</a>
<p>
  
  
  
  
<P> 
Often a communication with the same argument list (with the exception of the buffer contents) is repeatedly  
executed within the inner loop of a parallel computation.  In such a  
situation, it may be possible to optimize the communication by  
binding the list of communication arguments to a <em> persistent communication request</em>  
once and then repeatedly using  
the request to <em> start</em> and <em> complete</em> operations.In the case of point-to-point communication, the  
<em> persistent communication request</em> thus created can be thought of as a  
communication port or a ``half-channel.''  
It does not provide the full functionality of a conventional channel,  
since there is no binding of the send port to the receive port. This  
construct allows the reduction of the overhead for communication  
between the <font face="sans-serif"> MPI</font> process and communication controller, but not of the overhead for  
communication between one communication controller and another.  
It is not necessary that messages sent with a persistent point-to-point request be received  
by a receive operation using a persistent point-to-point request, or vice versa.  
<P> 
There are also persistent collective communication operations defined in  
Section <a href="node161.htm#Node161">Persistent Collective Operations</a> and Section <a href="node240.htm#Node240">Persistent Neighborhood Communication on Process Topologies</a>.  
The remainder of this section covers the point-to-point  
persistent <em> initialization</em> operations and the start  
routines, which are used for persistent point-to-point, partitioned point-to-point, and  
persistent collective communication operations.  
<P> 
A point-to-point <b> persistent communication request</b> is created using one of the  
five  
following calls.  These point-to-point persistent <em> initialization</em> calls involve no communication.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_SEND_INIT(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements sent (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Send_init(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_Send_init_c(const void *buf, MPI_Count count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Send_init(buf, count, datatype, dest, tag, comm, request, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Send_init(buf, count, datatype, dest, tag, comm, request, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">DEST</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Creates a <em> persistent communication request</em>  
for a <em> standard mode send</em> operation.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_BSEND_INIT(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements sent (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Bsend_init(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_Bsend_init_c(const void *buf, MPI_Count count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Bsend_init(buf, count, datatype, dest, tag, comm, request, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Bsend_init(buf, count, datatype, dest, tag, comm, request, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_BSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">DEST</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Creates a <em> persistent communication request</em>  
for a <em> buffered mode send</em> operation.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_SSEND_INIT(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements sent (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Ssend_init(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_Ssend_init_c(const void *buf, MPI_Count count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Ssend_init(buf, count, datatype, dest, tag, comm, request, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Ssend_init(buf, count, datatype, dest, tag, comm, request, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_SSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">DEST</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Creates a <em> persistent communication request</em>  
for a <em> synchronous mode send</em> operation.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_RSEND_INIT(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> buf</TD><TD>initial address of send buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements sent (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> dest</TD><TD>rank of destination (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Rsend_init(const void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_Rsend_init_c(const void *buf, MPI_Count count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Rsend_init(buf, count, datatype, dest, tag, comm, request, ierror) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Rsend_init(buf, count, datatype, dest, tag, comm, request, ierror) !(_c) <br> TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">dest</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_RSEND_INIT(BUF, COUNT, DATATYPE, DEST, TAG, COMM, REQUEST, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">DEST</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Creates a <em> persistent communication request</em>  
for a <em> ready mode send</em> operation.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_RECV_INIT(<span style="white-space:nowrap">buf</span>, <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">datatype</span>, <span style="white-space:nowrap">source</span>, <span style="white-space:nowrap">tag</span>, <span style="white-space:nowrap">comm</span>, <span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> buf</TD><TD>initial address of receive buffer (choice)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>number of elements received (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> datatype</TD><TD>type of each element (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> source</TD><TD>rank of source or <font face="sans-serif"> MPI_ANY_SOURCE</font> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> tag</TD><TD>message tag or <font face="sans-serif"> MPI_ANY_TAG</font> (integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> comm</TD><TD>communicator (handle)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> OUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Recv_init(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  
  <tt> int MPI_Recv_init_c(void *buf, MPI_Count count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Recv_init(buf, count, datatype, source, tag, comm, request, ierror) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">source</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <tt> MPI_Recv_init(buf, count, datatype, source, tag, comm, request, ierror) !(_c) <br> TYPE(*), DIMENSION(..), ASYNCHRONOUS :: <span style="white-space:nowrap">buf</span><br>INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Datatype), INTENT(IN) :: <span style="white-space:nowrap">datatype</span><br>INTEGER, INTENT(IN) :: <span style="white-space:nowrap">source</span>, <span style="white-space:nowrap">tag</span><br>TYPE(MPI_Comm), INTENT(IN) :: <span style="white-space:nowrap">comm</span><br>TYPE(MPI_Request), INTENT(OUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_RECV_INIT(BUF, COUNT, DATATYPE, SOURCE, TAG, COMM, REQUEST, IERROR) <br> &lt;type&gt; <span style="white-space:nowrap">BUF(*)</span><br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">DATATYPE</span>, <span style="white-space:nowrap">SOURCE</span>, <span style="white-space:nowrap">TAG</span>, <span style="white-space:nowrap">COMM</span>, <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
Creates a <em> persistent communication request</em>  
for a receive operation.  
The argument <font face="sans-serif"> buf</font> is marked as <font face="sans-serif"> OUT</font>  
because the user gives permission to write on the receive buffer by passing the  
argument to <font face="sans-serif"> MPI_RECV_INIT</font>.  
<P> 
A <em> persistent communication request</em> is <em> inactive</em> after it was created---no  
active communication is attached to the request.  
<P> 
A communication that uses a <em> persistent communication request</em>  
is <em> started</em> by the function <font face="sans-serif"> MPI_START</font>.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_START(<span style="white-space:nowrap">request</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> request</TD><TD>communication request (handle)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Start(MPI_Request *request) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Start(request, ierror) <br> TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">request</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_START(REQUEST, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">REQUEST</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The argument, <font face="sans-serif"> request</font>, is a handle returned by  
any of the <em> initialization</em> procedures  
for persistent point-to-point communication (the previous five procedures), or  
for partitioned point-to-point communication (see Chapter <a href="node87.htm#Node87">Partitioned Point-to-Point Communication</a>), or  
for persistent collective communication (see Sections <a href="node161.htm#Node161">Persistent Collective Operations</a> and <a href="node240.htm#Node240">Persistent Neighborhood Communication on Process Topologies</a>).  
The associated request should be <em> inactive</em>.  
The request becomes <em> active</em> once the call is made.  
<P> 
If the request is for a <em> ready mode send</em> operation, then  
a matching receive operation should be <em> started</em> before the call is made.  The  
communication buffer must not be  
modified  
after the call, and  
until the operation <em> completes</em>.  
<P> 
The call is <em> local</em>, with similar semantics to the nonblocking  
communication operations described in  
Section <a href="node73.htm#Node73">Nonblocking Communication</a>.  That is,  
a call to <font face="sans-serif"> MPI_START</font> with a  
request created by <font face="sans-serif"> MPI_SEND_INIT</font>  
starts a  
communication in the same manner as a call to <font face="sans-serif"> MPI_ISEND</font>;  
a call to <font face="sans-serif"> MPI_START</font> with a  
request created by <font face="sans-serif"> MPI_BSEND_INIT</font>  
starts a  
communication in the same manner as a call to  
<font face="sans-serif"> MPI_IBSEND</font>; and so on.  
<P> 
  
<TABLE><TR><TD COLSPAN=2>MPI_STARTALL(<span style="white-space:nowrap">count</span>, <span style="white-space:nowrap">array_of_requests</span>)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> IN</span> count</TD><TD>list length (nonnegative integer)</TD></TR>  
<TR><TD><span style="font-size:0.900em;"> INOUT</span> array_of_requests</TD><TD>array of requests (array of handles)</TD></TR>  
</TABLE>  
  <b> C binding</b><br>  <tt> int MPI_Startall(int count, MPI_Request array_of_requests[]) <br></tt>  
  <b> Fortran 2008 binding</b><br>  <tt> MPI_Startall(count, array_of_requests, ierror) <br> INTEGER, INTENT(IN) :: <span style="white-space:nowrap">count</span><br>TYPE(MPI_Request), INTENT(INOUT) :: <span style="white-space:nowrap">array_of_requests(count)</span><br>INTEGER, OPTIONAL, INTENT(OUT) :: <span style="white-space:nowrap">ierror</span> <br></tt>  
  <b> Fortran binding</b><br>  <tt> MPI_STARTALL(COUNT, ARRAY_OF_REQUESTS, IERROR) <br> <br>INTEGER <span style="white-space:nowrap">COUNT</span>, <span style="white-space:nowrap">ARRAY_OF_REQUESTS(*)</span>, <span style="white-space:nowrap">IERROR</span> <br></tt>  
<P> 
The execution of  
<font face="sans-serif"> MPI_STARTALL</font>  
has the same effect as the execution of  
<font face="sans-serif"> MPI_START</font>  
for each of the array elements  
in some arbitrary order.  
<font face="sans-serif"> MPI_STARTALL</font> with an array of length one  
is equivalent to <font face="sans-serif"> MPI_START</font>.  
<P> 
A communication started with a call to <font face="sans-serif"> MPI_START</font> or  
<font face="sans-serif"> MPI_STARTALL</font> is  
completed by a call to <font face="sans-serif"> MPI_WAIT</font>, <font face="sans-serif"> MPI_TEST</font>, or  
one of the derived functions described in  
Section <a href="node78.htm#Node78">Multiple Completions</a>.  The request becomes <em> inactive</em> after  
successful completion of such call.  The request is not deallocated  
and it can be activated anew by an <font face="sans-serif"> MPI_START</font> or  
<font face="sans-serif"> MPI_STARTALL</font> call.  
<P> 
A <em> persistent communication request</em> is deallocated by a call to  
<font face="sans-serif"> MPI_REQUEST_FREE</font>  
(Section <a href="node76.htm#Node76">Communication Completion</a>).  
The call to <font face="sans-serif"> MPI_REQUEST_FREE</font> can occur at any point in the program  
after the persistent request was created.  However, the request will be  
deallocated only after it becomes <em> inactive</em>.  
<em> Active</em> receive requests should not be <em> freed</em>. Otherwise, it will not be  
possible to check that the receive has <em> completed</em>.  
<em> Collective</em> operation requests  
(defined in  
Section <a href="node147.htm#Node147">Nonblocking Collective Operations</a> and Section <a href="node237.htm#Node237">Nonblocking Neighborhood Communication on Process Topologies</a>  
for nonblocking collective operations, and  
Section <a href="node161.htm#Node161">Persistent Collective Operations</a> and Section <a href="node240.htm#Node240">Persistent Neighborhood Communication on Process Topologies</a>  
for persistent collective operations)  
must not be <em> freed</em> while <em> active</em>.  
It is preferable, in general, to free requests when they are inactive.  If this  
rule is followed, then the functions  
described in this section will be invoked  
in a sequence of the form,  
<P><img width=374 height=23 src="img0.gif" alt="Image file"><P>
  
where  
<i>*</i> indicates zero or more repetitions.  
If the same <em> persistent communication request</em> is used in several concurrent  
threads, it is the user's responsibility to coordinate calls so that the  
correct sequence is obeyed.  
<P> 
<em> Inactive persistent requests</em> are not automatically <em> freed</em>  
when the associated communicator is disconnected (via <font face="sans-serif"> MPI_COMM_DISCONNECT</font>, see Section <a href="node306.htm#Node306">Releasing Connections</a>)  
or the associated World Model or Sessions Model is finalized (via <font face="sans-serif"> MPI_FINALIZE</font>, see Section <a href="node270.htm#Node270">Finalizing <font face="sans-serif"> MPI</font></a>, or <font face="sans-serif"> MPI_SESSION_FINALIZE</font>, see Section <a href="node274.htm#Node274">Session Creation and Destruction Methods</a>).  
In these situations, any further use of the request handle is erroneous.  
In particular, freeing associated inactive request handles after such a communicator disconnect or finalization is then impossible.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
Persistent request handles may bind internal resources  
such as <font face="sans-serif"> MPI</font> buffers in shared memory for providing efficient communication.  
Therefore, it is highly recommended to explicitly free inactive request handles,  
using <font face="sans-serif"> MPI_REQUEST_FREE</font>,  when they are no longer in use,  
and in particular before freeing or disconnecting the associated communicator  
with <font face="sans-serif"> MPI_COMM_FREE</font> or <font face="sans-serif"> MPI_COMM_DISCONNECT</font>  
or finalizing the associated session with <font face="sans-serif"> MPI_SESSION_FINALIZE</font>.  
 (<em> End of advice to users.</em>) <br> 
A send operation <em> started</em>  
with <font face="sans-serif"> MPI_START</font> can be <em> matched</em> with  
any receive operation and, likewise, a receive operation <em> started</em>  
with <font face="sans-serif"> MPI_START</font> can receive messages generated by any send  
operation.  
<P> 
 
<br> 
<em> Advice to users.</em>  
<P> 
To prevent problems with the argument copying and register optimization done  
  by Fortran compilers, please note the hints in  
Sections <a href="node479.htm#Node479">Problems With Fortran Bindings for <font face="sans-serif"> MPI</font></a>--<a href="node500.htm#Node500">Comparison with C</a>.  
 (<em> End of advice to users.</em>) <br> 

<P>
<hr>
<a href="node84.htm#Node84"><img width=16 height=16 src="previous.gif" alt="Previous"></a><a href="node55.htm#Node55"><img width=16 height=16 src="up.gif" alt="Up"></a><a href="node86.htm#Node86"><img width=16 height=16 src="next.gif" alt="Next"></a><br>
<b>Up: </b><a href="node55.htm#Node55"> Point-to-Point Communication</a>
<b>Next: </b><a href="node86.htm#Node86"> Null <font face="sans-serif"> MPI</font> Processes</a>
<b>Previous: </b><a href="node84.htm#Node84"> Cancel</a>
<p>
<HR>
Return to <A HREF="node627.htm">MPI-5.0 Standard Index</A><BR>
Return to <A HREF="http://www.mpi-forum.org/index.html">MPI Forum Home Page</A><BR>
<HR>
<FONT SIZE=-1>(Unofficial) MPI-5.0 of June 9, 2025<BR>
HTML Generated on March 2, 2025
</FONT>
</body>
</html>
